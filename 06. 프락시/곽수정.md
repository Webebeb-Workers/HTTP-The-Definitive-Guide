# 6. 프락시

프락시에 대한 자세한 소개와 활용방법, 동작 원리, 설정 방법 등을 소개하는 챕터

## 6.1 웹 중개자

- 웹 프락시 서버: 클라이언트 입장에서는 트랜잭션을 수행하는 중개인
- HTTP 프락시 서버: 웹 서버이기도 하고 웹 클라이언트이기도 함 (요청도 보내고 응답도 받기 때문)

<img width="584" alt="image" src="https://github.com/user-attachments/assets/61c8fdae-ad06-4490-bec2-0fcc5f1b5cae" />

### 6.1.1 개인 프락시와 공유 프락시

**개인 프락시**

- 하나의 클라이언트만을 위한 프락시
- 흔하지는 않지만 클라이언트 컴퓨터에서 직접 실행되는 형태로도 사용됨
- 브라우저 기능 확장, 성능 개선, 무료 ISP 서비스를 위한 광고를 운영하기 위한 작은 프락시

Q. ISP는 뭔가요?

**공용 프락시**

- 여러 클라이언트가 함께 사용하는 프락시
- 대부분의 프락시는 공용 프락시임 (비용효율 높음)
- 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문에 몇몇 애플리케이션은 프락시를 이용하는 사용자가 많을수록 유리함

Q. 어떤 애플리케이션이 어떻게 이득을 취하는건지 예시가 궁금함

### 6.1.2 프락시 대 게이트웨이

**프락시와 게이트웨이 차이점**

- 프락시: 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결함
  - 다른 버전의 HTTP 프로토콜 변환하기도 함
  - 상용 프락시 서버는 SSL 보안 프로토콜, SOCKS 방화벽, FTP 접근 등을 위한 게이트웨이 기능을 구현하기도 한다고 함
- 게이트웨이: 서로 다른 프로토콜을 사용하는 둘 이상을 연결함 (like 프로토콜 변환기)

<img width="579" alt="image" src="https://github.com/user-attachments/assets/004ceec5-a315-4eeb-9213-e3f634b01575" />

## 6.2 왜 프락시를 사용하는가?

- 보안 개선, 성능 개선, 비용 절약, 트래픽 감시 및 수정 가능

**1) 어린이 필터**

- 성인 콘텐츠 차단용 필터링 프락시 사용으로 접근 강제 거부 가능

<img width="584" alt="image" src="https://github.com/user-attachments/assets/69db4da9-63ab-4f0b-b71d-7efb740be7cd" />

**2) 문서 접근 제어자**

- 웹 서버들과 웹 리소스에 대한 단일한 접근 제어 전략 구현
- 기업 내 각기 다른 조직에서 관리되는 리소스 접근 제어를 중앙 프락시 서버에서 접근 제어 설정 가능

<img width="580" alt="image" src="https://github.com/user-attachments/assets/42a6ea17-1e75-45a2-a9c4-5290a1b315da" />

**3) 보안 방화벽**

- 네트워크 보안을 강화하기 위한 프락시 서버 (e.g. 보안 방화벽)
- 조직 in/out 응용 레벨 프로토콜의 흐름을 통제하거나 바이러스 제거 웹, 이메일 프락시가 사용 가능한 후크(hook - 트래픽 감시) 제공

<img width="577" alt="image" src="https://github.com/user-attachments/assets/d2d3425b-c611-447a-8088-35598e8eb0be" />

**4) 웹 캐시**

- 인기 있는 문서의 로컬 사본 관리, 요청 들어오면 빠르게 제공해서 느리고 비싼 인터넷 커뮤니케이션 줄임

<img width="579" alt="image" src="https://github.com/user-attachments/assets/343a4318-d0fd-4599-8986-e0665f8b2bf1" />

**5) 대리 프락시**

- 대리 / 리버스 프락시
- 웹 서버인 것처럼 위장해 웹 서버 요청을 받아 콘텐츠의 위치 찾아내기 위해 다른 서버와 커뮤니케이션함
- 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용됨 = 서버 가속기
- 콘텐츠 라우팅 기능과 결합되어 주문형 복제 콘텐츠의 분산 네트워크를 만들기 위해 사용될 수 있음

> 주문형 복제: 사용자의 요청이 있을 때마다 해당 콘텐츠를 가까운 서버에 자동으로 복사하여 저장하는 기능
>
> e.g. 넷플릭스처럼 모든 서버에 모든 콘텐츠를 저장하는 대신, 특정 지역에서 자주 요청되는 콘텐츠만 해당 지역 서버에 선택적으로 복제해둠 > 사용자가 요청 시 해당 콘텐츠가 있는 가장 가까운 서버를 찾아 연결해줌

<img width="580" alt="image" src="https://github.com/user-attachments/assets/1ed57bc8-f36f-41f1-bad1-50911ba3eeac" />

**6) 콘텐츠 라우터**

- 인터넷 트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹 서버로 유도함
- 사용자/콘텐츠 제공자가 더 높은 성능을 위해 비용을 지불한 경우 > 가까운 복제 캐시로 전달
- 필터링 서비스에 가입한 경우 HTTP 요청이 필터링 프락시를 통과하도록함

<img width="581" alt="image" src="https://github.com/user-attachments/assets/605947ac-c6bb-4a6a-9b53-4c1aa31e3a5d" />

**7) 트랜스코더**

- 콘텐츠를 클라이언트에게 전달 전 본문 포맷을 수정할 수 있음
- 트랜스코딩: 데이터의 표현 방식을 변환하는 것
- 이미지 크기 줄이거나, 색 강도를 줄이거나, GIF > JPG 이미지로 변환하거나 텍스트 파일 압축하기 가능
- 외국어 문서 변환도 가능

<img width="581" alt="image" src="https://github.com/user-attachments/assets/90d206d6-d193-469d-9d7c-9c433378bbee" />

**8) 익명화 프락시**

- HTTP 메시지에서 신원 식별용 특성 (IP 주소, 특정 헤더, 쿠키, 세션 아이디 등) 제거하여 개인 정보 보호 및 익명성 보장 가능
  - User-Agent 헤더 에서 사용자의 컴퓨터와 OS 종류 제거
  - 사용자의 이메일 주소를 보호하기 위해 From 헤더 제거
  - 어떤 사이트를 거쳐서 방문했는지 알기 어렵게 하기 위해 Referer 헤더 제거
  - 프로필과 신원 정보를 없애기 위해 Cookie 헤더 제거

<img width="581" alt="image" src="https://github.com/user-attachments/assets/e36833cc-5eb2-4124-8baf-5bb993c17f92" />

## 6.3 프락시는 어디에 있는가?

- 프락시는 어떻게 언제 네트워크 아키텍처상에 배치될까?
- 네크워크 배치, 연쇄 계층 이루는 방법, 트래픽이 프락시를 찾아가는 방법

### 6.3.1 프락시 서버 배치

**a) 출구 프락시**

- 로컬 네트워크 출구에 위치
- 회사 밖 해킹 방지 방화벽 제공을 위해, 인터넷 요금 절약 및 인터넷 트래픽 성능 개선을 위해, 콘텐츠 필터링을 위해 사용

**b) 접근(입구) 프락시**

- 고객으로부터의 모든 요청을 종합적으로 처리하기 위해, 다운로드 속도 개선 및 인터넷 대역폭 비용을 줄이기 위해 ISP 접근 지점에 위치해 많이 찾는 문서 사본으로 캐싱함

**c) 대리 프락시**

- 네트워크 가장 끝에 있는 웹 서버 바로 앞이 위치
- 웹 서버로 향하는 모든 요청 처리 + 필요할 때만 웹 서버에 자원 요청
- 보안 기능 추가 및 성능을 개선하기 위해 사용
- 웹 서버의 이름 + IP 주소로 가장함

**d) 네트워크 교환 프락시**

- 인터넷 피어링 교환 지점들에 놓여 캐시로 인터넷 교차로 혼잡 완화, 트래픽 감시를 위해 사용

<img width="575" alt="image" src="https://github.com/user-attachments/assets/0c4b040e-b044-492b-9759-105553fbd956" />

### 6.3.2 프락시 계층

- 부모 프락시: 인바운드 프락시 (서버에 가까운쪽)
- 자식 프락시: 아웃바운드 프락시 (클라이언트에 가까운쪽)

<img width="579" alt="image" src="https://github.com/user-attachments/assets/c7af7fb1-16ce-48e9-b450-e5c4f612c9c9" />

**프락시 계층 콘텐츠 라우팅**

위 사진 예는 정적이지만 상황에 맞게 메시지를 다양하고 유동적인 프락시 서버와 원 서버들의 집합에에 보낼 수 있음

> 웹 서버가 콘텐츠 분산 서비스 비용을 지불한 경우, 프락시는 가까운 캐시 서버에서 콘텐츠를 가져오거나, 없다면 원본 서버에서 직접 가져옴
>
> 이미지 요청의 경우, 프락시는 특수한 압축 프락시로 요청을 전달하여 이미지를 압축함으로써 느린 인터넷 환경에서도 빠른 다운로드가 가능하게 함

- 부하 균형: 자식 프락시가 부하 분산을 위해 현재 부모들의 작업량 수준에 근거해 부모 프락시 고름
- 지리적 인접성에 근거한 라우팅: 자식 프락시는 원 서버의 지역을 담당하는 부모 선택 가능
- 프로토콜/타입 라우팅: URI에 근거해 다른 부모나 원 서버로 라우팅 가능
- 유료 서비스 가입자를 위한 라우팅: 대형 캐시나 성능 개선을 위한 압축 엔진으로 라우팅 가능

<img width="578" alt="image" src="https://github.com/user-attachments/assets/fd921d26-d427-462a-ba02-21f47000e636" />

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

클라이언트 트래픽이 어떻게 프락시로 가도록 만드는걸까?에 대한 4가지 방법

**1) 클라이언트를 수정한다**

- 브라우저를 포함한 많은 웹 클라이언트들은 수동/자동 프락시 설정 지원함
- 클라이언트가 프락시를 사용하도록 설정되어 있다면 HTTP 요청을 바로 원 서버가 아닌 프락시로 보냄

**2) 네트워크를 수정한다**

- 클라이언트는 알지도 못하고 간섭 불가능한 상태에서 네트워크 인프라 가로채 웹 트래픽을 프락시로 가도록 함
- 스위칭 장치 + 라우팅 장치 필요로 함, 인터셉트 프락시라함

**3) DNS 이름공간을 수정한다**

- 웹 서버 앞에 위치하는 대리 프락시는 웹 서버 이름 + IP 주소 자기가 직접 사용함
- DNS 이름 테이블을 수동으로 편집하거나, 적절한 프락시나 서버 계산해주는 동적 DNS 서버 이용해 조정 가능

**4) 웹 서버를 수정한다**

- 웹 서버가 HTTP 리다이렉션 명령(응답코드 305)를 클라이언트에게 돌려줘서 프락시로 리다이렉트하도록 함

<img width="582" alt="image" src="https://github.com/user-attachments/assets/25ac8aaa-798e-4a1e-9f94-1f582d810a08" />

## 6.4 클라리언트 프락시 설정

브라우저가 프락시 설정하는 여러가지 방법

### 6.4.0 브라우저 기본 설정

브라우저 밴더나 배포자는 브라우저를 소비자에게 전달하기 전에 프락시 미리 설정 가능

### 6.4.1 클라이언트 프락시 설정: 수동

프락시를 사용하겠다고 명시적으로 설정함 (프락시 호스트 + 포트 지정)

### 6.4.2 클라이언트 프락시 설정: PAC 파일

자바스크립트 프락시 자동 설정(PAC) 파일에 대한 URI 제공

언제 어떤 프락시 서버를 써야하는지 판단하기 위해 그 자바스크립트 파일 가져와 실행함

- 문서에 접근할 때마다 상황에 맞게 계산해주는 작은 자바스크립트 프로그램 = 동적인 해결책
- PAC 파일 사용하려면 자바스크립트 PAC 파일의 URI를 브라우저에 설정해야함
  1. 브라우저에 PAC 파일의 위치(URI)를 설정해둠
  2. 사용자가 웹사이트에 접속할 때마다 PAC 파일 안의 자바스크립트가 실행됨
  3. 이 스크립트가 상황에 따라 적절한 프락시를 자동으로 선택해줌

<img width="599" alt="image" src="https://github.com/user-attachments/assets/86f7558b-6be7-4c8f-89c3-cbc3fc7d84fe" />

```js
function FindProxyForURL(url, host) {
  if (url.substring(0, 5) == 'http:') {
    return 'PROXY http-proxy.mydomain.com:8080'; // HTTP 접속시
  } else if (url.substring(0, 4) == 'ftp:') {
    return 'PROXY ftp-proxy.mydomain.com:8080'; // FTP 접속시
  } else {
    return 'DIRECT'; // 그 외의 경우
  }
}
```

### 6.4.3 클라이언트 프락시 설정: WPAD

대부분의 브라우저는 자동설정 파일 다운받을 수 있는 '설정 서버'를 자동으로 찾아주는 웹 프락시 자동발견 프로토콜(Web Proxy Autodiscovery Protocol) 제공함

- 브라우저에게 알맞은 PAC 파일을 자동으로 찾아주는 알고리즘

  1. PAC URI를 찾기 위해 WPAD를 사용함
  2. 주어진 URI에서 PAC 파일을 가져옴
  3. 프락시 서버를 알아내기 위해 PAC 파일을 실행함
  4. 알아낸 프락시 서버를 이용해서 요청을 처리함

- 올바른 PAC 파일 알아내기 위해 성공할 때까지 아래 각 기법 하나씩 시도해봄
  - 동적 호스트 발견 규약(DHCP)
  - 서비스 위치 규약(SLP)
  - DNS 잘 알려진 호스트명
  - DNS SRV 레코드
  - DNS TXT 레코드 안의 서비스 URI

## 6.5 프락시 요청의 미묘한 특징들

프락시 서버 요청에서 오해하기 쉬운 측면들 존재

### 6.5.1 프락시 URI는 서버 URI와 다르다

- 클라이언트 > 웹 서버 요청 시 스킴, 호스트, 포트번호가 없는 부분 URI 가짐

```
GET /index.html HTTP/1.0
User-Agent: SuperBrowservl.3
```

- 클라이언트 > 프락시 요청 시 완전한 URI 가짐

```
GET http://www.marys-antiques.com/index.html HTTP/1.0 User-Agent: SuperBrowser vl.3
```

- 이전에는 단일 서버와 직접 대화했기 때문에 부분 URI만 보냄 > 프락시 부상으로 인해 부분 URI가 문제가 되면서 클라이언트가 프락시 사용 시 완전한 URI를 보내도록 함

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 가상 호스팅 웹 서버에서도 '스킴/호스트/포트번호 누락'으로 인해 부분 URI로 요청 수신 시 웹 사이트의 호스트명을 알아야 함
- **명시적인 프락시**는 요청 메시지가 완전한 URI를 갖도록 해 문제를 해결함
- **가상으로 호스팅 되는 웹 서버**는 호스트와 포트에 대한 정보가 담겨 있는 Host 헤더 요구함

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

- 클라이언트가 프락시 미사용으로 설정되어 있어도, 대리 프락시나 인터셉트 지날 수 있음
  - 이런 경우에는 클라이언트가 웹 서버와 대화하고 있다고 생각해 완전한 URI 보내지 않음
- 대리 프락시는 앞에서 설명한 바와 같이 원 서버의 호스트 명과 아이피 주소를 사용해 원 서버를 대신하는 프락시 서버
- 인터셉트 프락시는 네트워크 흐름에서 클라이언트에서 서버로 가는 트래픽을 가 로채 캐시된 응답을 돌려주는 등의 일을 하는 프락시 서버다. 인터셉트 프락시는 클라이언트에서 서버로 가는 트래픽을 가로채기 때문에, 웹 서버로 보내는 부분 URI를 얻게 됨

<img width="581" alt="image" src="https://github.com/user-attachments/assets/2bde343b-f0b2-4ffe-af42-7812d68f8530" />

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 다목적 프락시 서버: 완전한 URI + 부분 URI
- 명시적 프락시 요청: 완전한 URI
- 그 외 프락시 요청: 부분 URI
- 웹 서버 요청: 가상 Host 헤더 사용

- 완전한 URI가 주어졌다면, 프락시는 그것을 사용해야댐
- 부분 URI가 주어졌고 Host 헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아내야 함
- 부분 URI가 주어졌으나 Host 헤더가 없다면, 다음의 방법으로 원 서버를 알아내야 함
  - **대리 프락시**: 프락시에 실제 서버 주소화 포트 번호 설정 가능성 유
  - **인터셉트 프락시**: 프락시에 원 IP 주소와 포트번호 사용할 수 있게 해뒀을 가능성 유
- 모두 실패 시 에러 메시지 반환

### 6.5.5 전송 중 URI 변경

- URI 변경은 다운스트림 서버와 상호운용성 문제를 일으킬 수 있으므로 유의해야함
- 몇몇 프라시는 다운 홉으로 보내기 전에 정규화 하기도 함
  - HTTP 포트 :80으로 변경 하거나 예약 글자 교체하거나
- HTTP 명세에는 인터셉트 프락시가 절대 경로 고쳐쓰는거 금지함 (빈경로만 /로)

### 6.5.6 URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)

- 프락시 존재 X: 사용자가 타이핑한 URI로 대응되는 IP 주소 검색
  - 호스트명 발견 O: IP 주소들 연결 계속 시도
  - 호스트명 발견 X: 브라우저가 호스트명 확장을 제공하고자 여러 시도 함
    - www 접두사, .com 접미사
    - 해석 불가능한 URI > 서드파티 사이트로 넘김
    - 앞부분만 입력해도 자동으로 도메인 검색

### 6.5.7 프락시 없는 URI 분석(URI Resolution)

- 프락시 없는 브라우저 호스트명 자동확장 예시 및 진행 과정

<img width="581" alt="image" src="https://github.com/user-attachments/assets/f809b0d5-a97d-4233-ac1d-a5f0cdd52479" />

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

- 명시적인 프락시 사용 시 위와 같은 브라우저의 편리한 확장 사용 불가, 부분 호스트명 자동확장 않함
- 브라우저의 URI가 프락시를 그냥 지나쳐버림

<img width="581" alt="image" src="https://github.com/user-attachments/assets/0b864af3-80b3-4fb3-803e-affb8823ab8a" />

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 보이지 않는 인터셉트 프락시와 함께일 때 클라이언트 입장에서는 프락시가 존재하지 않는 것임

<img width="580" alt="image" src="https://github.com/user-attachments/assets/17951da6-8730-4566-a6b1-acaeaebbf539" />

1. 사용자가 ‘oreilly’를 입력함

   - 브라우저의 URI 위치 창에 ‘oreilly’를 입력함

2. DNS 조회 시도 및 실패함

   - 브라우저가 ‘oreilly’에 대한 DNS 조회를 시도함
   - DNS 서버가 해당 호스트를 찾지 못해 실패함

3. 브라우저가 자동 확장하여 ‘www.oreilly.com’으로 변경함

   - 브라우저가 ‘oreilly’를 ‘www.oreilly.com’으로 자동 변환함
   - DNS 서버에 ‘www.oreilly.com’ 조회 요청을 보냄
   - DNS 서버가 성공적으로 IP 주소를 반환함

4. 클라이언트가 IP 주소를 사용해 서버 접속을 시도함

   - 클라이언트는 받은 IP 주소들 중 하나로 접속을 시도함
   - 죽은 IP일 가능성이 있어, 성공할 때까지 다른 IP도 시도함
   - 하지만 인터셉트 프락시가 있는 경우, 원래 서버 대신 프락시가 요청을 가로챔
   - 클라이언트는 원래 서버와 연결했다고 생각하지만, 실제로는 프락시가 응답함

5. 프락시가 원 서버와의 연결을 시도함

   - 프락시는 받은 IP 주소를 사용해 원 서버와의 연결을 시도함
   - 하지만 해당 IP가 실제로는 다운된 서버일 수 있음

6. 프락시는 장애 허용(fault tolerance)을 처리해야 함
   - 원 서버가 다운되었을 경우, 프락시는 호스트 헤더를 다시 분석하거나 역방향 DNS 조회(reverse DNS lookup)를 통해 다른 IP를 시도해야 함
   - 명시적 프락시와 인터셉트 프락시 모두 이러한 장애 허용 기능을 제공해야 함
   - 특히, 브라우저가 명시적인 프락시를 사용하도록 설정된 경우, 장애 허용 처리는 프락시에 의존하게 됨

## 6.6 메시지 추적

<img width="578" alt="image" src="https://github.com/user-attachments/assets/b3488553-2e20-4b5c-857a-ae1d5d7dbc6c" />

프락시가 점점 더 흔해지면서 프락시를 넘나다는 메시지 흐름을 추적하고 문제점을 찾아내는 것도 필요해짐

### 6.6.1 Via 헤더

- 중간 노드 (프락시/게이트웨이)를 지날 때마다 Via 목록의 끝에 반드시 추가되어야 함

<img width="579" alt="image" src="https://github.com/user-attachments/assets/154d49b8-757c-4f4c-a697-6bf068de497f" />

```
Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
```

- HTTP/1.1 프로토콜을 구현한 proxy-62.irenes-isp.net라 불리는 프락시
- HTTP/1.0 프로토콜을 구현한 cache.joes-hardware.com이라 불리는 프락시

- 메시지 전달 과정 내 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용됨
- 라우팅 루프 탐지를 위해 프락시가 요청 보내기 전 자신을 가리키는 유니크한 문자열을 Via 헤더에 삽입해야하고, 들어온 요청에도 라우팅 루프를 만족하는 헤더가 있는지 확인해야 함

> 라우팅 루프: 네트워크에서 데이터 패킷이 목적지에 도달하지 못하고 계속 같은 경로를 반복해서 돌고 있는 상황

**Via 문법**

```
Via = "Via:" waypoint *("," waypoint)
waypoint = received-protocol received-by [comment]
received-protocol = [protocol-name "/"] protocol-version
received-by = host [:port] | pseudonym
```

- Via: - 헤더 시작
- waypoint - 경유지점 정보 (각 프락시의 정보)
- received-protocol - 사용된 프로토콜 정보
- received-by - 프락시 서버의 호스트명이나 가명
- comment - 선택적인 주석

**Via 요청과 응답 경로**

응답 Via 헤더는 ↔️ 언제나 요청의 Via 헤더와 반대임

<img width="580" alt="image" src="https://github.com/user-attachments/assets/6376d6d9-f362-4d35-8010-eea5db227721" />

**Via와 게이트웨이**

- 몇몇 프락시는 서버에게 비 HTTP 프로토콜을 사용할 수 있는 게이트웨이 기능 제공함
- Via 헤더에서 프로토콜 변환 기록하므로 HTTP 애플리케이션은 프락시 연쇄에서 프로토콜 능력과 변환이 있었는지 알아챌 수 있음

<img width="579" alt="image" src="https://github.com/user-attachments/assets/33d3538d-5de8-4592-83a0-0e0b3c70e0bc" />

**Server 헤더와 Via 헤더**

```
Server: Apache/1.3.14 (Unix) PHP/4.0.4
Server: Netscape-Enterprise/4.1
Server: Microsoft-IIS/5.0
```

- 원 서버에 의해 사용되는 소프트웨어 알려줌
- 응답 메시지 프락시 통과 시 프락시가 Server 헤더 수정하면 안됨

**Via가 개인정보 보호와 보안에 미치는 영향**

- 보안을 위해 방화벽 뒤에 있는 내부 서버들의 실제 호스트명과 포트를 Via 헤더에 그대로 노출하면 안됨
- 대신 가명(pseudonym)을 사용해야 함

```
// FROM
Via: 1.0 foo, 1.1 devirus.company.com, 1.1 access-logger.company.com
// TO
Via: 1.0 foo, 1.1 concealed-stuff
```

- 같은 조직 내부의 여러 프락시들은 하나의 가명으로 합칠 수 있음
- 단, 프로토콜 버전이 다르면 합치면 안됨
- 이미 가명을 사용 중인 경우는 합치면 안됨

### 6.6.2 TRACE 메서드

- TRACE 메서드의 목적

  - 프락시를 통과하면서 HTTP 요청이 어떻게 변경되는지 추적
  - 프락시 네트워크 디버깅에 사용
  - 서버는 받은 요청을 그대로 응답 본문에 포함해서 돌려보냄
  - Content-Type은 message/http, 상태는 200 OK

- Max-Forwards 헤더

  - TRACE와 OPTIONS 요청이 거칠 수 있는 프락시 홉(hop) 수를 제한
  - 정수값을 가지며, 각 프락시를 지날 때마다 1씩 감소
  - 값이 0이 되면 더 이상 전달하지 않고 즉시 응답을 돌려보냄

- 프락시 네트워크의 무한 루프 방지
- 특정 프락시까지만 요청을 전달하여 디버깅
- 프락시 연쇄(chain) 테스트

<img width="599" alt="image" src="https://github.com/user-attachments/assets/43e55dc5-15be-49ba-810f-844dabcc5634" />

## 6.7 프락시 인증

- 접근 제어 장치로서 활용되는 프락시
  - 제한된 콘텐츠에 대한 요청 > 프락시 서버: 접근 자격 요구하는 407 Proxy Authorization Required 상태 코드 + 자격 제출 방법을 설명한 Proxy-Authenticate 헤더 필드와 함께 반환
  - 클라이언트가 407 응답 수신 시 로컬 DB/사용자에게 확인 후 요구되는 자격 수집
  - 자격 획득 이후 요구되는 자격을 Proxy-Authenticate 헤더 필드에 담아 요청을 다시 보냄
  - 자격이 유효하면 원 요청을 연쇄를 따라 통과시키고, 유효하지 않다면 407 응답 보냄
- 프락시 인증은 인증에 참여하는 프락시가 프락시 연쇄상에 여러 개 있을 때 잘 동작하지 않음
  - 각 프락시별로 인증 정보를 구분할 수 있는 HTTP 확장 기능을 제안했지만 널리 구현되지 않음

<img width="581" alt="image" src="https://github.com/user-attachments/assets/230610fc-139e-462f-9b2f-0a366263d9b4" />

## 6.8 프락시 상호운용성

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 이해 못하는 헤더 포함할 수 있음 > 반드시 그대로 전달 해야함 (같은 이름의 헤더 필드 여러개 - 상대적인 순서도 유지)
- HTTP/1.1은 확장 메서드를 허용하기 때문에 오늘날의 대부분 네트워크에서는 지원않는 메서드 통과 가능한 프락시들만 살아남음

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

- HTTP OPTIONS 메서드: 서버/웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 함

```
// 1)
OPTIONS * HTTP/1.1
// 2)
OPTIONS http://www.joes-hardware.com/index.html HTTP/1.1 static HTML file wouldn't accept a POST method.
```

- OPTIONS 요청 URI가 \* 이면 서버 전체의 능력에 대해 묻는거심
- OPTIONS 요청 URI가 실제 리소스라면 특정 리소스에 대해 가능한 기능 묻는거심
- 성공 시 200 OK 응답 + 지원하는 메서드 서술한 Allow 헤더 or 선택적으로 응답 본문 활용

### 6.8.3 Allow 헤더

```
Allow: GET, HEAD, PUT
```

- 요청 URI에 대한 메서드 지원 상황 열거함
- 또는 새 리소스가 지원했으면 하는 메서드 추천용으로 요청 헤더로 사용될 수 있음
