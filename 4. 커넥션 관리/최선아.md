# 4 커넥션 관리

## 4.1 TCP 커넥션

- HTTP 통신은 TCP/IP를 통해 이루어짐
- 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌 지 않고 안전하게 전달됨

<img width="415" alt="image" src="https://github.com/user-attachments/assets/c9506550-e278-4d88-b17d-10f90b3f80c4" />

1. URL에서 호스트명 추출
2. 호스트명으로 IP주소 얻음
3. URL로 포트 번호 얻음
4. IP와 포트번호로 TCP 커넥션 생성
5. 브라우저가 서버로 HTTP 요청
6. 서버가 브라우저에게 HTTP 응답
7. 커넥션 종료

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

<img width="415" alt="image" src="https://github.com/user-attachments/assets/45559863-6b4c-4ec4-8bd0-e7d4d61a7bfe" />

- TCP는 HTTP의 기반이 되어 데이터를 순서대로 정확하게 전달하는 신뢰성 있는 통신 방식을 제공함

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송됨

<img width="415" alt="image" src="https://github.com/user-attachments/assets/06b5859a-ecea-4750-887d-3886aaed3d50" />

<img width="419" alt="image" src="https://github.com/user-attachments/assets/42542fbf-95ec-458f-825e-2a8ba894be77" />

- TCP는 IP 패킷（혹은 IP 데이터그램）이라고 불리는 작은 조각을 통해 데이터를 전송함
- TCP/IP 프로토콜 스택에서:

  1. HTTP는 최상위 계층에서 메시지를 전송
  2. TCP는 이 메시지를 세그먼트로 분할
  3. IP는 이 세그먼트를 패킷으로 감싸서 전달
  4. 각 패킷은 IP 패킷 헤더(20B), TCP 세그먼트 헤더(20B), 데이터로 구성

### 4.1.3 TCP 커넥션 유지하기

- TCP 커넥션은 4가지 값(발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트)으로 유일한 커넥션을 생성하고 식별함
- 서로 다른 TCP 커넥션은 이 4가지 값이 모두 동일할 수 없지만 일부 값은 동일할 수 있음

<img width="420" alt="image" src="https://github.com/user-attachments/assets/a8f64f02-aae7-40a7-a113-9e5afa9819c6" />

<img width="416" alt="image" src="https://github.com/user-attachments/assets/424c98bf-0d23-4055-895f-5cacea6dd452" />

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API: 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공함
- 소켓 API는 TCP/IP의 복잡성을 추상화하여 서버-클라이언트 간 TCP 커넥션 생성과 데이터 통신을 단순화함

<img width="426" alt="image" src="https://github.com/user-attachments/assets/633d2a30-2ae5-4592-803c-853ddab1feee" />

**클라이언트와 서버가 TCP 소켓 인터페이스를 사용하여 상호작용하는 방법**

<img width="416" alt="image" src="https://github.com/user-attachments/assets/2fbaa2fa-e500-4757-b4bd-e39e8dfa3d2c" />

## 4.2 TCP의 성능에 대한 고려

- HTTP의 성능은 하위 계층인 TCP의 성능에 직접적인 영향을 받으므로, 더 좋은 성능의 HTTP 애플리케이션 개발을 위해서는 TCP 성능의 특성을 이해하는 것이 중요함

### 4.2.1 HTTP 트랜잭션 지연

<img width="416" alt="image" src="https://github.com/user-attachments/assets/d3b2e3ca-a7fe-4fed-8250-fd7f3e115706" />

- HTTP 트랜잭션의 주요 지연 요인을 순서대로 정리하면:

  1. DNS 조회 지연: URI의 호스트명을 IP 주소로 변환하는 시간
  2. TCP 연결 지연: 새로운 TCP 커넥션 설정에 필요한 시간
  3. 요청 전송 지연: HTTP 요청이 TCP를 통해 서버로 전송되는 시간
  4. 응답 전송 지연: 서버의 응답이 클라이언트에게 전송되는 시간

- 이런 TCP 네트워크 지연은 하드웨어 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메시지의 크기, 클라이언트와 서버 간의 거리에 따라 크게 달라짐

### 4.2.2 성능 관련 중요 요소

| 지연 요인              | 설명                                                   |
| ---------------------- | ------------------------------------------------------ |
| TCP 핸드셰이크         | 커넥션 설정을 위한 초기 연결 과정에서의 지연           |
| 느린 시작(slow-start)  | 인터넷 혼잡 제어를 위한 점진적 속도 증가 메커니즘      |
| 네이글(Nagle) 알고리즘 | 작은 데이터를 모아서 한 번에 전송하는 과정의 지연      |
| 확인응답 지연          | 데이터와 응답을 하나의 패킷으로 전송하는 과정의 지연   |
| TIME_WAIT 지연         | 커넥션 종료 후 일정 시간 포트를 재사용하지 못하는 지연 |

### 4.2.3 TCP 커넥션 핸드셰이크 지연

<img width="418" alt="image" src="https://github.com/user-attachments/assets/6780da19-7d02-4006-a247-48035261b541" />

- TCP 핸드셰이크(3-way handshake) 과정을 단계별로 정리하면:

  - 클라이언트 → 서버: SYN 플래그가 설정된 TCP 패킷 전송 (40~60바이트)
  - 서버 → 클라이언트: SYN + ACK 플래그가 설정된 TCP 패킷으로 응답
  - 클라이언트 → 서버: 최종 확인응답(ACK) 전송 (이때 데이터도 함께 전송 가능)

- 작은 HTTP 트랜잭션의 경우, 전체 처리 시간의 50% 이상이 TCP 연결 구성에 소요되는데, 이러한 TCP 구성 지연을 줄이기 위해 HTTP는 기존 커넥션을 재사용하는 방식을 사용함

### 4.2.4 확인응답 지연

- TCP의 데이터 전송 신뢰성 보장 메커니즘 원리:

  1. 각 TCP 세그먼트에 순번과 체크섬 포함
  2. 수신자는 정상 수신시(세그먼트를 온전히 받으면) 확인응답(ACK) 전송
  3. 송신자는 확인응답 미수신 시 재전송 수행

- 확인응답 최적화:

  - 데이터 패킷에 확인응답을 '통합(piggyback)' 전송
  - 0.1~0.2초간 확인응답을 지연시켜 통합 기회 모색
  - 통합 기회가 없으면 별도 패킷으로 전송

- HTTP에서의 한계:
  - 요청-응답 구조로 인해 통합 기회 감소
  - 확인응답 지연으로 인한 성능 저하 발생

### 4.2.5 TCP 느린 시작(slow start)

- 작동 원리:

  - TCP는 새로운 연결에서 처음에는 전송 속도를 제한
  - 성공적인 전송이 확인될 때마다 전송 가능한 패킷 수를 2배로 증가
  - 패킷 전송 성공 → 2개 더 전송 가능 → 4개 → 8개 → ...

- 목적:

  - 인터넷의 급작스러운 부하와 혼잡을 방지
  - ex) 처음부터 많이 보내는 것 = 교통상황 모르고 차량 100대를 한꺼번에 도로에 투입, 점진적 증가 = 차량 몇 대 보내보고 막히면 조절하고 괜찮으면 2배 투입

- 영향:
  - 새로운 TCP 연결은 초기에 속도가 느리고 기존에 쓰던 '튜닝된' TCP 연결이 더 효율적
  - 이로 인해 HTTP는 기존 연결 재사용(지속 커넥션) 방식을 선호

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘 작동 원리:

  - 작은 패킷들을 모아서 큰 패킷으로 만들어 전송
  - 최대 크기(LAN: 1,500바이트, 인터넷: 수백 바이트)까지 데이터를 버퍼에 누적
  - 이전 패킷의 확인응답을 받았을 때만 작은 패킷 전송 허용

- 목적:

  - 네트워크 효율성 증가
  - 작은 패킷으로 인한 오버헤드 감소 (각 패킷마다 40바이트의 헤더 필요)

- HTTP에서의 문제점:

  - 작은 HTTP 메시지가 불필요하게 지연될 수 있음
  - 확인응답 지연 알고리즘과 충돌 시 심각한 성능 저하
  - 해결책: TCP_NODELAY 설정으로 비활성화하고 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들기

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT의 목적과 동작:

  - TCP 연결 종료 후 일정 시간(보통 2MSL, 약 2분) 동안 해당 포트 재사용 제한
  - 이전 연결의 패킷이 새로운 연결에 섞이는 것을 방지
  - IP주소와 포트번호 조합을 제어 블록에 기록

- 포트 고갈 문제:

  - 가용 포트 수(약 60,000개) ÷ 대기 시간(120초) = 초당 최대 500개 연결 가능
  - 주로 성능 테스트 시 문제 발생(발신지 IP 주소, 발신지 포트, 목적지 IP 주소, 목적지 포트 중 발신지 포트만 변경할 수 있기 때문)
  - 실제 운영 환경에서는 보통 문제되지 않음

- 해결 방안:
  - 더 많은 클라이언트 장비 사용하거나 여러 개의 가상 IP 주소 사용
  - 2MSL 시간 조정 (주의 필요)
