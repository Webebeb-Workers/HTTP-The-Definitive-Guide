# TCP 커넥션

HTTP의 연결에 대한 과정, 유지 등을 여기서 알아본다.

## TCP 커넥션

HTTP 통신은 TCP/IP를 통해 이루어지며, 클라이언트와 서버 간의 안전한 데이터 전송을 보장함.

### 과정

<img width="597" alt="image" src="https://github.com/user-attachments/assets/b63c2769-188c-47cf-874d-3801c2fba92c" />

1. URL에서 호스트명 추출
2. 호스트명으로 IP 주소 찾기
3. 포트 번호 얻기
4. TCP 커넥션 생성
5. HTTP 요청 전송
6. 응답 수신
7. 커넥션 종료

### TCP 특징/구조

<img width="593" alt="image" src="https://github.com/user-attachments/assets/39723c12-8996-480c-a40a-f0d910b2b92e" />

IP 패킷（혹은 IP 데이터그램）이라고 불리는 작은 조각을 통해 데이터를 전송.

<img width="603" alt="image" src="https://github.com/user-attachments/assets/32ccdd57-1603-43d6-b669-2149b0c09205" />

| 구성 요소         | 설명                                                  |
| ----------------- | ----------------------------------------------------- |
| IP 패킷 헤더      | 발신지/목적지 IP 주소, 크기, 기타 플래그 (20바이트)   |
| TCP 세그먼트 헤더 | 포트 번호, 제어 플래그, 순서/무결성 체크값 (20바이트) |
| 데이터 조각       | 실제 전송할 데이터 (0바이트 이상)                     |

### TCP 커넥션 유지/식별

TCP 커넥션은 4가지 값으로 유일하게 식별되고, 생성됨. `<발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트>`

<img width="638" alt="image" src="https://github.com/user-attachments/assets/9eda0b8e-43cd-448e-9caf-3e4b0636bab7" />

- 서로 다른 TCP 커넥션은 네 가지 값이 모두 같을 수 없음
- 일부 값은 여러 커넥션이 공유할 수 있음

### TCP 소켓 프로그래밍

TCP 프로그래밍 인터페이스가 존재함. => 소켓 API

> [!NOTE]
> 소켓 API는 HTTP 개발 시 TCP/IP의 세부사항을 숨기고 간단한 인터페이스를 제공하는 프로그래밍 인터페이스
> TCP 종단(Endpoint) 데이터 구조 생성, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결 후 데이터 스트림을 읽고 쓸 수 있음

#### 추가 사항

- 유닉스에서 시작돼 현재는 대부분의 운영체제와 프로그래밍 언어에서 사용 가능
- TCP API는 네트워크 프로토콜의 핸드셰이킹, TCP 스트림과 IP 패킷 간의 분할 및 재조립 등 복잡한 세부사항을 추상화함
- 실제 연결 시간은 서버와의 거리, 서버 부하, 네트워크 혼잡도 등 여러 요인에 따라 달라질 수 있음

#### 주요 소켓 API 함수

| 함수 호출                      | 설명                               |
| ------------------------------ | ---------------------------------- |
| `socket(<parameters>)`         | 새로운 소켓 생성                   |
| `bind(s, <local IP:port>)`     | 소켓에 로컬 포트와 인터페이스 할당 |
| `connect(s, <remote IP:port>)` | 원격 호스트와 TCP 커넥션 생성      |
| `listen(s,...)`                | 로컬 소켓의 커넥션 수신 허용       |
| `accept(s)`                    | 로컬 포트의 커넥션 대기            |
| `read(s,buffer,n)`             | 소켓에서 n바이트 읽기              |
| `write(s,buffer,n)`            | 소켓에 n바이트 쓰기                |
| `close(s)`                     | TCP 커넥션 종료                    |
| `shutdown(s, <side>)`          | TCP 커넥션의 입출력 닫기           |
| `getsockopt(s,...)`            | 소켓 설정 읽기                     |
| `setsockopt(s,...)`            | 소켓 설정 변경                     |

#### 클라이언트-서버 상호작용 순서

<img width="631" alt="image" src="https://github.com/user-attachments/assets/f0bd77ec-7d43-4bd7-84a7-40b665296b30" />

- **서버 측**
  1. 소켓 생성 (socket)
  2. 80번 포트에 바인딩 (bind)
  3. 연결 수신 허용 (listen)
  4. 연결 대기 (accept)
  5. 요청 읽기 (read)
  6. 요청 처리
  7. 응답 전송 (write)
  8. 연결 종료 (close)
- **클라이언트 측**
  1. IP 주소와 포트 획득
  2. 소켓 생성 (socket)
  3. 서버에 연결 (connect)
  4. HTTP 요청 전송 (write)
  5. 응답 대기 (read)
  6. 응답 처리
  7. 연결 종료 (close)

## TCP 성능 고려사항

<img width="593" alt="image" src="https://github.com/user-attachments/assets/39723c12-8996-480c-a40a-f0d910b2b92e" />

위 이미지처럼 계층적 구조로 쌓여 있어서 HTTP 트랜잭션의 성능은 하부 TCP 계층의 성능에 큰 영향을 받음.
TCP 성능을 이해하는 것은 더 나은 HTTP 앱을 설계하는 데 필수적.

### HTTP 트랜잭션 지연 요소

<img width="597" alt="image" src="https://github.com/user-attachments/assets/a32d582b-48bc-4fd7-b9b4-677312dcdc90" />

| 단계      | 지연 원인     | 설명                                                       |
| --------- | ------------- | ---------------------------------------------------------- |
| DNS 조회  | 호스트명 해석 | URI의 호스트명을 IP 주소로 변환하는 과정에서 발생하는 지연 |
| TCP 연결  | 커넥션 설정   | 새로운 TCP 커넥션 설정 시 발생하는 1~2초의 지연            |
| 요청 전송 | 네트워크 전송 | HTTP 요청이 TCP 파이프를 통해 전송되는 시간                |
| 서버 처리 | 요청 처리     | 서버가 요청을 처리하는 시간                                |
| 응답 전송 | 네트워크 전송 | 서버의 응답이 클라이언트에게 전달되는 시간                 |

### TCP 성능 영향 주요 요소

| 지연 요소                 | 주요 특징                                              | 해결/완화 방법       |
| ------------------------- | ------------------------------------------------------ | -------------------- |
| TCP 커넥션 핸드셰이크     | 새 커넥션 설정 시 3-way 핸드셰이크로 인한 지연         | 커넥션 재사용        |
| 확인응답 지연             | TCP가 패킷 전송 성공을 위해 0.1-0.2초의 패킷 확인 지연 | 편승(piggyback) 활용 |
| TCP 느린 시작(slow start) | 네트워크 혼잡 방지를 위한 점진적 패킷 전송량 증가      | 기존 커넥션 유지     |
| 네이글(Nagle) 알고리즘    | 작은 패킷들을 모아 한 번에 전송                        | TCP_NODELAY 설정     |
| TIME_WAIT 지연            | 커넥션 종료 후 일정 시간(2분) 대기                     | 가상 IP 활용         |

#### TCP 커넥션 핸드셰이크

<img width="592" alt="image" src="https://github.com/user-attachments/assets/85f3ec17-09da-4bc9-a657-341a6bca68be" />

- 새로운 TCP 커넥션 설정 시 3단계 핸드셰이크 필요
- SYN, SYN+ACK, ACK 패킷 교환으로 인한 지연 발생
- 작은 HTTP 트랜잭션의 경우 전체 시간의 50% 이상을 차지할 수 있음

#### 확인응답 지연

- TCP의 신뢰성을 위한 확인응답 메커니즘
- 데이터 패킷에 확인응답을 '편승'시켜 효율성 증가
- HTTP의 요청-응답 방식으로 인해 편승 기회가 제한됨
- 일반적으로 0.1~0.2초의 지연 발생

#### TCP 느린 시작(slow start)

- 네트워크 혼잡 방지를 위한 점진적 속도 증가 메커니즘
- 새로운 커넥션은 처음에 전송 속도가 제한됨
- 성공적인 전송에 따라 전송 가능한 패킷 수가 증가
- '튜닝된' 기존 커넥션이 새로운 커넥션보다 더 효율적

#### 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘의 목적과 동작
  - TCP는 작은 크기의 데이터도 전송 가능한 스트림 인터페이스 제공
  - 각 TCP 세그먼트에 40바이트의 헤더가 필요해 작은 패킷의 과다 전송은 비효율적
  - 네이글 알고리즘은 작은 패킷들을 모아서 한 번에 전송하여 효율성 증가
  - 최대 크기(LAN: 1,500바이트, 인터넷: 수백 바이트)까지 데이터를 모음
  - 모든 패킷의 확인응답을 받은 경우에만 작은 패킷 전송 허용
- HTTP에서의 문제점
  - 작은 HTTP 메시지가 추가 데이터를 기다리며 지연됨
  - 확인응답 지연과 결합 시 성능이 저하됨 (100~200ms 지연)
  - TCP_NODELAY 설정으로 비활성화 가능하나, 데이터를 큰 덩어리로 만들어야 함

#### TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT의 목적과 동작
  - TCP 커넥션 종료 시 IP 주소와 포트 번호 정보를 제어 블록에 저장
  - 2MSL(보통 2분) 동안 같은 주소/포트 조합의 새 커넥션 생성 방지
  - 이전 커넥션의 패킷이 새 커넥션에 잘못 삽입되는 문제 예방
- 성능 테스트 시 주의사항
  - 제한된 IP 주소와 포트 번호로 인한 커넥션 제한
  - 포트 재사용 불가로 인한 성능 측정 왜곡 가능성
  - 예 : 60,000개 포트, 120초 TIME_WAIT 시 초당 500개 커넥션으로 제한
  - 해결책 : 추가 장비 사용 또는 가상 IP 주소 활용

#### 추가사항

- 과도한 커넥션이나 제어 블록은 운영체제 성능 저하 유발 가능
