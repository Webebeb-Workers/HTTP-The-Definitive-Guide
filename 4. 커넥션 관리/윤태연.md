# TCP 커넥션

HTTP의 연결에 대한 과정, 유지 등을 여기서 알아본다.

## TCP 커넥션

HTTP 통신은 TCP/IP를 통해 이루어지며, 클라이언트와 서버 간의 안전한 데이터 전송을 보장함.

### 과정

<img width="597" alt="image" src="https://github.com/user-attachments/assets/b63c2769-188c-47cf-874d-3801c2fba92c" />

1. URL에서 호스트명 추출
2. 호스트명으로 IP 주소 찾기
3. 포트 번호 얻기
4. TCP 커넥션 생성
5. HTTP 요청 전송
6. 응답 수신
7. 커넥션 종료

### TCP 특징/구조

<img width="593" alt="image" src="https://github.com/user-attachments/assets/39723c12-8996-480c-a40a-f0d910b2b92e" />

IP 패킷（혹은 IP 데이터그램）이라고 불리는 작은 조각을 통해 데이터를 전송.

<img width="603" alt="image" src="https://github.com/user-attachments/assets/32ccdd57-1603-43d6-b669-2149b0c09205" />

| 구성 요소         | 설명                                                  |
| ----------------- | ----------------------------------------------------- |
| IP 패킷 헤더      | 발신지/목적지 IP 주소, 크기, 기타 플래그 (20바이트)   |
| TCP 세그먼트 헤더 | 포트 번호, 제어 플래그, 순서/무결성 체크값 (20바이트) |
| 데이터 조각       | 실제 전송할 데이터 (0바이트 이상)                     |

### TCP 커넥션 유지/식별

TCP 커넥션은 4가지 값으로 유일하게 식별되고, 생성됨. `<발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트>`

<img width="638" alt="image" src="https://github.com/user-attachments/assets/9eda0b8e-43cd-448e-9caf-3e4b0636bab7" />

- 서로 다른 TCP 커넥션은 네 가지 값이 모두 같을 수 없음
- 일부 값은 여러 커넥션이 공유할 수 있음

### TCP 소켓 프로그래밍

TCP 프로그래밍 인터페이스가 존재함. => 소켓 API

> [!NOTE]
> 소켓 API는 HTTP 개발 시 TCP/IP의 세부사항을 숨기고 간단한 인터페이스를 제공하는 프로그래밍 인터페이스
> TCP 종단(Endpoint) 데이터 구조 생성, 원격 서버의 TCP 종단에 그 종단 데이터 구조를 연결 후 데이터 스트림을 읽고 쓸 수 있음

#### 추가 사항

- 유닉스에서 시작돼 현재는 대부분의 운영체제와 프로그래밍 언어에서 사용 가능
- TCP API는 네트워크 프로토콜의 핸드셰이킹, TCP 스트림과 IP 패킷 간의 분할 및 재조립 등 복잡한 세부사항을 추상화함
- 실제 연결 시간은 서버와의 거리, 서버 부하, 네트워크 혼잡도 등 여러 요인에 따라 달라질 수 있음

#### 주요 소켓 API 함수

| 함수 호출                      | 설명                               |
| ------------------------------ | ---------------------------------- |
| `socket(<parameters>)`         | 새로운 소켓 생성                   |
| `bind(s, <local IP:port>)`     | 소켓에 로컬 포트와 인터페이스 할당 |
| `connect(s, <remote IP:port>)` | 원격 호스트와 TCP 커넥션 생성      |
| `listen(s,...)`                | 로컬 소켓의 커넥션 수신 허용       |
| `accept(s)`                    | 로컬 포트의 커넥션 대기            |
| `read(s,buffer,n)`             | 소켓에서 n바이트 읽기              |
| `write(s,buffer,n)`            | 소켓에 n바이트 쓰기                |
| `close(s)`                     | TCP 커넥션 종료                    |
| `shutdown(s, <side>)`          | TCP 커넥션의 입출력 닫기           |
| `getsockopt(s,...)`            | 소켓 설정 읽기                     |
| `setsockopt(s,...)`            | 소켓 설정 변경                     |

#### 클라이언트-서버 상호작용 순서

<img width="631" alt="image" src="https://github.com/user-attachments/assets/f0bd77ec-7d43-4bd7-84a7-40b665296b30" />

- **서버 측**
  1. 소켓 생성 (socket)
  2. 80번 포트에 바인딩 (bind)
  3. 연결 수신 허용 (listen)
  4. 연결 대기 (accept)
  5. 요청 읽기 (read)
  6. 요청 처리
  7. 응답 전송 (write)
  8. 연결 종료 (close)
- **클라이언트 측**
  1. IP 주소와 포트 획득
  2. 소켓 생성 (socket)
  3. 서버에 연결 (connect)
  4. HTTP 요청 전송 (write)
  5. 응답 대기 (read)
  6. 응답 처리
  7. 연결 종료 (close)

## TCP 성능 고려사항

<img width="593" alt="image" src="https://github.com/user-attachments/assets/39723c12-8996-480c-a40a-f0d910b2b92e" />

위 이미지처럼 계층적 구조로 쌓여 있어서 HTTP 트랜잭션의 성능은 하부 TCP 계층의 성능에 큰 영향을 받음.
TCP 성능을 이해하는 것은 더 나은 HTTP 앱을 설계하는 데 필수적.

### HTTP 트랜잭션 지연 요소

<img width="597" alt="image" src="https://github.com/user-attachments/assets/a32d582b-48bc-4fd7-b9b4-677312dcdc90" />

| 단계      | 지연 원인     | 설명                                                       |
| --------- | ------------- | ---------------------------------------------------------- |
| DNS 조회  | 호스트명 해석 | URI의 호스트명을 IP 주소로 변환하는 과정에서 발생하는 지연 |
| TCP 연결  | 커넥션 설정   | 새로운 TCP 커넥션 설정 시 발생하는 1~2초의 지연            |
| 요청 전송 | 네트워크 전송 | HTTP 요청이 TCP 파이프를 통해 전송되는 시간                |
| 서버 처리 | 요청 처리     | 서버가 요청을 처리하는 시간                                |
| 응답 전송 | 네트워크 전송 | 서버의 응답이 클라이언트에게 전달되는 시간                 |

### TCP 성능 영향 주요 요소

| 지연 요소                 | 주요 특징                                              | 해결/완화 방법       |
| ------------------------- | ------------------------------------------------------ | -------------------- |
| TCP 커넥션 핸드셰이크     | 새 커넥션 설정 시 3-way 핸드셰이크로 인한 지연         | 커넥션 재사용        |
| 확인응답 지연             | TCP가 패킷 전송 성공을 위해 0.1-0.2초의 패킷 확인 지연 | 편승(piggyback) 활용 |
| TCP 느린 시작(slow start) | 네트워크 혼잡 방지를 위한 점진적 패킷 전송량 증가      | 기존 커넥션 유지     |
| 네이글(Nagle) 알고리즘    | 작은 패킷들을 모아 한 번에 전송                        | TCP_NODELAY 설정     |
| TIME_WAIT 지연            | 커넥션 종료 후 일정 시간(2분) 대기                     | 가상 IP 활용         |

#### TCP 커넥션 핸드셰이크

<img width="592" alt="image" src="https://github.com/user-attachments/assets/85f3ec17-09da-4bc9-a657-341a6bca68be" />

- 새로운 TCP 커넥션 설정 시 3단계 핸드셰이크 필요
- SYN, SYN+ACK, ACK 패킷 교환으로 인한 지연 발생
- 작은 HTTP 트랜잭션의 경우 전체 시간의 50% 이상을 차지할 수 있음

#### 확인응답 지연

- TCP의 신뢰성을 위한 확인응답 메커니즘
- 데이터 패킷에 확인응답을 '편승'시켜 효율성 증가
- HTTP의 요청-응답 방식으로 인해 편승 기회가 제한됨
- 일반적으로 0.1~0.2초의 지연 발생

#### TCP 느린 시작(slow start)

- 네트워크 혼잡 방지를 위한 점진적 속도 증가 메커니즘
- 새로운 커넥션은 처음에 전송 속도가 제한됨
- 성공적인 전송에 따라 전송 가능한 패킷 수가 증가
- '튜닝된' 기존 커넥션이 새로운 커넥션보다 더 효율적

#### 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘의 목적과 동작
  - TCP는 작은 크기의 데이터도 전송 가능한 스트림 인터페이스 제공
  - 각 TCP 세그먼트에 40바이트의 헤더가 필요해 작은 패킷의 과다 전송은 비효율적
  - 네이글 알고리즘은 작은 패킷들을 모아서 한 번에 전송해 효율성 증가
  - 최대 크기(LAN: 1,500바이트, 인터넷: 수백 바이트)까지 데이터를 모음
  - 모든 패킷의 확인응답을 받은 경우에만 작은 패킷 전송 허용
- HTTP에서의 문제점
  - 작은 HTTP 메시지가 추가 데이터를 기다리며 지연됨
  - 확인응답 지연과 결합 시 성능이 저하됨 (100~200ms 지연)
  - TCP_NODELAY 설정으로 비활성화 가능하나, 데이터를 큰 덩어리로 만들어야 함

#### TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT의 목적과 동작
  - TCP 커넥션 종료 시 IP 주소와 포트 번호 정보를 제어 블록에 저장
  - 2MSL(보통 2분) 동안 같은 주소/포트 조합의 새 커넥션 생성 방지
  - 이전 커넥션의 패킷이 새 커넥션에 잘못 삽입되는 문제 예방
- 성능 테스트 시 주의사항
  - 제한된 IP 주소와 포트 번호로 인한 커넥션 제한
  - 포트 재사용 불가로 인한 성능 측정 왜곡 가능성
  - 예 : 60,000개 포트, 120초 TIME_WAIT 시 초당 500개 커넥션으로 제한
  - 해결책 : 추가 장비 사용 또는 가상 IP 주소 활용

#### 추가사항

- 과도한 커넥션이나 제어 블록은 운영체제 성능 저하 유발 가능

## HTTP 커넥션 관리

그 전은 성능이라면, 여기서는 성하고 최적화하는 HTTP 기술을 얘기함.

### 흔히 잘못 이해하는 Connection 헤더

HTTP 통신에서 Connection 헤더는 클라이언트와 서버 간의 특정 커넥션에만 적용되는 옵션을 설정하는 데 사용.

- **헤더 필드 명** : 현재 커넥션에만 해당되는 헤더들을 나열
- **임시적인 토큰 값** : 커넥션에 대한 비표준 옵션을 의미
- **`close` 값** : 작업 완료 후 커넥션을 종료해야 함을 지시

특히, `Connection: close`는 요청 처리가 완료되면 커넥션을 종료하도록 서버에 지시함. 이러한 설정은 메시지가 다음 홉으로 전달되기 전에 해당 헤더들을 제거함으로써 보안과 효율성 상승.

\+ **홉별 헤더** : `Proxy-Authenticate`, `Proxy-Connection`, `Transfer-Encoding`, `Upgrade` 등 특정 두 서버 간에만 영향을 미치는 헤더들.

### 순차적인 트랜잭션 처리의 한계

웹 페이지가 여러 개의 리소스(예: 이미지, 스타일 시트)를 포함할 경우, 이를 순차적으로 로드하면 TCP 커넥션 설정과 느린 시작(Slow Start)으로 인해 전체 로딩 시간이 크게 증가.

- **지연 누적**: 여러 개의 HTTP 트랜잭션을 각각 처리하면 커넥션 설정 지연과 데이터 전송 지연이 발생 - TCP 커넥션 설정과 느린 시작(Slow Start) 때문에
- **사용자 경험 저하**: 페이지 로딩이 느리게 느껴지고, 브라우저 화면이 텅 비어 있는 상태로 유지됨

이러한 순차 처리가 브라우저 및 사용자에게 좋은 경험을 주지 않아 **병렬**, **지속**, **파이프라인**, **다중** 커넥션으로 최적화한다.

## 병렬 커넥션

앞서 언급했듯이 순차 처리는 매우 느림! HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리함.

<img width="486" alt="image" src="https://github.com/user-attachments/assets/54bd45d5-88ca-4164-b912-16310b42e502" />

### 병렬 커넥션을 통한 성능 최적화

> [!NOTE]
> 여러 개의 TCP 커넥션을 동시에 열어 여러 HTTP 트랜잭션을 병렬로 처리함으로써 웹 페이지 로딩 시간을 단축시키는 기술

#### 장점

<img width="496" alt="image" src="https://github.com/user-attachments/assets/04d27ac1-3f1d-4a13-9e61-c83a843b4e93" />

- **로딩 속도 향상** : 여러 커넥션을 통해 동시에 데이터를 전송함으로써 전체 로딩 시간 감소
- **대역폭 활용 극대화** : 남은 네트워크 대역폭까지 효율적으로 사용해 데이터 전송 속도를 높임

#### 단점

- **서버 부하 증가** : 다수의 커넥션을 동시에 처리해야 하므로 서버의 리소스가 많이 소모됨
- **포트 고갈 문제** : 클라이언트 측에서 열 수 있는 커넥션 수에 한계가 있어, 과도한 커넥션 시 포트 고갈이 발생할 수 있음
- **대역폭 제한 시 효과 감소** : 네트워크 대역폭이 제한적일 경우, 여러 커넥션을 통해 전송되는 데이터가 오히려 느려질 수 있음

#### 사용자 경험

병렬 커넥션은 실제로 페이지 로딩 시간을 크게 단축시키지 않더라도, 여러 리소스가 동시에 로드되는 모습을 보여줌으로써 사용자가 더 빠르게 로딩되고 있다고 느끼게 함.

다시 말해, 브라우저가 여러 커넥션을 통해 동시에 데이터를 받아오므로 시각적으로 페이지가 빠르게 채워지는 느낌을 줘 좋은 경험을 얻을 수 있음.

#### 병렬 커넥션의 실효성과 제한

대부분의 최신 브라우저는 병렬 커넥션의 수를 제한/지원(보통 6~8개)해 서버의 과부하 방지.

또한, 네트워크 대역폭이 충분히 넓지 않은 환경에서는 병렬 커넥션의 장점 감소 농후. 따라서, 병렬 커넥션을 사용할 때는 서버와 클라이언트의 리소스, 네트워크 조건 등을 종합적으로 고려하고 사용해야함.

## 지속 가능한 HTTP 통신의 이해

### 사이트 지향성과 지속 커넥션의 필요성

동일 사이트 내 여러 리소스 요청 발생, 효율적 처리를 위한 지속 커넥션 필요성 대두로 **지속 커넥션(persistent connection)**이 도입.

예) 하나의 웹 페이지에 포함된 여러 이미지나 하이퍼링크는 대부분 같은 서버에서 호스팅. 이러한 **사이트 지향성(site locality)** 덕분에 클라이언트는 동일한 서버에 반복적으로 HTTP 요청을 보내게 됨. 그럴 때 지속 커넥션이 도움이 됨.

### 지속 커넥션과 병렬 커넥션의 비교

- **지속 커넥션** : TCP 커넥션 설정 지연 감소와 리소스 효율성 향상
  - 커넥션 설정과 종료에 따른 지연과 대역폭 소모 감소
  - 이미 튜닝된 커넥션을 재사용해 데이터 전송 속도 향상
  - 커넥션 수를 줄여 서버와 클라이언트의 리소스 효율성 증가
- **병렬 커넥션** : 동시 다운로드로 로딩 시간 단축
  - 여러 리소스를 동시에 다운로드해 전체 로딩 시간 단축
  - 네트워크 대역폭을 효율적으로 활용

각 방식의 공통점은, 리소스 소모와 서버 부하 고려 필요성 존재

- **단점**
  - 지속 커넥션 : 과도한 커넥션 유지 시 리소스 소모 증가
  - 병렬 커넥션 : 서버 부하 증가 및 포트 고갈 위험, 네트워크 대역폭 제한 시 효율 저하

### HTTP 버전별 지속 커넥션 구현

- **HTTP/1.0** : Keep-Alive 헤더를 통한 확장적 지원
- **HTTP/1.1** : 기본 활성화로 안정성과 효율성 향상
- HTTP/1.0 Keep-Alive 동작 방식
  1. 클라이언트가 `Connection: Keep-Alive` 헤더를 포함한 요청을 서버로 전송
  2. 서버가 이를 인식하고 응답에도 동일한 헤더를 포함해 커넥션 유지
  3. 이후의 요청들은 동일한 커넥션을 통해 처리돼 커넥션 설정 지연 감소

<img width="663" alt="image" src="https://github.com/user-attachments/assets/d74689dc-8ab4-4f84-836f-f2cf2cef7b8a" />

### 지속 커넥션의 옵션과 제한 사항

- timeout, max 파라미터를 통한 커넥션 제어
  - **timeout 파라미터 :** 커넥션을 얼마나 오랫동안 유지할지 설정
  - **max 파라미터 :** 커넥션을 통해 처리할 수 있는 최대 HTTP 트랜잭션 수 설정
- `Content-Length`, `chunked transfer encoding` 정확성 요구
- 프락시 서버의 헤더 처리 규칙 준수 필요성 존재
  - 프락시 서버와 게이트웨이는 `Connection` 헤더에 명시된 헤더들을 제거해야 함
  - 오래된 프락시나 "멍청한(dumb)" 프락시는 지속 커넥션을 제대로 처리하지 못해 통신 오류를 유발할 수 있음

### 지속 커넥션과 프락시 서버의 상호작용 문제

**멍청한 프락시(dumb proxy)**는 `Connection: Keep-Alive` 헤더를 제대로 처리하지 못해 지속 커넥션을 맺는 과정에서 문제 발생 농후

<img width="678" alt="image" src="https://github.com/user-attachments/assets/f5fd20ea-0c70-459b-9ef1-a22a587a0051" />

1. 클라이언트가 프락시에 `Connection: Keep-Alive` 헤더와 함께 요청 전송
2. 프락시가 이 헤더를 인식하지 못하고 그대로 서버로 전달
3. 서버는 프락시와의 커넥션을 지속하려 하지만, 프락시는 이를 제대로 관리하지 못해 추가 요청을 무시하거나 커넥션이 끊어지지 않음
4. 결과적으로 클라이언트는 응답을 받지 못하고 타임아웃이 발생할 수 있음

이를 해결하기 위해 **Proxy-Connection** 헤더가 도입, 모든 프락시가 이를 지원하지 않기 때문에 여전히 호환성 문제 존재. 즉, 현대 HTTP 앱은 지속 커넥션을 명확히 구현, 프락시와의 호환성 고려.

### HTTP/1.1의 지속 커넥션 개선

**HTTP/1.1**에서는 **지속 커넥션**이 기본으로 활성화, 별도 설정 없이도 커넥션이 유지. 클라이언트와 서버는 `Connection: close` 헤더를 통해 커넥션을 종료 가능, 지속 커넥션은 자동으로 관리됨.

- 모든 커넥션이 기본적으로 지속 커넥션으로 처리됨
- 추가 요청 시 새로운 커넥션을 설정할 필요 없이 기존 커넥션을 재사용
- `Connection: close` 헤더를 통해 명시적으로 커넥션 종료 가능

### 지속 커넥션의 제한과 규칙

- 클라이언트가 `Connection: close` 헤더를 포함하면 추가 요청을 보낼 수 없음
- 모든 메시지는 정확한 `Content-Length` 또는 `chunked transfer encoding`을 가져야 함
- 프락시 서버는 `Connection` 헤더와 관련된 모든 홉별 헤더를 제거해 전달해야 함
- 클라이언트와 서버는 언제든지 커넥션을 종료할 수 있으며, 이를 대비한 재시도 메커니즘이 필요함

## 효율적인 HTTP 통신을 위한 파이프라인과 커넥션 관리

### 파이프라인 커넥션의 도입과 장점

**HTTP/1.1**은 지속 커넥션을 활용해 **파이프라인 커넥션**을 구현 가능.

**파이프라이닝**은 여러 개의 HTTP 요청을 한 번에 전송하고, 각 요청에 대한 응답을 순차적으로 받는 방식으로, 특히 네트워크 지연이 큰 환경에서 유용.

<img width="676" alt="image" src="https://github.com/user-attachments/assets/e9ae90be-b384-41b5-b944-af6fad0dad9b" />

- **지연 시간 감소** : 여러 요청을 큐에 쌓아 두고 동시에 전송함으로써 왕복 시간(RTT) 감소
- **효율적인 대역폭 사용** : 대기 시간을 최소화해 네트워크 자원을 효율적으로 활용
- **빠른 응답 처리** : 첫 번째 요청이 처리되는 동안 두 번째와 세 번째 요청을 동시에 전송해 전체 처리 시간 단축

### 파이프라인 커넥션의 제약 사항

파이프라인 커넥션을 효과적으로 사용하기 위해서는 몇 가지 제약 사항을 고려해야 함.

- **순서 보장** : HTTP 응답은 요청이 보내진 순서대로 돌아와야 함, 응답이 순서 없이 도착하면 이를 재정렬할 방법이 없기 때문에 문제 발생 가능
- **유연한 재시도 메커니즘** : 커넥션이 예기치 않게 끊길 경우, 클라이언트는 아직 완료되지 않은 요청을 다시 전송할 준비가 돼 있어야 함
- **멱등성 요청의 한계** : POST와 같은 비멱등(non-idempotent) 요청은 파이프라이닝을 통해 전송하면 요청이 중복될 경우 문제 발생 가능

따라서 이러한 요청은 파이프라이닝을 피해야 함.

### 커넥션 끊기의 미스터리

HTTP 커넥션을 언제, 어떻게 끊을지는 명확한 기준이 없으며, 이는 다양한 상황에서 복잡한 문제 야기. 특히, 또! **프락시 서버**와의 상호작용에서 문제가 발생.

- **예상치 못한 커넥션 종료**
  - 어떤 클라이언트나 서버, 또는 프락시 서버는 언제든지 TCP 커넥션을 끊을 수 있음
  - 정상적인 요청 처리 중에도 발생 가능, 클라이언트는 이러한 상황에 대비해 요청을 재시도 할 수 있어야 함
- **`Content-Length`의 정확성**
  - 일부 오래된 서버는 이를 제대로 구현하지 않아 응답 본문의 길이가 불일치 가능
  - 그렇다면 클라이언트는 데이터의 정확한 길이를 알 수 없어 통신 오류가 발생

### 우아하게 커넥션 종료하기

1. **TCP 커넥션의 양방향성 이해**
   - 데이터 입출력을 위한 양방향 큐 구조
   - 한쪽 출력 큐의 데이터가 상대방 입력 큐로 전달되는 구조
2. **커넥션 종료 방식의 구분**
   - 전체 끊기 : `close()` 호출로 입출력 채널 모두 종료
   - 절반 끊기 : `shutdown()` 호출로 입력 또는 출력 채널 개별 종료
3. **안전한 커넥션 종료를 위한 고려사항**
   - 출력 채널 종료의 상대적 안전성
   - 입력 채널 종료 시 리셋 에러 발생 위험 존재
   - 파이프라인 커넥션에서 버퍼 데이터 손실 가능성
4. **우아한 커넥션 종료의 구현**
   - 자신의 출력 채널 우선 종료
   - 상대방의 출력 채널 종료 대기
   - 타임아웃 기반의 주기적 상태 검사해야 함
   - 필요시 강제 종료 메커니즘 구현해야 함
