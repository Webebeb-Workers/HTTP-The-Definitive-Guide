# 4. 커넥션 관리

## 4.1 TCP 커넥션

전 세계 모든 통신은 지그상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이뤄짐

세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있으며, 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달됨

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공

TCP 커넥션의 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달

<img width="579" alt="image" src="https://github.com/user-attachments/assets/ee5c6bc2-87aa-42cb-b780-ecb950d7d046" />

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

TCP는 IP 패킷이라고 불리는 작은 조각을 통해 데이터를 전송

- HTTP는 프로토콜 스택에서 최상위 계층이며, HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보냄

- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷에 담아서 인터넷을 통해 데이터를 전달

<img width="574" alt="image" src="https://github.com/user-attachments/assets/2d849b4d-5b99-4035-950e-6937046586dd" />

<img width="579" alt="image" src="https://github.com/user-attachments/assets/89ea6b27-2d9e-4a99-b016-a9a85bcf7df5" />

### 4.1.3 TCP 커넥션 유지하기

컴퓨터는 항상 TCP 커넥션을 여러개 가지고 있으며, TCP는 포트 번호를 통해서 여러 개의 커넥션을 유지

TCP 커넥션은 발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트 네 가지 값으로 식별 가능

### 4.1.4 TCP 소켓 프로그래밍

## 4.2 TCP 성능에 대한 고려

HTTP는 TCP 바로 위에 있는 계층이기 때문에 HTTP 트랜잭션의 성능은 TCP 성능에 영향을 받음

### 4.2.1 HTTP 트랜잭션 지연

**HTTP 트랜잭션을 지연시키는 원인들**

- 클라이언트가 URI에서 웹 서버의 IP 주소와 포트번호를 알아내는데, URI의 호스트에 방문한 적이 최근 없으면 DNS resolutio 인프라를 사용하여 URI에 있는 호스트 명을 IP로 변환하는데 지연
- 클라이언트가 TCP 커넥션 요청을 서버에게 보내고 서버가 커넥션 허가 응답을 회신하기를 기다리는 과정에서 지연
- 커낵션이 맺어진 후 클라이언트는 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전달하는데, 요청 메시지가 전달되고 서버에 의해서 처리되는데 지연
- 웹 서버가 HTTP 응답을 보내는데 지연

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글 알고리즘
- TCP의 편승 확인응답을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 커넥션 생성 요청인 SYN 플래그를 가진 작은 TCP 패킷을 서버에게 보낸다

- 서버가 커넥션을 받으면 몇 가지 커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 SYN과 ACK 플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다

- 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인응답 신호를 보낸다

### 4.2.4 확인응답 지연

- 인터넷 자체가 패킷 전송을 완벽히 보장하지는 않기 때문에, TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가짐

- 각 세그먼트의 수신자는 순번과 데이터 무결성 체크섬을 가지며, 각 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환

- 확인응답 지연은 송출할 확인응답을 특정 시간동안 버퍼에 저장해 두고, 확인응답을 편승시키기 위한 송출 데이터 패킷을 찾음 만약 일정 시간 안에 송출 데이터

- 패킷을 찾지 못하면 확인응답은 별도 패킷을 만들어 전송

- 하지만 요청과 응답 두 가지 형식으로만 이루어지는 HTTP 동작 방식은, 확인 응답이 송출 데이터 패킷에 편승할 기회를 감소시켜 지연이 자주 발생

### 4.2.5 TCP 느린 시작(slow start)

- TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라지는데, TCP 커넥션은 시간이 지나면서 자체적으로 '튜닝'되어서, 처음에는
- 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나감
- 인터넷의 갑작스러운 부하와 혼잡을 방지

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 애플리케이션이 어떤 크기의 데이터든지 TCP 스택으로 전송할 수 있도록, TCP는 데이터 스트림 인터페이스를 제공

- 하지만 각 TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에, TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크 성능이 떨어짐

- 네이글 알고리즘은 네트워크 효율을 위해서, 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한 개의 덩어리로 합치며, 세그먼트가 최대 크기가 되지 않으면 전송을 하지 않음

- 다른 모든 패킷이 확인응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락하며 다른 패킷들이 아직 전송 중이면 데이터는 버퍼에 저장됨

- 전송되고 나서 확인응답을 기다리던 패킷이 확인응답을 받았거나 전송하기 충분할 만큼의 패킷이 쌓였을 때 버퍼에 저장되어 있던 데이터가 전송

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TCP 연결이 종료된 후에도 세그먼트의 최대 생명주기의 두 배 정도(2MSL, 약 2분)의 시간 동안 유지되는 상태

- 특정 커넥션이 생성되고 닫힌 다음, 그와 같은 IP 주소와 포트 번호를 가지는 커넥션이 2분 이내에 또 생성되는 것을 막아줌

## 4.3 HTTP 커넥션 관리

커넥션을 생성하고 최적화하는 HTTP 기술 설명

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- 클라이언트 ➡️ 프락시 서버 ➡️ 캐시 서버 ➡️ ... ➡️ 서버 중
- 두 개의 인접한 HTTP 애플리케이션이 현재 맺고 있는 커넥션에만 적용될 옵션 지정해야할 때도 있음
- HTTP Connection 헤더 필드: 커넥션 토큰 쉼표로 구분, 다른 커넥션에 전달 X
  - e.g. 다음 메시지 보낸 다음 끊어져야 할 커넥션 `Connection: close`로 명시 가능

**Connection 헤더의 토큰 종류**

- HTTP 헤더 필드 명: 이 커넥션에만 해당되는 헤더들 나열 (e.g. `Connection: Upgrade`)
- 임시적인 토큰 값: 커넥션에 대한 비표준 옵션 의미 (e.g. `Connection: private`)
- close 값: 커넥션 작업이 완료되면 종료되어야 함 의미 (e.g. `Connection: close`)

**HTTP 헤더 필드 명**

- 해당 필드는 현재 커넥션만을 위한 정보임, 따라서 다음 커넥션에 전달하면 안됨
- Connection 헤더에 있는 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제되어야 함

**홉별(hop-by-hop)**

- 두 서버 간에만 영향을 미치고 다른 서버 간에는 영향을 미치지 않는다는 의미하는
- 홉별 헤더 명을 기술하여, Connection 헤더에 명시된 헤더들이 전달되는 것을 방지함

1. HTTP 애플리케이션이 Connection 헤더와 함께 메시지 전달 받음
2. 수신자는 송신자에게 온 요청에 기술된 모든 옵션 적용
3. 디음 홉 전달 전에 Connection 헤더 + 헤더에 기술된 모든 헤더 삭제
4. 헤더에 기술되지 않은 헤더 `홉별 헤더`도 삭제 (e.g. Proxy-Authenticate, Proxy-Connection, Transfer-Encoding, Upgrade)

<img width="577" alt="image" src="https://github.com/user-attachments/assets/64c16772-6e16-44a8-b1b9-529c2c5484ec" />

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

**EX) 3개의 이미지가 있는 웹페이지**

- HTML + 이미지 3개를 위한 4개의 HTTP 트랜잭션 만들어야함
- 각 트랜잭션이 새로운 커넥션 필요로 하면 커넥션 지연 발생
- 순차적으로 로드 시: 이미지 혹은 객체 크기 모르는 경우 레이아웃 지연 발생 ➡️ 텅 빈 화면 보게됨

<img width="577" alt="image" src="https://github.com/user-attachments/assets/7c7cf3b0-4678-4fb2-9f61-b8e3099db287" />

이를 위해 HTTP 커넥션 성능 향상시키는 기술 4가지

**병렬(parallel) 커넥션**
여러 개의 TCP 커넥션을 통한 동시 HTTP 요청

**지속(persistent) 커넥션**
커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용

**파이프라인(pipelined) 커넥션**
공유 TCP 커넥션을 통한 병렬 HTTP 요청

**다중(multiplexed) 커넥션**
요청과 응답들에 대한 중재 (실험적인 기술)

> Q. 현재는 다중 커넥션 지원하는지?

## 4.4 병렬 커넥션

아래 그림처럼 클라이언트가 여러 HTTP 커넥션을 맺어 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있음

<img width="578" alt="image" src="https://github.com/user-attachments/assets/ad4557dc-f63e-472f-8cb8-e5cf6495732b" />

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

- 각 커넥션의 지연 시간을 겹치게 해서 지연 시간 줄일 수 있음
- 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리지 않는다면 나머지 객체 내려받는데 남은 대역폭 사용 가능

<img width="578" alt="image" src="https://github.com/user-attachments/assets/42ddee11-bb0e-4eb4-ae7d-fdfdbd9bca35" />

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

- 클라이언트의 네트워크 대역폭이 좁은 경우 ➡️ 객체를 병렬로 내려받아도 제한된 대역폭 때문에 성능상 이점 거의 없음
- 다수의 커넥션 ➡️ 메모리 소모 & 성능 문제 발생 가능
- 실제 브라우저: 병렬 커넥션을 사용하지만 대부분 4개 사용함

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수'있다.

- 병렬 커넥션이 항상 빠른건 아님
- 총 다운로드 시간이 더 걸려도 사용자는 화면 작업을 바로 확인할 수 있다면 그걸 빠른걸로 느낌

## 4.5 지속 커넥션

- 사이트 지역성: 웹 클라이언트는 같은 웹사이트에 여러 개의 커넥션을 맺는 특성이 있음 (이미지, 하이퍼링크 등을 위해)
- **지속 커넥션(HTTP/1.1의 특징)**
  - 처리 완료 후에도 TCP 커넥션을 유지
  - 향후 HTTP 요청을 위해 재사용 가능
  - 클라이언트나 서버가 명시적으로 끊기 전까지 유지
  - 새로운 커넥션 설정에 드는 시간 절약 & TCP 느린 시작을 피해 더 빠른 데이터 전송 가능

### 4.5.1 지속 커넥션 vs 병렬 커넥션

- **병렬 커넥션**의 단점

  - 각 트랜잭션마다 새로운 커넥션 맺고 끊음 ➡️ 시간 + 대역폭 소요
  - 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어짐
  - 실제로 연결할 수 있는 병렬 커넥션 수 제한있음

- **지속 커넥션**의 장점

  - 커넥션을 위한 사전 작업 + 지연 줄여줌, 튜닝된 (다수의 패킷 전송 권한 가지는 커넥션) 커넥션 유지, 커넥션 수 줄여줌
  - 대신 관리 못하면 계속 연결된 상태의 커넥션 쌓여서 리소스 소모 多

- 효과적인 방법 = 지속 + 병렬 커넥션?
  - 적은 수의 병렬 커넥션 + 지속하는 방식
  - 지속 커넥션 타입: HTTP/1.0+에는 `keep-alive` 또는 HTTP/1.1에는 `지속` 커넥션

### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- 아래 그림처럼 4개의 커넥션을 맺고 끊는데 필요한 작업이 없어져 시간이 단축됨

<img width="594" alt="image" src="https://github.com/user-attachments/assets/b0964fe5-a2b2-4822-828f-18bc8467d1c0" />

### 4.5.3 Keep-Alive 동작

- HTTP/1.1 명세에서는 keep-alive 사용하지 않지만 이전 버전 호환을 위해 동작 방식을 이해해보겠심

1. 클라이언트 ➡️ 서버: 요청에 Connection: Keep-Alive 헤더 포함
2. 서버 ➡️ 클라이언트: 이 커넥션으로 요청 계속 받을거면 같은 헤더 포함 / 지원하지 않을거면 해당 헤더 포함하지 않고 서버 커넥션 끊음

<img width="596" alt="image" src="https://github.com/user-attachments/assets/5463bcae-372e-419d-8e81-ed4d4189a3e3" />

### 4.5.4 Keep-Alive 옵션

- keep-alive 커넥션은 언제든 끊을 수 있고, 트랜잭션 수를 제한할 수 있음
- keep-alive 동작은 keep-alive 헤더의 쉼표로 구분된 옵션들로 제어할 수 있음
  - timeout: 커넥션 유지 시간
  - max: 처리할 HTTP 트랜잭션 수
  - 디버깅용 임의 속성 지원 가능

```
e.g.)
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- HTTP/1.0에서는 기본으로 사용되지 않음
- 사용하려면 Connection: Keep-Alive 헤더를 명시적으로 포함해야 함
- 모든 메시지에 이 헤더를 포함해야 연결 유지

- 엔터티 본문의 길이를 알 수 있어야 함 + 정확한 Content-Length 값 필요
- 멀티파트 미디어 형식 또는 청크 전송 인코딩 사용

- 프락시의 경우 메시지 전달/캐싱 전에 Connection 헤더 관련 필드 제거
- 클라이언트는 연결 종료 시 재요청 가능하도록 준비

### 4.5.6 Keep-Alive와 명청한(dumb) 프락시

- 문제 원인

  - 클라이언트가 프락시에 Connection: Keep-Alive 요청
  - 구형 프락시는 이 헤더를 이해하지 못하고 서버에 그대로 전달

- 발생하는 문제
  - 서버는 프락시와 연결 유지 중이라 생각
  - 프락시는 Keep-Alive를 이해 못함
  - 클라이언트는 연결이 유지된 줄 알고 계속 요청
  - 프락시는 추가 요청을 무시 (구형 프락시는 요청 1개 - 응답1개 - 연결 종료 패턴을 따르기 때문)
  - 결국 타임아웃까지 대기하게 됨

<img width="598" alt="image" src="https://github.com/user-attachments/assets/96391bbb-b02d-4183-85e1-568b2714114a" />

- 프락시는 Connection 헤더와 관련 헤더들을 절대 전달하면 안 됨
- 홉별(hop-by-hop) 헤더들도 전달/캐시하면 안 됨

> Q. 그러면 중간에 프락시 있는 경우 keep-alive 연결 못하나?

### 4.5.7 Proxy-Connection 살펴보기

- 위 문제점에 대한 차선책 (넷스케이프)
- 구형 프락시: 서버가 모르는 헤더라 무시하므로 문제 없음

```
브라우저 -> 프락시 -> 서버
(Proxy-Connection) -> (그대로 전달) -> (무시)
```

- 신형 프락시: Connection 헤더로 변환해서 Keep-Alive 사용 가능

```
브라우저 -> 프락시 -> 서버
(Proxy-Connection) -> (Connection으로 변환) -> (처리)
```

<img width="595" alt="image" src="https://github.com/user-attachments/assets/cd098feb-d679-41ed-a168-b57aa753b956" />

- 하지만 구형 옆에 신형 프락시가 있는 경우 문제 다시 발생함

<img width="598" alt="image" src="https://github.com/user-attachments/assets/b154e7c4-12c2-4660-911d-bf588c654f5f" />

- 추가로 보이지 않는 중간 서버들(방화벽, 캐시 서버, 리버스 프락시 등) 존재
- 브라우저가 이들을 감지할 수 없어 Proxy-Connection 헤더를 보낼 수 없음
- 결론) Proxy-Connection은 완벽한 해결책이 아니며, 보이지 않는 웹 애플리케이션들이 지속 커넥션을 명확히 구현해야함

### 4.5.8 HTTP/1.1의 지속 커넥션

- **HTTP/1.1의 지속 커넥션**: 목적은 Keep-Alive와 같지만 개선된 커넥션 지원
  - 기본으로 활성화되어 있음, 별도 설정 외에는 모든 커넥션을 지속 커넥션으로 취급함
  - 의도적으로 커넥션 끊으려면 Connection: close 헤더 명시, 없어도 서버 상황에 따라 끊길 수는 있음

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트 측면

  - Connection: close 보냈으면 추가 요청 불가
  - 더 이상 요청이 없다면 마지막에 Connection: close 전송
  - 서버당 최대 2개의 지속 커넥션 권장

- 메시지 요구사항

  - 정확한 길이 정보 필수 (Content-Length 또는 청크 전송)

- 프락시 규칙

  - 클라이언트/서버와 별도의 커넥션 관리
  - 클라이언트의 기능 지원 범위를 모르면 지속 커넥션 금지
  - 서버당 약 2N개 커넥션 유지 (N=사용자 수)

- 연결 종료/복구
  - 언제든 연결 종료 가능
  - 중단된 연결 복구 가능해야 함
  - 안전한 요청은 재전송 가능해야 함

## 4.6 파이프라인 커넥션

- 지속 커넥션을 통해 여러 요청을 연속해서 보냄 + 첫 응답 기다리지 않고 여러 요청을 연속 전송 가능

  - 네트워크 대기 시간 감소, TCP 연결 지연 제거

- 파이프라인 제약 사항
  - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인 이으면 안됨
  - HTTP 응답은 요청 순서와 같게 와야함 (HTTP 메시지에는 순번이 없어서 순서에 맞게 정렬시킬 방법 없음)
  - HTTP 클라이언트는 완료되지 않은 요청이 파이프라인에 있다면 언제든 다시 요청 보낼 준비 해야함
  - POST 요청과 같이 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내면 안됨 (비멱등 요청)

<img width="595" alt="image" src="https://github.com/user-attachments/assets/f91f313e-ceaa-42be-a6eb-0b83cc46ed4f" />

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리(언제 어떻게 커넥션을 끊는가)에 대한 명확한 기준은 없음

## 4.7.1 '마음대로' 커넥션 끊기

- HTTP 클라이언트, 서버, 프락시는 언제든지 TCP 전송 커넥션 끊을 수 있음
- 에러 발생 경우 메시지를 다 보낸 다음 커넥션이 끊어지는게 아닌 그 전에 끊어질 수 있음
- 파이프라인 경우에도 일정 시간 동안 요청을 전송하지 않을 시 연결이 끊길 수 있고, 그 시점에 클라이언트가 요청 메시지 전송 시 문제 발생

## 4.7.2 Content-Length와 Truncation

- 클라이언트 / 프락시가 커넥션 끊어졌다는 HTTP 받은 후 전달 된 엔티티 길이 !== Content-Length인 경우 서버에 데이터의 정확한 길이 다시 물어봐야함
- 수신자가 캐시인 경우 캐싱 하지 않아야 하고 프락시도 Content-Length를 정정하려 하면 안되고 메시지 그대로 전달해야함

## 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과 반환하는 경우 = 그 트랜잭션은 **멱등**하다고 함
  - GET, HEAD, PUT, DELETE, TRACE, OPTIONS 메서드들은 멱등함
  - POST와 같은 멱등하지 않은 요청은 파이프라인을 통해 요청하면 안됨
  - 비멱등인 요청을 다시 보내는 경우 이전 요청에 대한 응답을 받을 때까지 기다려야함
  - 자동으로 재시도 하면 안되고 브라우저가 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여주는 등 해야함

## 4.7.4 우아한 커넥션 끊기

- TCP 커넥션은 양방향임
- TCP 커넥션 양쪽에는 데이터를 읽거나 쓰기 위한 입력 큐 / 출력 큐가 있음

<img width="469" alt="image" src="https://github.com/user-attachments/assets/efda0d2d-fecc-4dea-8f08-ea1060198417" />

- 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 / 둘 다 끊을 수 있음
  - close() 호출 시 두 커넥션 모두 끊음 = "전체 끊기"
  - shutdown() 호출 시 개별적으로 끊음 = "절반 끊기"

<img width="470" alt="image" src="https://github.com/user-attachments/assets/06398069-7a49-44b4-ab5a-a89593bad5fe" />

- 단순한 HTTP 애플리케이션 = "전체 끊기"만 가능
- 애플리케이션이 각기 다른 HTTP 클라이언트, 서버, 프락시와 통신 시, 파이프라인 지속 커넥션 사용 시, 예상치 못한 쓰기 에러 발생 시 = "절반 끊기" 사용해야함

- 보통은 커넥션의 출력 채널 끊는게 안전함
  - 커넥션 반대편에 있는 기기는 모든 데이터 버퍼로부터 읽고 데이터 전송 후 커넥션 끊겼다는 것을 알게됨
- 클라이언트에서 더는 데이터를 보내지 않을 것임을 확신할 수 없는 이상 커넥션 입력 채널 끊는 것은 위험함
  - 클라이언트에서 이미 끊긴 입력 채널에 데이터 전송 > TCP connection reset by peer 메시지 서버로부터 전송 됨 > 버퍼에 저장된 데이터 모두 삭제됨

```
상황: 10개 요청 전송 -> 응답들이 버퍼에 있음 -> 11번째 요청 시도 -> 서버가 연결 종료
결과:
- 'connection reset by peer' 에러 발생
- 버퍼의 이전 10개 응답 데이터 모두 삭제
```

**일반적으로 우아한 커넥션 끊기**

- 자신의 출력 채널 먼저 끊고, 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것
  - 절반 끊기 여부를 확인해준다는 보장 없음
  - 출력 채널에 절반 끊기 실행
  - 입력 채널의 상태를 주기적으로 검사
  - 일정 시간(타임아웃) 내에 입력 채널이 끊어지지 않으면
  - 리소스 보호를 위해 강제 종료 가능
