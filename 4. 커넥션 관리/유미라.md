# 1. TCP 커넥션

- HTTP 통신은 TCP/IP 프로토콜을 기반으로 클라이언트와 서버 간에 메시지를 주고받는 과정이다.

![image](https://github.com/user-attachments/assets/22ac707c-86e8-4093-a450-f28819208e6d)

## 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 TCP 커넥션을 기반으로 하며, 데이터를 순서대로 정확하고 신뢰성 있게 전달한다.

## TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 데이터를 세그먼트 단위로 나누어 IP 패킷에 담아 전송한다.

![image](https://github.com/user-attachments/assets/eac4b808-0f72-45e4-8fb5-4cae2f6bf547)

## TCP 커넥션 유지하기

TCP 커넥션은 다음 네 가지 정보를 조합해 고유하게 식별된다.
- `발신지 IP 주소`
- `발신지 포트 번호`
- `수신지 IP 주소`
- `수신지 포트 번호`

여러 TCP 커넥션이 있을 때, 일부 구성 요소는 같을 수 있지만, 네 가지 값이 모두 같은 커넥션은 존재하지 않는다.

## TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

### 소켓 API
- 프로그래머가 TCP/IP의 복잡한 세부사항을 몰라도 네트워크 통신을 구현할 수 있도록 도와주는 프로그래밍 인터페이스.

![image](https://github.com/user-attachments/assets/effcf348-cfb3-436c-a8c3-d7e5398a4741)

### 클라이언트와 서버 간에 HTTP 트랜잭션을 수행하기 위한 소켓 API의 사용 방법

![image](https://github.com/user-attachments/assets/fe0ad085-e08a-4227-8bc7-a1153e6fbd22)

# 2. TCP의 성능에 대한 고려

## HTTP 트랜잭션 지연

### HTTP 트랜잭션을 지연시키는 원인

#### HTTP 통신 과정과 지연 요소

![image](https://github.com/user-attachments/assets/a36cd3cd-29b4-48e7-990a-c1c468ce014f)

- 하드웨어 성능, 네트워크 속도, 응답 메시지 크기, 클라이언트와 서버 간 거리, 그리고 TCP 프로토콜의 복잡성이 통신 속도에 영향을 미친다.

## 성능 관련 중요 요소
- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

## TCP 커넥션 핸드셰이크 지연
### TCP 커넥션 핸드셰이크 과정

![image](https://github.com/user-attachments/assets/5d7d669f-bb8a-4b80-af46-9e137b9ee1fa)

1. 클라이언트: TCP 커넥션을 만들기 위해 작은 TCP 패킷(SYN)을 서버로 전송
2. 서버: 요청을 받으면 SYN과 ACK를 포함한 응답을 클라이언트에게 전송
3. 클라이언트: 커넥션이 잘 설정되었음을 확인하는 응답 패킷을 서버에 전송

> 핸드셰이크 과정은 클라이언트가 HTTP 요청을 보내기 전에 TCP 커넥션을 설정하는 데 시간이 소요되기 때문에, 작은 HTTP 트랜잭션에서는 이 과정이 전체 시간의 50% 이상을 차지할 수 있다.

### 확인응답 지연
#### 확인응답(ACK)
- 각 TCP 세그먼트는 전송된 데이터가 정확하게 전달되었는지 확인하기 위해 순번과 데이터 무결성 체크섬을 포함하고 있다. 
- 수신자는 데이터를 제대로 받으면 작은 확인응답 패킷을 송신자에게 보낸다.
- 만약 송신자가 일정 시간 내에 확인응답을 받지 못하면 데이터 전송에 오류가 발생한 것으로 판단하고, 데이터를 다시 전송한다.

#### 동작 방식
- TCP는 네트워크의 효율성을 높이기 위해 '편승(piggyback)'이라는 방식을 사용한다. 즉, 송신자가 데이터를 보낼 때 확인응답도 함께 보내도록 하여 네트워크 트래픽을 줄이는 방법이다.
- 보통 0.1~0.2초 정도 버퍼에 확인응답을 저장하고, 해당 확인응답을 편승할 데이터 패킷을 찾아서 같이 보내려고 시도한다.
- 만약 일정 시간 내에 확인응답을 편승시킬 수 있는 송출 데이터 패킷을 찾지 못하면, 확인응답은 별도의 패킷으로 전송된다.

#### HTTP에서의 한계
- 그러나 HTTP는 요청과 응답 패턴이 간단하여 확인응답이 편승할 기회가 적고, 이에 따라 지연이 발생할 수 있다.

### TCP 느린 시작(slow start)

- TCP의 데이터 전송 속도는 느린 시작(Slow Start) 과정에 따라 점진적으로 증가한다. 
- 처음에는 전송할 수 있는 패킷 수가 제한되며, 확인응답을 받을 때마다 더 많은 패킷을 보낼 수 있게 된다. 
- 이 방식은 네트워크 혼잡을 방지하지만, 새로운 커넥션에서는 속도가 더 느리므로, HTTP는 지속 커넥션을 사용하여 이미 튜닝된 커넥션을 재사용한다.

### 네이글(Nagle) 알고리즘과 TCP_NODELAY

#### 네이글 알고리즘
- 작은 데이터를 여러 번 보낼 때마다, 각각의 패킷은 헤더를 포함해 크기가 커지기 때문에 네트워크 성능이 저하될 수 있다.
- 이를 해결하기 위해, 네이글 알고리즘은 작은 데이터를 한 번에 모아서 전송한다. 즉, 데이터가 전송되기 전에 일정 크기 이상 모이거나 이전 패킷의 확인응답을 받을 때까지 기다린다.

#### 네이글 알고리즘의 문제점
1. 네이글 알고리즘은 작은 HTTP 메시지가 패킷을 채우지 못할 때, 추가 데이터를 기다리며 지연을 발생시킨다.
2. 네이글 알고리즘은 확인응답 지연과 함께 사용될 경우, 확인응답을 기다리는 동안 데이터를 전송을 멈추기 때문에 성능에 문제가 생긴다.

#### TCP_NODELAY
- 성능 개선을 위해 HTTP 애플리케이션에서는 네이글 알고리즘을 비활성화하는 TCP_NODELAY 옵션을 사용할 수 있다. 

### TIME_WAIT의 누적과 포트 고갈
#### TIME_WAIT 
- 각 TCP 연결이 종료되면, 해당 연결의 포트 정보가 일정 시간 동안(일반적으로 2MSL, 약 2분) 기록되어 새로운 연결이 해당 포트를 재사용할 수 없게 된다. 
- 이는 이전 커넥션의 패킷이 새로운 연결에 섞여 들어가는 문제를 방지하는 역할을 한다.
#### 포트 고갈
- 성능 측정에서는 한정된 수의 IP 주소와 포트만 사용할 수 있기 때문에 TIME_WAIT 상태에서 포트를 재활용하지 못하면, 서버의 성능이 저하될 수 있다. 
#### 해결 방법
- 더 많은 부하 발생 장비를 사용하거나, 가상 IP 주소를 활용하여 더 많은 연결을 만들 수 있다.

> 결론적으로, TIME_WAIT 상태는 성능 시험에서 문제를 일으킬 수 있지만, 실제 서비스 환경에서는 큰 문제가 되지 않는 경우가 많다.
