# 1. TCP 커넥션

- HTTP 통신은 TCP/IP 프로토콜을 기반으로 클라이언트와 서버 간에 메시지를 주고받는 과정이다.

![image](https://github.com/user-attachments/assets/22ac707c-86e8-4093-a450-f28819208e6d)

## 신뢰할 수 있는 데이터 전송 통로인 TCP

- HTTP 커넥션은 TCP 커넥션을 기반으로 하며, 데이터를 순서대로 정확하고 신뢰성 있게 전달한다.

## TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다

- TCP는 데이터를 세그먼트 단위로 나누어 IP 패킷에 담아 전송한다.

![image](https://github.com/user-attachments/assets/eac4b808-0f72-45e4-8fb5-4cae2f6bf547)

## TCP 커넥션 유지하기

TCP 커넥션은 다음 네 가지 정보를 조합해 고유하게 식별된다.
- `발신지 IP 주소`
- `발신지 포트 번호`
- `수신지 IP 주소`
- `수신지 포트 번호`

여러 TCP 커넥션이 있을 때, 일부 구성 요소는 같을 수 있지만, 네 가지 값이 모두 같은 커넥션은 존재하지 않는다.

## TCP 소켓 프로그래밍

- 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공한다.

### 소켓 API
- 프로그래머가 TCP/IP의 복잡한 세부사항을 몰라도 네트워크 통신을 구현할 수 있도록 도와주는 프로그래밍 인터페이스.

![image](https://github.com/user-attachments/assets/effcf348-cfb3-436c-a8c3-d7e5398a4741)

### 클라이언트와 서버 간에 HTTP 트랜잭션을 수행하기 위한 소켓 API의 사용 방법

![image](https://github.com/user-attachments/assets/fe0ad085-e08a-4227-8bc7-a1153e6fbd22)

# 2. TCP의 성능에 대한 고려

## HTTP 트랜잭션 지연

### HTTP 트랜잭션을 지연시키는 원인

#### HTTP 통신 과정과 지연 요소

![image](https://github.com/user-attachments/assets/a36cd3cd-29b4-48e7-990a-c1c468ce014f)

- 하드웨어 성능, 네트워크 속도, 응답 메시지 크기, 클라이언트와 서버 간 거리, 그리고 TCP 프로토콜의 복잡성이 통신 속도에 영향을 미친다.

## 성능 관련 중요 요소
- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback) 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

## TCP 커넥션 핸드셰이크 지연
### TCP 커넥션 핸드셰이크 과정

![image](https://github.com/user-attachments/assets/5d7d669f-bb8a-4b80-af46-9e137b9ee1fa)

1. 클라이언트: TCP 커넥션을 만들기 위해 작은 TCP 패킷(SYN)을 서버로 전송
2. 서버: 요청을 받으면 SYN과 ACK를 포함한 응답을 클라이언트에게 전송
3. 클라이언트: 커넥션이 잘 설정되었음을 확인하는 응답 패킷을 서버에 전송

> 핸드셰이크 과정은 클라이언트가 HTTP 요청을 보내기 전에 TCP 커넥션을 설정하는 데 시간이 소요되기 때문에, 작은 HTTP 트랜잭션에서는 이 과정이 전체 시간의 50% 이상을 차지할 수 있다.

### 확인응답 지연
#### 확인응답(ACK)
- 각 TCP 세그먼트는 전송된 데이터가 정확하게 전달되었는지 확인하기 위해 순번과 데이터 무결성 체크섬을 포함하고 있다. 
- 수신자는 데이터를 제대로 받으면 작은 확인응답 패킷을 송신자에게 보낸다.
- 만약 송신자가 일정 시간 내에 확인응답을 받지 못하면 데이터 전송에 오류가 발생한 것으로 판단하고, 데이터를 다시 전송한다.

#### 동작 방식
- TCP는 네트워크의 효율성을 높이기 위해 '편승(piggyback)'이라는 방식을 사용한다. 즉, 송신자가 데이터를 보낼 때 확인응답도 함께 보내도록 하여 네트워크 트래픽을 줄이는 방법이다.
- 보통 0.1~0.2초 정도 버퍼에 확인응답을 저장하고, 해당 확인응답을 편승할 데이터 패킷을 찾아서 같이 보내려고 시도한다.
- 만약 일정 시간 내에 확인응답을 편승시킬 수 있는 송출 데이터 패킷을 찾지 못하면, 확인응답은 별도의 패킷으로 전송된다.

#### HTTP에서의 한계
- 그러나 HTTP는 요청과 응답 패턴이 간단하여 확인응답이 편승할 기회가 적고, 이에 따라 지연이 발생할 수 있다.

### TCP 느린 시작(slow start)

- TCP의 데이터 전송 속도는 느린 시작(Slow Start) 과정에 따라 점진적으로 증가한다. 
- 처음에는 전송할 수 있는 패킷 수가 제한되며, 확인응답을 받을 때마다 더 많은 패킷을 보낼 수 있게 된다. 
- 이 방식은 네트워크 혼잡을 방지하지만, 새로운 커넥션에서는 속도가 더 느리므로, HTTP는 지속 커넥션을 사용하여 이미 튜닝된 커넥션을 재사용한다.

### 네이글(Nagle) 알고리즘과 TCP_NODELAY

#### 네이글 알고리즘
- 작은 데이터를 여러 번 보낼 때마다, 각각의 패킷은 헤더를 포함해 크기가 커지기 때문에 네트워크 성능이 저하될 수 있다.
- 이를 해결하기 위해, 네이글 알고리즘은 작은 데이터를 한 번에 모아서 전송한다. 즉, 데이터가 전송되기 전에 일정 크기 이상 모이거나 이전 패킷의 확인응답을 받을 때까지 기다린다.

#### 네이글 알고리즘의 문제점
1. 네이글 알고리즘은 작은 HTTP 메시지가 패킷을 채우지 못할 때, 추가 데이터를 기다리며 지연을 발생시킨다.
2. 네이글 알고리즘은 확인응답 지연과 함께 사용될 경우, 확인응답을 기다리는 동안 데이터를 전송을 멈추기 때문에 성능에 문제가 생긴다.

#### TCP_NODELAY
- 성능 개선을 위해 HTTP 애플리케이션에서는 네이글 알고리즘을 비활성화하는 TCP_NODELAY 옵션을 사용할 수 있다. 

### TIME_WAIT의 누적과 포트 고갈
#### TIME_WAIT 
- 각 TCP 연결이 종료되면, 해당 연결의 포트 정보가 일정 시간 동안(일반적으로 2MSL, 약 2분) 기록되어 새로운 연결이 해당 포트를 재사용할 수 없게 된다. 
- 이는 이전 커넥션의 패킷이 새로운 연결에 섞여 들어가는 문제를 방지하는 역할을 한다.
#### 포트 고갈
- 성능 측정에서는 한정된 수의 IP 주소와 포트만 사용할 수 있기 때문에 TIME_WAIT 상태에서 포트를 재활용하지 못하면, 서버의 성능이 저하될 수 있다. 
#### 해결 방법
- 더 많은 부하 발생 장비를 사용하거나, 가상 IP 주소를 활용하여 더 많은 연결을 만들 수 있다.

> 결론적으로, TIME_WAIT 상태는 성능 시험에서 문제를 일으킬 수 있지만, 실제 서비스 환경에서는 큰 문제가 되지 않는 경우가 많다.

# 3. 커넥션 관리
## 흔히 잘못 이해하는 Connection 헤더
<img width="575" alt="image" src="https://github.com/user-attachments/assets/7705248a-50d5-4f13-bd77-982a5c52e5bb" />

- Connection 헤더는 특정 HTTP 연결(커넥션)에서만 유효한 옵션이나 헤더 필드를 지정하는 데 사용된다.
- 현재 커넥션에만 적용되며, 메시지가 다른 곳으로 전달될 때(프록시나 서버로 넘어갈 때) 이 Connection 헤더와 관련된 모든 헤더 필드는 삭제되어야 한다.

### Connection 헤더의 주요 토큰
- 헤더 필드 명: 현재 커넥션에만 적용되는 HTTP 헤더 필드
- 임시 토큰 값: 비표준 커넥션 옵션
- close 값: 작업 완료 후 커넥션을 종료해야 함을 명시

### 홉별 (hop-by-hop) 헤더
- Proxy-Authenticate
- Proxy-Connection
- Transfer-Encoding
- Upgrade

## 순차적인 트랜잭션 처리에 의한 지연
<img width="575" alt="image" src="https://github.com/user-attachments/assets/056ef726-1339-4fa7-a740-bed236e42ffe" />

- 웹페이지에 3개의 이미지가 있을 때, 이 페이지를 브라우저가 로드하려면 4개의 HTTP 트랜잭션이 필요하다.
- 만약 이 트랜잭션들이 순차적으로 처리되면, 각 요청이 끝날 때까지 기다려야 하므로 페이지 로딩 시간이 길어진다.
- 그로 인해 사용자는 빈 화면을 보거나, 페이지가 늦게 로드되면서 불편함을 느낄 수 있다.

## 병렬 커넥션
<img width="566" alt="image" src="https://github.com/user-attachments/assets/f449dec6-614d-440d-9903-05d75ff73c36" />

- 웹 페이지에서 여러 객체를 순차적으로 다운로드하는 방식은 느리지만, HTTP는 여러 커넥션을 병렬로 처리하여 여러 트랜잭션을 동시에 다운로드할 수 있게 한다.

### 병렬 커넥션은 페이지룔 더 빠르게 내려받는다
<img width="574" alt="image" src="https://github.com/user-attachments/assets/b009de1a-28ac-48f0-9608-7ff3bd7eabc4" />

- 단일 커넥션에서 대역폭 제한과 대기 시간을 줄이면 웹페이지 로딩 속도를 개선할 수 있다.
- 병렬 커넥션 방식은 여러 커넥션이 동시에 데이터를 다운로드하면서 각 커넥션의 지연 시간을 겹쳐 총 지연 시간을 줄인다.
- 클라이언트의 인터넷 대역폭을 하나의 커넥션이 독점하지 않으면, 남은 대역폭을 다른 객체 다운로드에 효율적으로 활용할 수 있다. 

### 병렬 커넥션이 항상 더 빠르지는 않다
- 병렬 커넥션은 네트워크 대역폭이 넓을 때 빠른 성능을 보이지만, 대역폭이 제한적일 경우 성능이 향상되지 않는다.
- 여러 커넥션이 메모리와 성능 문제를 일으킬 수 있다.
- 수백 개의 커넥션을 사용하는 것이 서버에 큰 부담을 줄 수 있으며, 서버는 과도한 커넥션을 끊을 수 있다. 이로 인해, 브라우저는 보통 4개의 커넥션만 허용한다.

### 병렬 커넥션은 더 빠르게 ‘느껴질 수’ 있다
- 병렬 커넥션은 실제로 페이지 로딩 속도를 빠르게 만들지 않지만, 여러 객체가 동시에 로드되는 모습을 보며 사용자는 더 빠르게 로딩되는 것처럼 느낄 수 있다.

# 5. 지속 커넥션
- **site locality** : 웹 클라이언트가 같은 서버에 여러 번 요청을 보내는 특성
- **지속 커넥션** : 한 번 TCP 커넥션을 맺고 나서 여러 HTTP 요청을 해당 커넥션에서 처리한다.
- 커넥션을 재사용하기 때문에, 새로운 커넥션을 맺을 때 발생하는 지연과 시간 소모를 줄일 수 있다.

## 지속 커넥션 vs 병렬 커넥션
### 병렬 커넥션의 단점
- 각 트랜잭션마다 새로운 커넥션을 맺고 끊기 때문에 시간과 대역폭이 소요된다.
- 각각의 새로운 커넥션은 TCP 느린 시작 때문에 성능이 떨어진다.
- 실제로 연결할 수 있는 병 렬 커넥션의 수에는 제한이 있다.

### 지속 커넥션의 장점
- 커넥션을 재사용하여 사전 연결 작업과 지연을 줄인다.
- 커넥션 수를 줄여 서버 자원과 네트워크 자원의 효율성을 높인다.

### 지속 커넥션의 단점
- 잘못 관리되면 많은 수의 열린 커넥션이 쌓여 로컬 및 원격 리소스에 불필요한 부담을 줄 수 있다.

> 지속 커넥션은 병렬 커넥션과 함께 사용될 때에 가장 효과적이다.

## HTTP/1.0+의 Keep-Alive 커넥션
![image](https://github.com/user-attachments/assets/f5e1c77b-6e8c-48c5-a299-e3223f31b2d6)

- HTTP/1.0에서 keep-alive라는 지속 커넥션 기능이 실험적으로 도입되었고, 이는 상호 운용성 문제를 겪었지만 여전히 많은 클라이언트와 서버에서 사용되고 있다.
- 이러한 설계상의 문제는 HTTP/1.1에서 수정되었다.
- keep-alive 커넥션은 여러 HTTP 트랜잭션을 처리할 때, 각각의 새로운 커넥션을 맺고 끊는 과정 없이 하나의 지속 커넥션을 사용하여 시간과 성능상의 이점을 가져온다.

## Keep-Alive 동작
![image](https://github.com/user-attachments/assets/827c867b-b211-4dce-9645-eaeab307f04b)

- keep-alive는 HTTP/1.1 명세에서 제외되었지만, 여전히 많은 브라우저와 서버에서 핸드셰이크 방식으로 사용되고 있다.
- HTTP/1.0에서 keep-alive 커넥션을 구현하려면 클라이언트는 요청에 Connection: Keep-Alive 헤더를 포함시켜야 한다.
- 서버는 이 요청을 받으면 응답 메시지에 Connection: Keep-Alive 헤더를 포함하여 커넥션을 유지하고자 한다. 만약 헤더가 없으면, 서버는 커넥션을 끊을 것이라 추정된다.

## Keep-Alive 옵션
- Keep-Alive 헤더는 클라이언트와 서버가 커넥션을 유지하기를 바라는 요청일 뿐, 반드시 따라야 하는 규칙은 아니다.
- 커넥션을 끊거나, 처리할 트랜잭션의 수를 제한하는 등 Keep-Alive 커넥션을 제어할 수 있다.
- timeout과 max 파라미터를 사용하여 커넥션이 유지될 시간을 제어할 수 있지만, 보장된 동작은 아니다.
- Keep-Alive 헤더는 선택적이고, Connection: Keep-Alive 헤더가 있을 때만 사용될 수 있다.

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

## Keep-Alive 커넥션 제한과 규칙
### HTTP/1.0에서의 Keep-Alive 사용
- 기본적으로 활성화되지 않으며, 클라이언트가 Connection: Keep-Alive 요청 헤더를 명시적으로 포함해야 커넥션을 유지한다.
- 서버가 응답에 Connection: Keep-Alive 헤더를 포함하지 않으면 요청 처리 후 커넥션을 끊는다.

### 커넥션 유지 조건
- Content-Length 헤더가 정확히 설정되거나, 멀티파트 미디어 형식 또는 청크 전송 인코딩 방식으로 본문이 전송되어야 한다.
- 잘못된 Content-Length는 트랜잭션의 경계(끝과 시작)를 혼동시켜 문제가 발생할 수 있다.

### 프락시 및 게이트웨이 관련 규칙
- 프락시는 Connection 헤더와 관련 필드를 제거해야 한다.
- Connection 헤더를 인식하지 못하는 오래된 프락시와의 문제를 방지해야 한다.

### 오래된 HTTP/1.0 기기와 호환성
- 오래된 프락시 서버로 인해 Connection: Keep-Alive 필드가 무시될 수 있다.
- 일부 클라이언트와 서버는 이러한 문제를 무시하기도 한다.

### 커넥션 실패 처리
- 커넥션이 응답 완료 전에 끊어진 경우, 클라이언트는 요청을 다시 보낼 수 있도록 설계되어야 한다.
- 요청 재전송이 제대로 처리되지 않으면 반복 요청으로 인해 문제가 발생할 수 있다.

## Keep-Alive와 멍청한(dumb) 프락시
![image](https://github.com/user-attachments/assets/51ed3421-5399-404d-ad33-c94ed30b71f3)

### 진행 단계
#### 1. 클라이언트 → 프락시:
- 클라이언트는 Connection: Keep-Alive 헤더를 포함한 요청을 프락시로 보낸다.
- 이 요청은 "현재 커넥션을 끊지 말고 유지하자"는 요청이다.

#### 2. 프락시 → 서버:
- 멍청한 프락시는 이 헤더가 홉 단위로 적용된다는 것을 모른다.
- 따라서 클라이언트로부터 받은 Connection: Keep-Alive 헤더를 그대로 서버에 전달한다.

#### 3. 서버 → 프락시:
- 서버는 프락시의 요청에 포함된 Connection: Keep-Alive 헤더를 보고, 프락시가 커넥션을 유지하자고 요청했다고 판단한다.
- 이에 따라 서버는 프락시와 커넥션을 유지하기로 동의하고, 응답 메시지에 Connection: Keep-Alive를 포함해 보낸다.

#### 4. 프락시 → 클라이언트:
- 프락시는 서버로부터 받은 응답을 클라이언트에게 그대로 전달한다.
- 응답에 포함된 Connection: Keep-Alive 헤더를 보고, 클라이언트는 프락시가 커넥션을 유지하기로 동의했다고 오해한다.

#### 5. 실제 상태:
- 클라이언트와 서버는 각각 자신들이 프락시와 커넥션을 유지하고 있다고 생각한다.
- 하지만 실제로 프락시는 Connection: Keep-Alive를 전혀 이해하지 못하며, 필요할 때 커넥션을 끊어버린다.

### 발생할 수 있는 문제
- 프락시는 서버가 응답을 보낸 후 커넥션을 끊을 것으로 기대한다.
- 하지만 서버는 프락시와 커넥션을 유지하겠다고 판단했기 때문에 종료하지 않는다.
- 이 상태에서 클라이언트가 추가 요청을 보내도, 프락시는 이 요청을 "현재 응답 처리 중인 커넥션에서 새롭게 발생한 요청"으로 간주하지 않고 예상치 못한 입력으로 취급해 무시한다.

#### 클라이언트, 프락시, 서버 간의 상태
- 클라이언트는 요청에 대한 응답을 받지 못해 무한 로딩 상태로 남게 된다.
- 프락시는 커넥션이 끊길 때까지 아무런 작업을 하지 않고 대기 상태에 있다.
- 서버는 커넥션을 유지하면서 추가 요청이나 응답 처리를 기다린다.

### 해결책
- 프락시는 Connection 헤더와 같은 홉 단위 헤더를 제대로 처리해야 한다.
- 요청을 다음 홉으로 전달하기 전에 Connection 헤더를 제거하거나, 해당 헤더에 명시된 헤더 필드들을 삭제해야 한다.

## Proxy-Connection 살펴보기
- 넷스케이프 개발자들은 멍청한 프락시 문제를 완전히 해결하지는 못하지만, 이를 우회할 기발한 차선책을 제안했다.
- `Connection` 헤더 대신, `Proxy-Connection`이라는 비표준 헤더를 도입했다.
 
### 작동 방식
- 브라우저는 프락시로 Proxy-Connection 헤더를 보낸다.
- 이 헤더는 프락시와의 커넥션을 유지하자는 요청을 나타낸다.
- 영리한 프락시는 이 헤더를 이해하고, 서버로 요청을 보낼 때 `Connection: Keep-Alive` 헤더로 변환하여 전달한다.
- 서버와 프락시 사이의 커넥션은 유지된다.
- 프락시는 클라이언트와의 커넥션을 유지하려고 노력한다.

![image](https://github.com/user-attachments/assets/db4d47c6-810e-4ae6-8609-680234144c70)

- 프락시는 Proxy-Connection을 전달할 수 있지만, 서버는 이를 무시한다.
- 따라서 서버가 커넥션을 유지하려고 오해하지 않는다.

### Proxy-Connection의 한계
![image](https://github.com/user-attachments/assets/a8db10d7-422d-440f-b126-4e7bbc3b9ab2)

- Proxy-Connection은 한 개의 프락시만 있는 경우에는 동작하지만,여러 프락시가 연결된 경우(예: 멍청한 프락시 + 영리한 프락시) 다시 문제가 발생한다.
- 방화벽, 캐시 서버, 리버스 프락시 가속기 등 보이지 않는 프락시는 브라우저가 인식할 수 없다. 따라서 브라우저는 해당 기기에 Proxy-Connection 헤더를 보내지 못한다.

## HTTP/1.1 의 지속 커넥션
- HTTP/1.1에서는 지속 커넥션이 기본값으로 활성화되어 Connection: Keep-Alive 헤더가 필요 없다.
- 커넥션을 종료하려면 명시적으로 Connection: close 헤더를 사용해야 한다.
- 지속 커넥션은 기본값이지만, 클라이언트와 서버는 언제든지 연결을 끊을 수 있다.

## 지속 커넥션의 제한과 규칙
- Connection: close 헤더를 보낸 경우, 그 커넥션은 더 이상 재사용할 수 없으며, 해당 커넥션으로는 더 이상 요청을 보내지 못한다.
- 지속 커넥션을 사용하려면 정확한 메시지 길이 정보가 필요하며, 특히 청크 전송 인코딩이나 Content-Length 헤더가 있어야 한다.
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다.
- 클라이언트의 커넥션 기능 지원 범위를 모를 때는 프락시가 지속 커넥션을 맺지 않도록 해야 한다. (구식 프락시에서 발생할 수 있는 Connection 헤더 전달 문제 때문)
- 서버가 메시지를 전송 중에 커넥션을 끊지 않지만, Connection: close 헤더 없이도 언제든지 커넥션을 끊을 수 있다.
- HTTP/1.1 애플리케이션은 중간에 끊어진 커넥션을 복구할 수 있어야 하며, 클라이언트는 문제가 없는 경우 요청을 반복해서 보낼 준비가 되어 있어야 한다.
- 클라이언트는 서버 과부하를 방지하기 위해서 두 개의 커넥션까지만 유지하는 것이 이상적이다.

# 6. 파이프라인 커넥션
- HTTP/1.1에서는 지속 커넥션을 이용하여 여러 요청을 한 번에 보내는 요청 파이프라이닝을 할 수 있다.
- 여러 요청을 큐에 쌓은 후 응답이 오기 전에 여러 개의 요청을 보내는 방식으로 성능을 높일 수 있다.

## 파이프라이닝의 제약
- HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인한 후에 파이프라인을 시작해야 한다.
- HTTP 응답은 요청한 순서대로 와야 한다. 만약 응답 순서가 어긋나면 클라이언트는 이를 재정렬할 방법이 없다.
- 클라이언트는 커넥션이 언제 끊어지더라도, 파이프라인에 있는 완료되지 않은 요청을 다시 보내야 할 준비를 해야 한다.
- POST 같은 비멱등(non-idempotent) 요청은 파이프라인을 통해 보내면 안 된다. 이를 재전송할 경우 문제가 발생할 수 있기 때문이다.

# 7. 커넥션 끊기에 대한 미스터리
## ‘마음대로’커넥션 끊기
- HTTP 클라이언트, 서버, 또는 프락시는 언제든지 TCP 커넥션을 끊을 수 있다.
- 일반적으로 메시지를 다 전송한 후 커넥션을 끊지만, 에러 상황에서는 중간에 끊길 수도 있다.
- 지속 커넥션의 경우, 서버는 일정 시간 동안 유휴 상태인 커넥션을 끊을 수 있지만, 클라이언트가 요청을 보내는 중에 연결이 끊기면 문제가 발생할 수 있다.

## Content-Length와 Truncation
- HTTP 응답은 Content-Length 헤더를 통해 데이터의 크기를 정확히 알려줘야 한다.
- 클라이언트나 프락시가 응답을 받은 후, Content-Length와 실제 데이터 길이가 일치하지 않거나 Content-Length가 없으면 서버에 확인해야 한다.
- 이런 경우, 클라이언트나 프락시는 데이터를 받은 후 그 길이가 Content-Length와 일치하는지 확인하고, 맞지 않으면 서버에 다시 확인해야 한다.
- 또한, 캐시 프락시는 이런 응답을 캐시하지 않아야 하며, 프락시는 Content-Length 값을 수정하지 않고 그대로 전달해야 한다.

## 커넥션 끊기의 허용, 재시도, 멱등성
- HTTP 연결은 에러 없이도 언제든지 끊어질 수 있으며, 클라이언트는 이를 대비해 트랜잭션 재시도를 준비해야 한다.
- 커넥션이 끊기면 클라이언트는 서버에서 요청이 얼마나 처리되었는지 알 수 없다.
- GET, PUT, DELETE 등은 멱등성 있는 요청으로, 여러 번 요청해도 결과가 동일하다. 반면 POST는 멱등성이 없으므로 반복 요청은 중복 처리가 될 수 있어 피해야 한다.

## 우아한 커넥션 끊기
![image](https://github.com/user-attachments/assets/839bce22-7b75-4649-9581-c9711926eae0)

- TCP 연결은 양방향이다.
- 커넥션의 양쪽에는 입력 큐와 출력 큐가 존재한다.
- 한쪽 출력 큐의 데이터는 상대방의 입력 큐로 전달된다.

### 전체 끊기와 절반 끊기
![image](https://github.com/user-attachments/assets/a713e07d-2dbe-4369-a654-6b8dda8f29ee)

- **전체 끊기** : `close()`를 호출하면, 입력 채널과 출력 채널 모두 끊어진다.
- **절반 끊기** : `shutdown()`을 호출하면, 입력 채널이나 출력 채널 중 하나만 개별적으로 끊을 수 있다.

### TCP 끊기와 리셋 에러
![image](https://github.com/user-attachments/assets/5d96e607-a487-4fcd-bf04-36363e718c05)

- 단순한 HTTP 애플리케이션에서는 전체 끊기만을 사용하지만, 복잡한 애플리케이션에서는 절반 끊기를 사용해야 한다.

#### 출력 채널 끊기
- 출력 채널이란, 요청이나 응답 데이터를 보내는 쪽(클라이언트나 서버)의 채널이다.
- 애플리케이션은 출력 채널을 먼저 끊는 것이 안전하다. 이렇게 하면 상대방이 더 이상 데이터를 보내지 않음을 알게 된다.
- 예를 들어, 클라이언트가 자신의 출력 채널을 끊으면 서버는 클라이언트가 더 이상 데이터를 보내지 않겠다는 것을 인식하게 된다.

#### 입력 채널 끊기
- 입력 채널은 요청이나 응답 데이터를 받는 쪽(클라이언트나 서버)의 채널이다.
- 만약 클라이언트가 입력 채널을 먼저 끊으면 서버는 "connection reset by peer" 에러를 발생시킨다.
- 이 경우, 클라이언트는 이미 끊어진 입력 채널에 데이터를 전송하려 할 수 있는데, 이때 서버는 에러 메시지를 보내고, 서버의 입력 버퍼에 있는 데이터를 삭제한다.

### 우아하게 커넥션 끊기 
- HTTP 명세는 커넥션을 우아하게 끊는 방법을 명시하지 않지만, 일반적으로 애플리케이션은 자신의 출력 채널을 먼저 끊고, 상대방의 출력 채널이 끊어질 때까지 기다린다.
- 양쪽이 더 이상 데이터를 전송하지 않음을 알려주면 (출력 채널을 끊음), 커넥션은 리셋 없이 정상 종료된다.
- 그러나 상대방이 절반 끊기를 구현하지 않았을 수도 있기 때문에, 애플리케이션은 출력 채널을 끊고 난 후 입력 채널을 주기적으로 상태 검사해야 한다.
- 입력 채널이 일정 시간 내에 끊어지지 않으면, 애플리케이션은 리소스를 보호하기 위해 커넥션을 강제로 끊을 수 있다.
