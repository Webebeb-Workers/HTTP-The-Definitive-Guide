# 클라이언트 식별과 쿠키

HTTP는 기본적으로 "상태가 없는(stateless)" 프로토콜로, 각 요청과 응답이 독립적으로 처리됨.

하지만 현대 웹사이트에서는 개인화된 서비스 제공과 사용자 추적을 위해 클라이언트를 식별하는 다양한 기술이 필요함.

## 개별 접촉의 필요성

> [!NOTE]
> 웹 서버가 익명의 요청을 처리하는 것뿐만 아니라 서버와 통신하는 클라이언트를 추적하기 위해 사용하는 다양한 기술들의 집합

현대 웹사이트들의 개인화된 서비스 제공 필요성은 아래와 같음.

- **개별 인사** : 사용자에게 특화된 환영 메시지나 페이지 제공
- **사용자 맞춤 추천** : 고객의 흥미에 맞는 제품 추천
- **저장된 사용자 정보** : 배송 주소, 신용카드 정보 등을 저장해 편의성 제공
- **세션 추적** : 상태를 유지하며 사용자와 상호작용(장바구니 등)

## HTTP 헤더를 통한 식별 정보

> [!NOTE]
> 사용자에 대한 정보를 전달하는 HTTP 헤더들로, 브라우저가 서버에 요청을 보낼 때 자동으로 포함되는 정보들

### 주요 식별 관련 헤더

- `From` : 사용자의 이메일 주소 포함(스팸 우려로 대부분 사용 안 함)
- `User-Agent` : 사용자의 브라우저와 운영체제 정보
- `Referer` : 사용자가 현재 링크를 타고 온 이전 페이지의 URL
- `Authorization` : 사용자 이름과 비밀번호
- `Client-IP`/`X-Forwarded-For` : 클라이언트의 IP 주소
- `Cookie` : 서버가 생성한 ID 라벨

<img width="673" alt="image" src="https://github.com/user-attachments/assets/ed3f5131-1866-4e02-8029-bc8b5677e53a" />

## 클라이언트 IP 주소 기반 식별

초기에는 클라이언트의 IP 주소를 이용해 사용자를 식별하려 했으나 여러 한계점이 존재함.

### 한계점

- IP 주소는 사용자가 아닌 **컴퓨터를 식별**함(다수 사용자가 한 기기 사용 시 구분 불가)
- 많은 ISP는 **동적 IP 할당** 방식 사용(접속할 때마다 IP 변경)
- NAT나 방화벽 사용 시 **실제 IP 주소가 숨겨짐**
- 프락시 서버 사용 시 **서버는 프락시의 IP만 확인 가능**

일부 프락시는 `Client-IP`나 `X-Forwarded-For` 같은 확장 헤더로 원본 IP 보존을 시도하나 모든 프락시가 이를 지원하지 않음.

## 사용자 로그인 기반 식별

> [!NOTE]
> 사용자 이름과 비밀번호로 인증(로그인)하여 명시적으로 사용자를 식별하는 방식

HTTP는 `WWW-Authenticate`와 `Authorization` 헤더를 통해 로그인 기능 제공.

### 로그인 과정

<img width="680" alt="image" src="https://github.com/user-attachments/assets/8ed91968-4904-4061-b32f-33234c38a3ee" />

1. 사용자가 보호된 리소스 요청 시 서버는 401 응답과 함께 `WWW-Authenticate` 헤더 전송
2. 브라우저가 로그인 대화상자 표시
3. 사용자가 정보 입력 후, 브라우저는 `Authorization` 헤더에 자격증명 추가해 재요청
4. 이후 동일 사이트 요청 시 브라우저가 자동으로 인증 정보 전송

### 문제점

- 사이트마다 별도 로그인 필요
- 다양한 사용자명/비밀번호 조합 기억 필요
- 각 사이트마다 다른 규칙과 제약 존재

## 뚱뚱한 URL(Fat URL)

> [!NOTE]
> URL에 사용자 식별 정보나 세션 정보를 포함시키는 기술로, 주로 경로 처음이나 끝에 상태 정보를 추가하는 방식

### 특징

- URL에 사용자 상태 정보나 식별자 포함(예: `/exec/obidos/tg/browse/-/229220/002-1145265-8016838`)
- 서버가 페이지의 모든 링크를 동적으로 생성하여 식별 정보 유지

### 단점

- **심미적 문제** : 한마디로 못생겼음, 복잡하고 혼란스러운 URL 생성
- **공유 문제** : URL 공유 시 개인 정보 노출 위험
- **캐싱 불가** : 동일 페이지도 URL 변경으로 캐싱 어려움
- **서버 부하** : 모든 페이지와 링크 동적 생성 필요
- **이탈 위험** : 사용자가 다른 사이트로 이동하거나 일반 URL 사용 시 세션 정보 손실
- **세션 지속성 부재** : 로그아웃 시 모든 정보 손실

그래서 이러한 문제들을 해결하는 더 효율적인 식별 기술인 '쿠키'가 나옴.

## 쿠키

> [!NOTE]
> 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식 <br />
> 넷스케이프가 최초 개발했으나 현재는 모든 브라우저에서 지원함

참고 : 쿠키는 캐시와 충돌할 수 있어서, 부분의 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않음

### 쿠키의 타입

세션 쿠키와 지속 쿠키 두 가지 타입으로 구분됨.

- **세션 쿠키** : 사용자가 사이트 탐색 시 관련 설정과 선호 사항을 저장하는 임시 쿠키로, 브라우저 종료 시 삭제됨
- **지속 쿠키** : 디스크에 저장되어 브라우저 종료나 컴퓨터 재시작 후에도 유지되는 쿠키로, 주기적 방문 사이트의 설정이나 로그인 정보 유지에 사용됨

쿠키는 `Discard` 파라미터가 설정되어 있거나 `Expires`/`Max-Age` 파라미터가 없으면 세션 쿠키가 됨.

### 쿠키 동작 원리

서버가 사용자에게 붙이는 스티커/라벨과 같은 역할을 수행함.

1. 최초 방문 시 웹 서버는 사용자에 대해 아무것도 모름
2. 서버는 사용자 식별을 위한 유일값을 쿠키에 할당
3. 브라우저는 쿠키를 데이터베이스에 저장
4. 이후 방문 시 브라우저는 서버가 할당한 쿠키를 `Cookie` 요청 헤더에 포함해 전송

쿠키는 단순 ID 번호뿐 아니라 다양한 정보(이름, 전화번호 등)를 포함할 수 있음.

### 쿠키 상자: 클라이언트 측 상태

쿠키의 기본 발상은 브라우저가 서버 관련 정보를 저장하고, 해당 서버 접근 시 그 정보를 함께 전송하는 것임. 공식적으로는 'HTTP 상태 관리 체계'라 불림.

#### 브라우저별 쿠키 저장 방식

- **구글 크롬** : **SQLite 파일**에 쿠키 저장

  - `creation_utc` : 쿠키 생성 시점
  - `host_key` : 쿠키 도메인
  - `name`/`value` : 쿠키 이름과 값
  - `path` : 쿠키 관련 도메인 경로
  - `expire_utc` : 쿠키 파기 시점
  - `secure` : SSL 커넥션 시에만 전송 여부

- **인터넷 익스플로러** : 각각의 개별 파일로 쿠키 저장
  - 첫째 줄 : 쿠키 이름
  - 둘째 줄 : 쿠키 값
  - 셋째 줄 : 도메인과 경로

### 사이트별 쿠키 관리

브라우저는 수백/수천 개의 쿠키를 가질 수 있으나, 모든 사이트에 모든 쿠키를 전송하지는 않음. 일반적으로 각 사이트에 2-3개 쿠키만 전송하는 이유는 다음과 같음.

- 모든 쿠키 전달 시 성능 저하 발생
- 대부분 쿠키는 특정 서버에 특화된 값 포함
- 모든 쿠키를 모든 사이트에 전달 시 개인정보 문제 발생 가능성 존재

#### 쿠키 도메인 제어

- **Domain 속성** : 서버가 쿠키 생성 시 `Set-Cookie` 응답 헤더에 기술하여 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어 가능
- **Path 속성** : URL 경로 앞부분을 지정하여 웹사이트 일부에만 쿠키 적용 가능

따라서 쿠키는 일종의 상태 정보라고 할 수 있으며, 서버가 생성해 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리.

### 쿠키 구성요소

현재 Version 0(넷스케이프 쿠키)와 Version 1(RFC 2965) 쿠키 명세가 존재함. Version 1은 Version 0의 확장이나 널리 사용되지는 않음.

#### Version 0(넷스케이프) 쿠키 형식/명세

```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name1=value1 [; name2=value2] ...
```

### `Set-Cookie` 헤더 속성

`Set-Cookie` 헤더는 쿠키의 이름과 값을 필수로 가지며, 쿠키 옵션 속성들은 세미콜론으로 이어서 기술함.

#### 이름=값

- 필수 속성으로, 세미콜론, 쉼표, 등호, 공백을 포함하지 않는 문자열임
- 이름과 값 모두 큰따옴표로 감싸지 않음
- 웹 서버는 사용자 재방문 시 읽어올 어떤 이름=값 조합이든 생성 가능함
- 예: `Set-Cookie: customer=Mary`

#### Expires

- 선택적 속성으로, 쿠키의 생명주기를 나타내는 날짜 문자열 기술함
- 파기 일자에 도달하면 쿠키는 삭제되고 전달되지 않음
- 날짜 형식: 요일, DD-MM-YY HH:MM:SS GMT
- GMT만 타임존으로 사용 가능하며, 날짜 요소 간 구분자는 대시(-)여야 함
- Expires 미지정 시 사용자 세션 종료 시 파기됨
- 예: `Set-Cookie: foo=bar; expires=Wednesday, 09-Nov-99 23:12:40 GMT`

#### Domain

- 선택적 속성으로, 브라우저는 이 속성에 기술된 도메인 사용 서버로만 쿠키 전송함
- 서버가 특정 도메인에만 쿠키를 제한적으로 전달하게 함
- 'acme.com' 도메인은 'anvil.acme.com'과 'shipping.crate.acme.com'에는 적용되나 'www.cnn.com'에는 적용되지 않음
- 명시된 도메인에 해당하는 도메인만 쿠키 설정 가능함
- 최상위 도메인(.com, .edu 등) 제한을 방지하기 위해 2-3개 영역 도메인 기술 필요함
- 특정 최상위 도메인(.com, .edu, .net, .org, .gov, .mil, .int, .biz, .info, .name, .museum, .coop, .aero, .pro)은 두 영역만 기술해도 됨
- 도메인 미지정 시 Set-Cookie 응답 생성 서버 호스트명이 기본값임
- 예: `Set-Cookie: SHIPPING=FEDEX; domain="joes-hardware.com"`

#### Path

- 선택적 속성으로, 서버의 특정 문서에만 쿠키를 할당할 수 있음
- Path 속성값이 URL 경로 앞부분과 일치하면 쿠키 전달함
- '/foo' 경로는 '/foobar'와 '/foo/bar.html'에 적용됨
- 경로 미지정 시 Set-Cookie 응답 전달 URL의 경로가 사용됨
- '/' 경로는 도메인 내 모든 곳에 적용됨
- 예: `Set-Cookie: lastorder=00183; path=/orders`

#### Secure

- 선택적 속성으로, 이 속성 포함 시 HTTP가 SSL 보안 연결일 때만 쿠키 전송함
- 예: `Set-Cookie: private_id=519; secure`

#### Version 0 Cookie 헤더

클라이언트가 서버에 요청 시, 현재 요청 사이트와 일치하는 `Domain`/`Path`/`Secure` 필터를 가지면서 아직 파기되지 않은 모든 쿠키를 `Cookie` 헤더에 포함시켜 전송함.

예: `Cookie: session-id=002-1145265-8016838; session-id-time=1007884800`
