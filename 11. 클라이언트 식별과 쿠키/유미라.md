# 1. 개별 접촉
HTTP는 익명이며 상태가 없는 요청-응답 방식의 통신 프로토콜이다. 하지만 웹 서버는 사용자를 식별하고 연속적인 요청을 추적하기 위해 일부 정보를 활용할 수 있다. 현대 웹사이트는 개인화된 서비스를 제공하기 위해 사용자 정보를 저장하고 활용한다.

1. **개별 인사** : 사용자에게 맞춤형 환영 메시지나 페이지 내용을 제공
2. **사용자 맞춤 추천** : 고객의 관심사를 학습해 선호할 만한 제품을 추천
3. **저장된 사용자 정보** : 주소나 결제 정보를 저장해 쇼핑을 편리하게 만듦
4. **세션 추적** : HTTP는 상태가 없지만, 장바구니 기능 등 사용자 상태를 유지하려면 각 요청을 식별하는 방법이 필요

# 2. HTTP 헤더
<img width="574" alt="image" src="https://github.com/user-attachments/assets/8cf8f888-76e9-46d6-b985-82eb4c287818" />

1. `From` 헤더 : 사용자의 이메일 주소를 포함하지만, 스팸 문제로 인해 대부분의 브라우저가 이를 전송하지 않는다.
2. `User-Agent` 헤더: 브라우저와 운영체제 정보를 제공하여 콘텐츠 최적화에 유용하지만, 개별 사용자 식별에는 한계가 있다.
3. `Referer` 헤더: 사용자가 이전에 방문한 페이지 정보를 포함하여 사용자의 관심사를 파악하는 데 도움을 줄 수 있다.

`From`, `User-Agent`, `Referer` 헤더는 사용자 식별과 관련된 정보를 포함하지만, 단독으로는 특정 사용자를 정확히 식별하기 어렵다.

# 3. 클라이언트 IP 주소
초기 웹에서는 클라이언트의 IP 주소를 사용자 식별에 활용하려 했지만, 여러 한계로 인해 효과적인 방법이 아니었다.

## IP 주소를 이용한 사용자 식별의 문제점
1. **컴퓨터 식별 한계** : IP 주소는 개별 사용자가 아닌 컴퓨터를 가리키므로, 여러 사용자가 같은 컴퓨터를 쓰면 식별이 불가능하다.
2. **동적 IP 할당** : ISP가 로그인 시마다 새로운 IP를 할당하면 사용자가 매번 다른 IP를 가지게 된다.
3. **NAT(Network Address Translation)** : 여러 사용자가 하나의 공용 IP를 공유하므로 개별 사용자 구분이 어렵다.
4. **프락시 및 게이트웨이** : 웹 서버가 실제 클라이언트가 아닌 프락시 서버의 IP를 보게 되며, 일부 프락시만 원본 IP를 전달하는 확장 헤더를 추가한다.

<img width="576" alt="image" src="https://github.com/user-attachments/assets/72ec13a3-9c66-42ac-985a-5a36aecb6712" />

# 4. 사용자 로그인
- 웹 서버는 사용자를 식별하기 위해 IP 주소 대신 사용자 이름과 비밀번호를 통한 로그인을 요구할 수 있다.
- HTTP는 WWW-Authenticate 및 Authorization 헤더를 사용하여 인증을 지원하며, 로그인 후 브라우저는 모든 요청에 로그인 정보를 자동으로 포함한다.

<img width="537" alt="image" src="https://github.com/user-attachments/assets/7b57fcd7-0923-48a3-8946-8f22d73d76b6" />

1. 브라우저가 www.joes-hardware.com 사이트에 요청을 보내면, 서버는 사용자의 식별 정보를 알지 못해 HTTP 401 Login Required 응답과 함께 WWW-Authenticate 헤더를 반환하여 로그인을 요구한다.
2. 브라우저는 로그인 대화상자를 띄우고, 사용자가 로그인 정보를 입력하면 브라우저는 해당 정보를 포함해 요청을 다시 보낸다.
3. 서버는 이제 사용자의 식별 정보를 알게 되고, 이후 브라우저는 요청할 때마다 Authorization 헤더에 사용자 정보를 자동으로 포함해 서버로 전송하여 세션 동안 사용자 식별을 유지한다.

## 문제점
- 로그인 과정은 번거롭고 불편하다. 
- 예를 들어, 프레드는 사이트마다 로그인해야 하고, 각 사이트에 대해 서로 다른 사용자 이름과 비밀번호를 기억해야 한다. 
- 또한, 사용자 이름이 이미 다른 사람에 의해 사용되거나 사이트마다 비밀번호 규칙이 달라서 불편하다.

# 5. 뚱뚱한 URL
일부 웹사이트는 URL에 사용자 식별 정보(예: 세션 ID)를 추가하여 사용자를 추적하는 방식을 사용했다. 이러한 URL을 **뚱뚱한 URL**이라고 하며, 사용자의 세션을 유지하는 데 활용된다.

## 작동 방식
1. 사용자가 웹사이트에 방문하면 고유한 세션 ID가 생성됨
2. 서버는 이 세션 ID를 URL에 포함한 후, 사용자에게 리다이렉트하여 적용된 URL을 제공
3. 이후 웹사이트의 모든 하이퍼링크는 이 세션 ID가 포함된 URL로 자동 변경됨
4. 사용자가 사이트 내에서 이동할 때 URL을 통해 세션 정보를 유지함

## 문제점
- **못생긴 URL** : 길고 복잡한 URL로 사용자 혼란
- **공유하지 못 하는 URL** : URL에 세션 정보가 포함되어 다른 사람에게 개인 정보가 노출될 위험
- **캐시를 사용할 수 없음** : URL 변경으로 인해 캐시 사용 불가
- **서버 부하 가중** : 매번 페이지를 다시 생성해야 함
- **이탈** : 사용자가 다른 사이트로 이동하거나 다른 URL을 요청하면 세션에서 이탈하게 되어, 세션 정보 초기화
- **세션 간 지속성의 부재** : URL을 북마크하지 않으면 로그아웃 시 모든 정보 손실

# 6. 쿠키
- 쿠키는 사용자를 식별하고 세션을 유지하는 주요 웹 기술로, 모든 브라우저에서 지원된다.

## 6.1 쿠키의 타입
- `세션 쿠키` : 브라우저를 닫으면 삭제되는 임시 쿠키
- `지속 쿠키` : 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작해도 남아있다.

## 6.2 쿠키는 어떻게 동작하는가
<img width="474" alt="image" src="https://github.com/user-attachments/assets/cff6c0e8-7a93-43f2-a12b-87bcbcb5738e" />

- **쿠키 생성** : 서버는 사용자가 웹사이트에 처음 방문할 때, 고유한 식별 값을 쿠키로 할당하고 Set-Cookie 헤더를 통해 사용자에게 전달한다.
- **쿠키 저장** : 브라우저는 서버가 전달한 쿠키를 쿠키 데이터베이스에 저장한다.
- **쿠키 활용** : 사용자가 다시 방문하면, 브라우저는 저장된 쿠키를 Cookie 요청 헤더에 담아 서버로 전송한다.
- **쿠키 내용** : 쿠키는 어떤 정보든 포함할 수 있으며, 보통 사용자 식별을 위한 고유번호나 사용자 관련 정보를 포함한다.
  - `Cookie: name="Brian Totty"; phone="555-1212")`

## 6.3 쿠키 상자: 클라이언트 측 상태
- **HTTP 상태 관리 체계 (클라이언트 상태)** : 브라우저가 쿠키 정보를 저장하고 관리하는 시스템

### 구글 크롬 쿠키
- 쿠키는 SQLite 파일에 저장된다.
- 주요 필드
  - `creation_utc`: 쿠키 생성 시점 (초 단위)
  - `host_key`: 쿠키의 도메인
  - `name`: 쿠키의 이름
  - `value`: 쿠키의 값
  - `path`: 관련된 도메인 경로
  - `expire_utc`: 쿠키의 파기 시점 (초 단위)
  - `secure`: SSL 연결에서만 쿠키를 전송할지 여부

### 마이크로소프트 인터넷 익스플로러
<img width="534" alt="image" src="https://github.com/user-attachments/assets/0bbe2179-7a11-42ef-a8d1-e60b7383d5af" />

- 쿠키는 개별 파일로 저장된다.
- 파일 구조
  - line 1 : 쿠키의 이름
  - line 2 : 쿠키의 값
  - line 3 : 도메인과 경로
  - 기타 : 날짜, 표식 등의 추가 정보 

## 6.4 사이트마다 각기 다른 쿠키들
### 쿠키 전송 제한
- 브라우저는 모든 쿠키를 모든 사이트에 보내지 않는다.
  - 성능 저하를 막기 위해, 보통 각 사이트에 두세 개의 쿠키만 전송한다.
  - 쿠키 대부분은 특정 사이트에 특화된 값이므로 다른 사이트에 전달되는 것은 의미가 없다.
  - 모든 쿠키를 전달하면 개인정보 유출 위험이 커진다.
- 쿠키는 쿠키를 생성한 서버에게만 전달된다.

### 광고사의 쿠키 사용
- 웹사이트는 광고 네트워크와 협력해 지속 쿠키를 설정하고, 이를 통해 사용자의 행동을 추적한다.
- 사용자가 다른 웹사이트를 방문할 때, 같은 광고사의 쿠키가 전송되어 광고 서버가 사용자의 데이터를 추적한다.
- 광고사는 Referer 헤더를 통해 사용자의 프로필과 웹사이트 사용 습관을 추적하여, 맞춤형 광고를 제공한다.
- 최신 브라우저는 개인정보 보호 설정을 통해 쿠키 사용을 제한할 수 있다.

### 쿠키 도메인 속성
- 서버는 Set-Cookie 응답 헤더의 Domain 속성을 사용해 쿠키를 특정 도메인과 하위 도메인에서 유효하도록 설정한다.
- `Set-Cookie: user="maryl7"; domain="airtravelbargains.com`
  - airtravelbargains.com과 그 하위 도메인에서 사용될 수 있으며, 브라우저는 이를 해당 도메인에 포함된 모든 사이트로 전송한다.

### 쿠키 Path 속성
- 서버는 쿠키 생성 시 Path 속성을 지정하여, 해당 경로에 속하는 페이지에 쿠키를 설정할 수 있다.
- `Set-cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/`
  - 사용자가 `http://www.airtravelbargains.com/specials.html`에 접근할 경우
    - Cookie: user="maryl7"
  - 사용자가 `http://www.airtravelbargains.com/autos/cheapo/index.html`에 접근할 경우
    - Cookie: user="mary17"
    - Cookie: pref=compact

## 6.5 쿠키 구성 요소
<img width="581" alt="image" src="https://github.com/user-attachments/assets/5efb78eb-16e3-4dda-b957-df7da7eff5e8" />

- **Version 0 쿠키** : 흔히 '넷스케이프 쿠키'라고 불리며, 초기 쿠키 명세이다.
- **Version 1 쿠키 (RFC 2965)** : Version 0 쿠키의 확장으로, 널리 사용되지 않는다.
- 두 명세 모두 HTTP/1.1 명세의 일부로 기술되지 않았다.

> Q. 현재의 쿠키 표준은?

## 6.6 Version 0(넷스케이프) 쿠키
```
Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: namel=valuel [; name2=value2] ...
```

### Version 0 Set-Cookie 헤더
<img width="573" alt="image" src="https://github.com/user-attachments/assets/495ec5e8-cbf6-4f73-9602-c0667bb69e4d" />
<img width="573" alt="image" src="https://github.com/user-attachments/assets/86dc037b-fbd0-48e5-b48c-f882a81179f4" />

### Version 0 Cookie 헤더
```
Cookie: session—id=002-1145265-8016838; session-id-time=1007884800
```

- 요청하려는 사이트의 Domain, Path, Secure 조건에 맞는 쿠키를 Cookie 헤더에 담아 서버로 전송한다.
- 전송된 쿠키는 파기되지 않은 쿠키들만 포함되며, 여러 쿠키는 하나의 Cookie 헤더에 이어서 보낸다.

# 6.7 Version 1 (RFC 2965) 쿠키
## RFC 2965에서 추가된 주요 변경사항
- 쿠키 목적 설명
- 브라우저 종료 시 삭제 가능
- Max-Age
- 포트 번호 제어
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 포함
- 호환되는 버전 번호
- Cookie 헤더에서 사용자 이름 및 키워드를 구별하기 위해 `$` 접두어 사용

## Version 1 쿠키의 문법
<img width="487" alt="image" src="https://github.com/user-attachments/assets/d547323c-9696-4af8-89f6-93c036a6c19a" />

## Version 1 Set-Cookie2 헤더
![image](https://github.com/user-attachments/assets/2ae7e4bb-fc3c-4e32-8e52-dcc60fd23549)

## Version 1 Cookie 헤더
- Version 1 쿠키는 서버가 전송한 쿠키와 관련된 필터 정보(`$` 접두어)를 포함하여 쿠키를 전송한다.
- `Set-Cookie2` 응답
```
Set-Cookie2: ID="29046"; Domain=".joes-hardware.com"
Set-Cookie2: color=blue
Set-Cookie2: support-pref="L2"; Domain="customer-care.joes-hardware.com"
Set-Cookie2: Coupon='hammer027"; Version="1"; Path="/tools"
Set-Cookie2: Coupon="handvacl03"; Version="1"; Path="/tools/cordless"
```

- `/tools/cordless/specials.html`로 요청
```
Cookie: $Version="1"; ID="29046"; $Domain=".joes-hardware.com";
        color="blue";
        Coupon="hammer027"; $Path="/tools";
        Coupon="handvacl03"; $Path="/tools/cordless"
```

## Version 1 Cookie2 헤더와 버전 협상
- 클라이언트는 Cookie2 헤더에 Version 정보를 담아, 자신이 새로운 형식의 쿠키를 지원한다고 서버에 알린다.
  - `Cookie2: $Version="1"`
- 서버는 클라이언트의 Cookie2 헤더를 보고, Set-Cookie2 헤더를 응답으로 보내야 한다. 즉, Set-Cookie가 아닌 Set-Cookie2로 쿠키를 보낸다.
- 만약 클라이언트가 Set-Cookie와 Set-Cookie2 헤더를 모두 받으면, Set-Cookie2가 우선시되고, Set-Cookie 헤더는 무시된다.
- 클라이언트가 Version 0과 Version 1 쿠키 모두를 지원할 때, 서버에서 Version 0 쿠키를 보내면, 클라이언트는 Version 0 쿠키를 전송해야 한다.
  -  하지만, 클라이언트는 버전 업그레이드를 알리기 위해 Cookie2: $Version="1"을 보내야 한다.

# 6.8 쿠키와 세션 추적
- 쿠키는 웹 사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는 데 사용한다.
- 전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에도 그들의 쇼핑 카트를 유지하려 세션 쿠키를 사용한다.

![image](https://github.com/user-attachments/assets/6a45faea-268e-4b97-8fe7-3fb6b4565969)

- a : 사용자가 http://www.amazon.com을 입력하면 브라우저가 루트 페이지를 요청한다.
- b : 서버는 클라이언트를 전자상거래 소프트웨어 URI로 리다이렉트한다.
- c : 클라이언트는 리다이렉트된 URL로 요청을 보낸다.
- d :
  - 서버는 응답으로 두 개의 세션 쿠키(임시 쿠키)를 설정하고 클라이언트를 또 다른 URL로 리다이렉트시킨다.
  - 이 리다이렉트된 URL은 뚱뚱한 URL이라고도 불리며, 그 자체로 상태 정보를 담고 있다.
  - 사용자가 쿠키를 비활성화한 경우, 서버는 뚱뚱한 URL을 통해 세션을 유지하며, 사용자가 사이트를 떠나지 않는 한 최소한의 식별 과정은 계속 진행된다.
- e : 클라이언트는 두 개의 쿠키를 포함한 새로운 URL을 요청한다.
- f : 서버는 클라이언트를 home.html 페이지로 리다이렉트하고, 두 개의 쿠키(장기 쿠키)를 더 첨부한다.
- g : 클라이언트는 home.html 페이지를 가져오고, 총 네 개의 쿠키를 서버에 전송한다.
- h : 서버는 콘텐츠를 클라이언트에 보낸다.

> Q. 쿠키를 단계적으로 설정하는 이유?

# 6.9 쿠키와 캐싱
- 쿠키가 포함된 응답을 캐싱할 때, 이전 사용자의 쿠키 정보가 다른 사용자에게 할당되거나 개인 정보가 노출될 수 있으므로 주의가 필요하다.

## 캐시를 다루는 기본 원칙
- **캐시되지 말아야 할 문서가 있다면 표시하라**
  - 문서의 소유자(즉, 웹 서버)가 문서를 캐시할지 여부를 결정한다.
  - Set-Cookie 헤더는 캐시에서 제외할 수 있으며, `no-cache=Set-Cookie`를 통해 명시적으로 설정할 수 있다.
  - `Cache-Control: public`을 사용하면 문서를 모든 사용자에게 캐시할 수 있어 대역폭을 절약할 수 있다.
- **Set-Cookie 헤더를 캐시 하는 것에 유의하라**
  - Set-Cookie 헤더가 포함된 응답을 캐싱할 때는 특별한 주의가 필요하다.
  - 캐시된 Set-Cookie 헤더를 여러 사용자에게 제공하면 사용자 추적이 실패할 수 있고, 일부 캐시는 이 헤더를 제거하여 클라이언트에게 전달하지 않는 문제가 발생할 수 있다.
  - 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술해서 이 문제를 개선할 수 있다.
  - 보수적인 캐시는 Set-Cookie 헤더가 있는 응답을 아예 캐시하지 않거나 콘텐츠 유형에 따라 선택적으로 캐시하기도 한다.
- **Cookie 헤더를 가지고 있는 요청을 주의하라**
  - Cookie 헤더가 포함된 요청은 개인정보를 담은 응답을 받을 가능성이 있으므로 주의해야 한다.
  - 개인정보는 캐시되지 않도록 표시되어야 하지만, 모든 서버가 이를 준수하지는 않는다.
  - 보수적인 캐시는 Cookie 헤더가 포함된 요청에 대한 응답을 아예 캐시하지 않거나, 콘텐츠 유형에 따라 선택적으로 캐시한다.
  - 효율적인 방법은 캐시된 이미지에 파기 시간이 0인 Cookie 헤더를 설정하여 매번 재검사를 강제하는 것이다.

> Q. 파기 시간이 0이라면 쿠키를 쓰는 이유가 있나?

# 6.10 쿠키, 보안 그리고 개인정보
- 쿠키를 비활성화할 수 있으며, 로그 분석 등을 통해 대체할 수 있으므로 쿠키 자체가 보안적으로 크게 위험하지 않다.
- 원격 데이터베이스에 개인 정보를 저장하고, 쿠키에는 해당 데이터의 키 값만 저장하는 방식은 민감한 데이터를 보호하는 데 유용하다.
- 협력업체 웹 사이트가 지속 쿠키를 이용해 사용자를 추적하려는 마케팅 활동이 문제가 될 수 있다.
  - 쿠키를 IP 주소나 Referer 헤더 정보와 함께 사용하면, 마케팅 회사들이 사용자의 프로필을 매우 정확하게 수집할 수 있다. 
- 쿠키에 대한 부정적인 여론이 있지만, 개인정보를 누가 받는지 명확히 알고, 사이트의 개인정보 정책에 유의한다면 세션 관리나 트랜잭션에서 쿠키의 편리함이 더 중요할 수 있다.

## 정리
- 쿠키는 웹 서버가 사용자를 식별하고, 사용자의 이전 방문 정보(예: 사용자 번호 등)를 저장하여, 이후 방문 시 다시 서버로 전달하는 작은 데이터
- 대부분의 쿠키는 브라우저 종료 시 삭제되며, 지속 쿠키는 설정된 만료일까지 디스크에 저장된다.
- 쿠키는 시스템의 취약점을 손상시키거나 네트워크 스누핑을 유발하지 않는다.
  - 쿠키 자체는 단순히 웹사이트 방문 기록을 저장하는 기능을 하며, 사용자 행동을 추적하는 데 사용될 수 있다.
  - 웹 서버의 로그 파일을 통해서도 사용자 행동 추적이 가능하며, 쿠키는 이를 더 효율적으로 관리한다.
