# 11.1 개별 접촉

**HTTP의 특징**

- 익명으로 사용
- 상태를 저장하지 않는(stateless) 프로토콜
- 요청(Request)과 응답(Response)으로 통신

**웹 서버의 역할**

- 클라이언트의 요청을 처리하고 응답을 반환
- 사용자를 식별하고 연속적인 요청을 추적

**현대 웹 사이트**

- 개인화된 서비스 제공
- 사용자 데이터 수집 및 브라우징 기록 저장
- 예시: Amazon.com은 다양한 방식으로 개인화된 서비스 제공

**사용자 개인화 기술**

1. 개별 인사

- 사용자에게 특화된 환영 메시지 및 페이지 제공

2. 사용자 맞춤 추천

- 고객의 관심사를 학습하여 추천 상품 제공
- 생일이나 중요한 날에 특별한 제품 추천

3. 저장된 사용자 정보

- 주소 및 신용카드 정보를 저장하여 쇼핑 편의성 향상

4. 세션 추적

- HTTP는 상태를 저장하지 않으므로 웹사이트가 별도로 사용자 상태 관리
- 예: 장바구니 기능을 유지하려면 사용자 식별 필요

**사용자 식별 기술**

1. **HTTP 헤더**: 사용자 정보 전달
2. **IP 주소 추적**: 클라이언트 IP를 기반으로 식별
3. **사용자 로그인 인증**: 계정 기반 식별
4. **뚱뚱한(Fat) URL**: URL에 식별자 포함
5. **쿠키**: 지속적인 식별을 위한 강력하고 효율적인 방법

# 11.2 HTTP 헤더

**HTTP 요청 헤더를 통한 사용자 정보 전달**

| 헤더 이름      | 헤더 타입 | 설명                                             |
| -------------- | --------- | ------------------------------------------------ |
| **From**       | 요청      | 사용자의 이메일 주소 (현재 대부분 사용되지 않음) |
| **User-Agent** | 요청      | 브라우저 및 운영체제 정보 제공                   |
| **Referer**    | 요청      | 사용자가 현재 페이지로 유입된 근원 페이지        |

**From 헤더**

- 사용자의 이메일 주소 포함
- 스팸 우려로 인해 대부분의 브라우저가 사용하지 않음
- 웹 로봇이나 스파이더가 문제 일으켰을 때, 웹마스터와의 연락을 위해 사용

**User-Agent 헤더**

- 브라우저 및 운영체제 정보 포함
- 콘텐츠 최적화에 유용하지만, 특정 사용자 식별에는 도움안됨
- 예시:
  - 크롬 38,0.2125.111 User-Agent:  
    `Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36`
  - 인터넷 익스플로러 9.0.29 User-Agent:  
     `Mozilla/4.0 （compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E`

**Referer 헤더**

- 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL 제공
- 특정 사용자 식별은 어렵지만, 관심사 분석에 활용 가능
- 예: 야구 사이트에서 유입된 사용자는 야구에 관심이 있을 가능성이 높음

**추가적인 사용자 식별 헤더**

| 헤더 이름           | 헤더 타입  | 설명                                       |
| ------------------- | ---------- | ------------------------------------------ |
| **Authorization**   | 요청       | 사용자 인증 (아이디, 비밀번호)             |
| **Client-IP**       | 확장(요청) | 클라이언트의 IP 주소                       |
| **X-Forwarded-For** | 확장(요청) | 클라이언트의 실제 IP 주소 (프록시 사용 시) |
| **Cookie**          | 확장(요청) | 서버가 설정한 사용자 식별 ID               |

From, User-Agent, Referer 헤더만으로는 특정 사용자 식별이 어려움. 더 정확한 식별 방법(인증, IP 추적, 쿠키 등)이 필요함

# 11.3 클라이언트 IP 주소

초기 웹 개발자들은 사용자의 **고정된 IP 주소**를 활용해 사용자 식별을 시도.

**클라이언트 IP 주소로 사용자 식별이 어려운 이유**

1. **IP 주소는 기기 식별**

- 같은 기기를 여러 사용자가 공유할 수 있음

2. **동적 IP 할당**

- ISP가 로그인(인터넷 연결)할 때마다 다른 IP를 부여함

3. **NAT(Network Address Translation)**

- 여러 사용자가 하나의 공용 IP 사용
- NAT: IP 주소 부족 문제 해결을 위함. 여러 기기가 인터넷에 접속할 때 하나의 공용 IP 주소만 사용하도록 함.(내부 네트워크에서는 사설 IP 주소를 가짐)

4. **프록시 서버 문제**

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/7280663c-ecf0-4e28-8b6e-0209803c4d54" />

- 실제 IP가 아닌 프록시 IP만 확인됨.
- 일부 프록시는 원본 IP 주소를 보존하려고 Client-ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가해 해결하지만, 모든 프록시가 이런 식으로 동작하진 않음

# 11.4 사용자 로그인

<img width="421" alt="Image" src="https://github.com/user-attachments/assets/4be5e38e-e5d5-4688-b4ec-183cff6e09cd" />

**HTTP 기본 인증 방식**

1. **브라우저가 웹 서버에 요청**
2. **서버가 401 Login Required 응답 코드** 와, `WWW-Authenticate` 헤더를 반환하여 로그인 하라고 요청
3. **브라우저가 로그인 대화 상자 표시**
4. **사용자가 입력한 로그인 정보**를 `Authorization` 헤더로 다시 요청
5. **로그인 성공 후 모든 요청에 로그인 정보 포함**

**웹 사이트 로그인 문제점**

- **사이트마다 로그인해야 함** → 사용자가 불편함을 느낌
- **각 사이트별 다른 계정 정보 필요** → 기억하기 어려움
- **일관되지 않은 인증 정책** → 아이디, 비밀번호 규칙이 사이트마다 다름

# 11.5 뚱뚱한 URL

**뚱뚱한 URL이란?**

- 사용자의 **세션 정보**를 URL에 포함하여 사용자 식별 및 추적
- URL 경로의 **앞뒤에 상태 정보 추가**
- 사용자가 사이트를 돌아다니면 서버는 URL에 있는 상태 정보를 유지하는 **하이퍼링크를 동적으로 생성**

**예시**

```html
<a href="/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838,,>All
Gifts</a><br>
<a href=,,/exec/obidos/wishlist/ref=gr_pll_/002-1145265-8016838*,>Wish List</a><br>
```

- 002-1145265-8016838: 사용자 식별 ID
- 사용자가 사이트를 이동할 때마다 이 ID를 유지

**뚱뚱한 URL의 동작 방식**

1. **웹 사이트 첫 방문 시, 고유 ID 생성**

- 서버가 사용자를 식별하기 위해 **고유한 ID**를 생성
- 이 ID는 URL에 추가되어 **세션을 유지하는 용도로 사용됨**

2. **사용자를 뚱뚱한 URL로 리디렉트**

- 서버는 생성된 **고유 ID가 포함된 URL**로 사용자를 리디렉트
- 이후 모든 요청은 이 ID를 포함한 URL을 통해 이루어짐

3. **서버가 요청을 받을 때 사용자 정보 조회**

- 서버는 요청된 URL에서 **사용자 ID를 추출**
- 해당 ID와 관련된 **세션 정보(예: 쇼핑 카트, 프로필 정보 등)를 불러옴**

4. **모든 하이퍼링크를 뚱뚱한 URL로 변환**

- 사용자가 클릭할 수 있는 **모든 링크에 고유 ID를 추가**
- 사용자가 사이트를 탐색할 때 **항상 세션 정보가 유지되도록 함**

**뚱뚱한 URL의 문제점**

1. 못생긴 URL

- URL이 길고 복잡하여 **사용자가 이해하기 어려움**

2. 공유 불가능한 URL

- URL에 **개인 식별 정보가 포함**되기 때문에 링크를 공유하면 **다른 사용자에게 개인 정보 노출 위험**

3. 캐싱 불가

- URL이 요청마다 달라지므로 **브라우저 및 프록시 캐시를 사용할 수 없음**

4. 서버 부하 증가

- 캐싱이 안되므로 요청마다 **새로운 HTML 페이지를 생성해야 함**

5. 이탈 문제

- 사용자가 다른 사이트로 이동하거나 새로고침하면 **세션 정보가 사라짐**
- 예) **쇼핑 카트 정보 초기화**

6. 세션 간 지속성 부족

- 사용자가 **뚱뚱한 URL을 북마크하지 않으면 세션 정보 유지 불가**
