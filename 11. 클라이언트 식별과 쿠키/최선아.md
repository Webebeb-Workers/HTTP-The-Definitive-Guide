# 11.1 개별 접촉

**HTTP의 특징**

- 익명으로 사용
- 상태를 저장하지 않는(stateless) 프로토콜
- 요청(Request)과 응답(Response)으로 통신

**웹 서버의 역할**

- 클라이언트의 요청을 처리하고 응답을 반환
- 사용자를 식별하고 연속적인 요청을 추적

**현대 웹 사이트**

- 개인화된 서비스 제공
- 사용자 데이터 수집 및 브라우징 기록 저장
- 예시: Amazon.com은 다양한 방식으로 개인화된 서비스 제공

**사용자 개인화 기술**

1. 개별 인사

- 사용자에게 특화된 환영 메시지 및 페이지 제공

2. 사용자 맞춤 추천

- 고객의 관심사를 학습하여 추천 상품 제공
- 생일이나 중요한 날에 특별한 제품 추천

3. 저장된 사용자 정보

- 주소 및 신용카드 정보를 저장하여 쇼핑 편의성 향상

4. 세션 추적

- HTTP는 상태를 저장하지 않으므로 웹사이트가 별도로 사용자 상태 관리
- 예: 장바구니 기능을 유지하려면 사용자 식별 필요

**사용자 식별 기술**

1. **HTTP 헤더**: 사용자 정보 전달
2. **IP 주소 추적**: 클라이언트 IP를 기반으로 식별
3. **사용자 로그인 인증**: 계정 기반 식별
4. **뚱뚱한(Fat) URL**: URL에 식별자 포함
5. **쿠키**: 지속적인 식별을 위한 강력하고 효율적인 방법

# 11.2 HTTP 헤더

**HTTP 요청 헤더를 통한 사용자 정보 전달**

| 헤더 이름      | 헤더 타입 | 설명                                             |
| -------------- | --------- | ------------------------------------------------ |
| **From**       | 요청      | 사용자의 이메일 주소 (현재 대부분 사용되지 않음) |
| **User-Agent** | 요청      | 브라우저 및 운영체제 정보 제공                   |
| **Referer**    | 요청      | 사용자가 현재 페이지로 유입된 근원 페이지        |

**From 헤더**

- 사용자의 이메일 주소 포함
- 스팸 우려로 인해 대부분의 브라우저가 사용하지 않음
- 웹 로봇이나 스파이더가 문제 일으켰을 때, 웹마스터와의 연락을 위해 사용

**User-Agent 헤더**

- 브라우저 및 운영체제 정보 포함
- 콘텐츠 최적화에 유용하지만, 특정 사용자 식별에는 도움안됨
- 예시:
  - 크롬 38,0.2125.111 User-Agent:  
    `Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.111 Safari/537.36`
  - 인터넷 익스플로러 9.0.29 User-Agent:  
     `Mozilla/4.0 （compatible; MSIE 7.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E`

**Referer 헤더**

- 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL 제공
- 특정 사용자 식별은 어렵지만, 관심사 분석에 활용 가능
- 예: 야구 사이트에서 유입된 사용자는 야구에 관심이 있을 가능성이 높음

**추가적인 사용자 식별 헤더**

| 헤더 이름           | 헤더 타입  | 설명                                       |
| ------------------- | ---------- | ------------------------------------------ |
| **Authorization**   | 요청       | 사용자 인증 (아이디, 비밀번호)             |
| **Client-IP**       | 확장(요청) | 클라이언트의 IP 주소                       |
| **X-Forwarded-For** | 확장(요청) | 클라이언트의 실제 IP 주소 (프록시 사용 시) |
| **Cookie**          | 확장(요청) | 서버가 설정한 사용자 식별 ID               |

From, User-Agent, Referer 헤더만으로는 특정 사용자 식별이 어려움. 더 정확한 식별 방법(인증, IP 추적, 쿠키 등)이 필요함

# 11.3 클라이언트 IP 주소

초기 웹 개발자들은 사용자의 **고정된 IP 주소**를 활용해 사용자 식별을 시도.

**클라이언트 IP 주소로 사용자 식별이 어려운 이유**

1. **IP 주소는 기기 식별**

- 같은 기기를 여러 사용자가 공유할 수 있음

2. **동적 IP 할당**

- ISP가 로그인(인터넷 연결)할 때마다 다른 IP를 부여함

3. **NAT(Network Address Translation)**

- 여러 사용자가 하나의 공용 IP 사용
- NAT: IP 주소 부족 문제 해결을 위함. 여러 기기가 인터넷에 접속할 때 하나의 공용 IP 주소만 사용하도록 함.(내부 네트워크에서는 사설 IP 주소를 가짐)

4. **프록시 서버 문제**

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/7280663c-ecf0-4e28-8b6e-0209803c4d54" />

- 실제 IP가 아닌 프록시 IP만 확인됨.
- 일부 프록시는 원본 IP 주소를 보존하려고 Client-ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가해 해결하지만, 모든 프록시가 이런 식으로 동작하진 않음

# 11.4 사용자 로그인

<img width="421" alt="Image" src="https://github.com/user-attachments/assets/4be5e38e-e5d5-4688-b4ec-183cff6e09cd" />

**HTTP 기본 인증 방식**

1. **브라우저가 웹 서버에 요청**
2. **서버가 401 Login Required 응답 코드** 와, `WWW-Authenticate` 헤더를 반환하여 로그인 하라고 요청
3. **브라우저가 로그인 대화 상자 표시**
4. **사용자가 입력한 로그인 정보**를 `Authorization` 헤더로 다시 요청
5. **로그인 성공 후 모든 요청에 로그인 정보 포함**

**웹 사이트 로그인 문제점**

- **사이트마다 로그인해야 함** → 사용자가 불편함을 느낌
- **각 사이트별 다른 계정 정보 필요** → 기억하기 어려움
- **일관되지 않은 인증 정책** → 아이디, 비밀번호 규칙이 사이트마다 다름

# 11.5 뚱뚱한 URL

**뚱뚱한 URL이란?**

- 사용자의 **세션 정보**를 URL에 포함하여 사용자 식별 및 추적
- URL 경로의 **앞뒤에 상태 정보 추가**
- 사용자가 사이트를 돌아다니면 서버는 URL에 있는 상태 정보를 유지하는 **하이퍼링크를 동적으로 생성**

**예시**

```html
<a href="/exec/obidos/tg/browse/-/229220/ref=gr_gifts/002-1145265-8016838,,>All
Gifts</a><br>
<a href=,,/exec/obidos/wishlist/ref=gr_pll_/002-1145265-8016838*,>Wish List</a><br>
```

- 002-1145265-8016838: 사용자 식별 ID
- 사용자가 사이트를 이동할 때마다 이 ID를 유지

**뚱뚱한 URL의 동작 방식**

1. **웹 사이트 첫 방문 시, 고유 ID 생성**

- 서버가 사용자를 식별하기 위해 **고유한 ID**를 생성
- 이 ID는 URL에 추가되어 **세션을 유지하는 용도로 사용됨**

2. **사용자를 뚱뚱한 URL로 리디렉트**

- 서버는 생성된 **고유 ID가 포함된 URL**로 사용자를 리디렉트
- 이후 모든 요청은 이 ID를 포함한 URL을 통해 이루어짐

3. **서버가 요청을 받을 때 사용자 정보 조회**

- 서버는 요청된 URL에서 **사용자 ID를 추출**
- 해당 ID와 관련된 **세션 정보(예: 쇼핑 카트, 프로필 정보 등)를 불러옴**

4. **모든 하이퍼링크를 뚱뚱한 URL로 변환**

- 사용자가 클릭할 수 있는 **모든 링크에 고유 ID를 추가**
- 사용자가 사이트를 탐색할 때 **항상 세션 정보가 유지되도록 함**

**뚱뚱한 URL의 문제점**

1. 못생긴 URL

- URL이 길고 복잡하여 **사용자가 이해하기 어려움**

2. 공유 불가능한 URL

- URL에 **개인 식별 정보가 포함**되기 때문에 링크를 공유하면 **다른 사용자에게 개인 정보 노출 위험**

3. 캐싱 불가

- URL이 요청마다 달라지므로 **브라우저 및 프록시 캐시를 사용할 수 없음**

4. 서버 부하 증가

- 캐싱이 안되므로 요청마다 **새로운 HTML 페이지를 생성해야 함**

5. 이탈 문제

- 사용자가 다른 사이트로 이동하거나 새로고침하면 **세션 정보가 사라짐**
- 예) **쇼핑 카트 정보 초기화**

6. 세션 간 지속성 부족

- 사용자가 **뚱뚱한 URL을 북마크하지 않으면 세션 정보 유지 불가**

# 11.6 쿠키

**사용 목적**: 사용자를 식별하고 세션을 유지하는 데 사용되는 가장 널리 사용되는 방식
**기술적 특징**: 이전에 설명한 다른 기술들이 겪는 문제점들을 겪지 않으며, 때로는 함께 사용되기도 함
**역사**: 넷스케이프가 최초로 개발했으며, 현재 모든 브라우저에서 지원됨
**중요성**: 중요한 웹 기술일 뿐만 아니라, 새로운 HTTP 헤더를 정의하는 데 사용됨
**캐시와의 관계**: 쿠키는 캐시와 충돌할 수 있어, 대부분의 브라우저나 캐시는 쿠키에 포함된 내용을 캐싱하지 않음

## 11.6.1 쿠키의 타입

쿠키는 크게 **세션 쿠키 (Session Cookie)**와 **지속 쿠키 (Persistent Cookie)** 두 가지 타입으로 나뉨

**세션 쿠키 (Session Cookie)**:

- 사용자가 사이트를 탐색할 때 관련된 설정과 선호 사항들을 저장하는 임시 쿠키
- 브라우저를 닫으면 자동으로 삭제됨

**지속 쿠키 (Persistent Cookie)**:

- 삭제되지 않고 더 길게 유지됨
- 디스크에 저장되어 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아 있음
- 주로 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 정보를 유지하는 데 사용됨

**세션 쿠키와 지속 쿠키의 차이점**:

- 주된 차이점은 파기되는 시점임
- 쿠키는 `Discard` 파라미터가 설정되어 있거나, 파기되기 까지 남은 시간을 가리키는 `Expires` 혹은 `Max-Age` 파라미터가 없으면 세션 쿠기가 됨

## 11.6.2 쿠키는 어떻게 동작하는가

**쿠키의 비유**:

- 쿠키는 서버가 사용자에게 붙이는 "스티커"와 같으며, 서버는 사용자가 방문할 때마다 이 스티커를 읽을 수 있음

**쿠키의 동작 과정**:

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/54195825-8bab-49b2-bd08-323328f37ee5" />

1. **첫 방문**: 사용자가 웹사이트에 처음 방문하면 서버는 사용자를 식별할 수 없음
2. **쿠키 할당**: 웹 서버는 사용자를 식별하기 위한 유일한 값을 쿠키에 할당하고, 이를 `Set-Cookie` 또는 `Set-Cookie2` 헤더를 통해 사용자에게 전달함
3. **쿠키 저장**: 브라우저는 받은 쿠키를 쿠키 데이터베이스에 저장함
4. **이후 방문**: 사용자가 같은 사이트를 재방문하면, 브라우저는 해당 쿠키를 `Cookie` 요청 헤더에 담아 서버로 전송함

**쿠키의 내용**:

- 쿠키는 식별 번호만 포함할 수도 있고, 다양한 정보를 포함할 수도 있음
- 예시: `Cookie: name="Brian Totty"; phone="555-1212"`
- 서버는 이 쿠키 값을 사용하여 데이터베이스에서 사용자의 정보를 찾을 수 있음

## 11.6.3 쿠키 상자: 클라이언트 측 상태

**기본 개념**:

- 쿠키는 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하는 방식
- 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이를 **클라이언트 측 상태** 또는 공식적으로 **HTTP 상태 관리 체계(HTTP State Management Mechanism)**라고 함

### 쿠키 저장 방식

**구글 크롬 쿠키**

<img width="530" alt="Image" src="https://github.com/user-attachments/assets/91a64108-c636-4ecc-9a1d-c767cff02c10" />

- 크롬은 쿠키 정보를 **SQLite** 파일에 저장함
- 주요 필드:
  - `creation_utc`: 쿠키 생성 시간 (1970년 1월 1일 이후 초 단위)
  - `host_key`: 쿠키의 도메인
  - `name`: 쿠키 이름
  - `value`: 쿠키 값
  - `path`: 쿠키 관련 도메인 경로
  - `expire_utc`: 쿠키 파기 시점 (1970년 1월 1일 이후 초 단위)
  - `secure`: SSL 연결에서만 쿠키를 전송할지 여부

**마이크로소프트 인터넷 익스플로러**

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/a56f3461-575e-4ea6-a12b-5234ac7e7164" />

- 인터넷 익스플로러는 **캐시 디렉터리**에 개별 쿠키 파일로 저장함
- 쿠키 파일에서 첫 번째 줄은 쿠키 이름, 두 번째 줄은 쿠키 값, 세 번째 줄은 도메인 및 경로 정보 등을 나타냄
- 추가적인 정보(예: 날짜나 표식 등)는 다른 줄에 기록됨

## 11.6.4 사이트마다 각기 다른 쿠키들

**브라우저의 쿠키 전송 방식**:

- 브라우저는 수백 또는 수천 개의 쿠키를 가질 수 있지만, 모든 쿠키를 모든 사이트에 보내지 않음
- 이유:
  - **성능 저하**: 모든 쿠키를 전송하면, 실제 콘텐츠보다 더 많은 쿠키 데이터를 전송하게 되어 성능이 저하됨
  - **무의미한 값**: 대부분의 쿠키는 특정 서버에 특화된 이름/값 쌍을 포함하고 있어 다른 사이트에서는 무의미함
  - **개인정보 문제**: 신뢰하지 않는 사이트에서 가져갈 수 있어서 개인정보 유출 위험이 커짐

**쿠키 전송 규칙**:

- 브라우저는 쿠키를 생성한 서버에만 해당 쿠키 정보를 전송함
- 예를 들어, `joes-hardware.com`에서 생성된 쿠키는 `joes-hardware.com`에만 전송되고, 다른 사이트에는 전송되지 않음

**광고사와 쿠키 사용**:

- 많은 웹사이트는 광고사와 계약함. 광고들은 웹 사이트 자체의 일부인 것처럼 제작되고, 지속 쿠키를 만들어냄
- 같은 광고사에서 제공하는 서로 다른 웹 사이트에 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 광솨 서버로 전송함
- 광고사는 여기에 Referer 헤더를 접목하여 사용자의 프로필과 웹 사이트를 사용하는 습관에 대한 데이터 구축 가능
- 최신 브라우저들은 개인정보 설정 기능을 통해 광고사의 쿠키 사용 방식에 제약을 둘 수 있음

**쿠키의 Domain 속성**:

- **Domain 속성**: 서버가 쿠키를 생성할 때, 어떤 도메인에서 해당 쿠키를 읽을 수 있는지 지정 가능
- 예:

  ```
  Set-cookie: user="maryl7"; domain="airtravelbargains.com"
  ```

  - 이 쿠키는 `airtravelbargains.com` 도메인 하위의 모든 사이트에서 유효

**쿠키의 Path 속성**:

- **Path 속성**: 쿠키가 웹 사이트의 특정 URL 경로에만 적용되도록 제한할 수 있음
- 예:
  ```
  Set-cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/
  ```
  - 사용자가 `http://www.airtravelbargains.com/autos/`에 접근할 때만 `pref=compact` 쿠키가 전송됨
  - 다른 경로에서는 해당 쿠키는 전달되지 않음

**쿠키의 관리**:

- 쿠키는 서버가 생성하고 클라이언트(브라우저)가 관리함
- 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관리함

## 11.6.5 쿠키 구성요소

**쿠키 버전**:

- **Version 0 쿠키**: 흔히 '넷스케이프 쿠키'라고 불림.
- **Version 1 쿠키**: 'RFC 2965'로 정의되며, Version 0 쿠키의 확장. 그러나 널리 사용되지 않음.
- 쿠키 명세는 HTTP/1.1 명세에 포함되지 않음.

| 제목                                      | 설명                                               | 위치                                                                                                             |
| ----------------------------------------- | -------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |
| Persistent Client State: HTTP Cookies     | 넷스케이프 쿠키 표준 원문                          | [http://home.netscape.com/news-ref/std/cookie_spec.html](http://home.netscape.com/news-ref/std/cookie_spec.html) |
| RFC 2965: HTTP State Management Mechanism | 2000년 10월에 작성된 쿠키 표준으로 RFC 2109를 대체 | [http://www.ietf.org/rfc/rfc2965.txt](http://www.ietf.org/rfc/rfc2965.txt)                                       |

> 지금은 어떨까?

## 11.6.6 Version 0(넷스케이프) 쿠키

- 최초의 쿠키 명세는 넷스케이프에서 정의함
- `Set-Cookie`와 `Cookie` 요청 헤더를 사용하여 쿠키를 설정하고 전송
- Version 0 쿠키는 다음과 같은 형식을 사용:
  - `Set-Cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]`
  - `Cookie: name1=value1 [; name2=value2] ...`

**Version 0 Set-Cookie 헤더 속성 설명**

| Set-Cookie 속성 | 설명과 용례                                                                         | 예시                                                       |
| --------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| 이름=값         | 필수 속성. 쿠키 이름과 값을 설정합니다. 세미콜론, 쉼표, 등호, 공백을 포함하지 않음. | `Set-Cookie: customer=Mary`                                |
| Expires         | 선택적인 속성. 쿠키의 생명주기를 설정하며, 만료일에 도달하면 쿠키는 삭제됩니다.     | `Set-Cookie: foo=bar; expires=Wed, 09-Nov-99 23:12:40 GMT` |
| Domain          | 선택적인 속성. 특정 도메인에서만 쿠키를 전달하도록 제한.                            | `Set-Cookie: SHIPPING=FEDEX; domain=joes-hardware.com`     |
| Path            | 선택적인 속성. 특정 URL 경로에만 쿠키를 전달하도록 설정.                            | `Set-Cookie: lastorder=00183; path=/orders`                |
| Secure          | 선택적인 속성. 쿠키는 SSL 보안 연결을 사용할 때만 전송됩니다.                       | `Set-Cookie: private_id=519; secure`                       |

**Version 0 Cookie 헤더**

- 클라이언트가 서버에 요청할 때, `Domain`, `Path`, `Secure` 조건에 맞고 파기되지 않은 쿠키를 `Cookie` 헤더에 포함하여 전송함
- 모든 쿠키는 Cookie 헤더에 이어 붙여 보냄
  ```
  Cookie: session-id=002-1145265-8016838; session-id-time=1007884800
  ```

## 11.6.7 Version 1 (RFC 2965) 쿠키

- RFC 2965는 RFC 2109의 확장된 버전이며, `Set-Cookie2` 및 `Cookie2` 헤더를 소개함.
- Version 0 (넷스케이프 쿠키)와 호환됨.

**주요 변경 사항**

- 쿠키마다 설명문 추가 가능
- 브라우저 종료 시 쿠키 강제 삭제 가능
- `Max-Age` 속성을 통해 절대 날짜가 아닌 상대 시간(초 단위) 지정 가능
- 포트 번호까지 쿠키 제어 가능
- 도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보냄
- 쿠키의 버전 번호를 명시적으로 지원
- `Cookie` 헤더에서 사용자 이름과 키워드를 구별하기 위해 `$` 접두어 사용

> `도메인, 포트, 경로 필터가 있으면 Cookie 헤더에 담겨 되돌려 보낸다.` 가 무슨 소리지?

- Version 1 쿠키의 문법은 아래와 같음

```
set-cookie "Set-Cookie2:" cookies
cookies l#cookie
cookie NAME "=" VALUE set-cookie-av)
NAME attr
VALUE value
set-cookie-av "Comment" "=" value
"CommentURL" "=" <"> http_URL <">
"Discard"
"Domain" "=" value
"Max-Age” "=" value
"Path" "=" value
"Port" [ "=" <"> portlist <”> ]
"Secure"
"Version" "=" 1*DIGIT
portlist = l#portnum
portnum = 1*DIGIT
cookie "Cookie:" cookie-version 1*((";" | cookie-value)
cookie-value NAME "=" VALUE path] domain] port]
cookie-version "$Version" "=" value
NAME attr
VALUE value
path "$Path" "=M value
domain "$Domain" ”=" value
port "$Port" [ "=" <"> value <"> ]
cookie? = "Cookie2:" cookie-version
```

**Version 1 Set-Cookie2 헤더**

- Version 1 쿠키 표준에는 넷스케이프 표준보다 많은 속성이 있음
- 아래 표는 이 속성에 대한 개요임. 더 자세한 내용은 RFC 2965 참고

| 속성         | 필수 여부 | 설명                                                                     |
| ------------ | --------- | ------------------------------------------------------------------------ |
| `이름=값`    | 필수      | 서버가 저장하는 `이름=값` 쌍. 쿠키 이름은 `$`(예약어) 로 시작할 수 없음. |
| `Version`    | 필수      | 쿠키 명세의 버전을 나타내는 정수 값. RFC 2965에서는 `1`.                 |
| `Comment`    | 선택      | 쿠키 사용 목적을 설명하는 UTF-8 인코딩된 문자열.                         |
| `CommentURL` | 선택      | 쿠키 정책과 목적을 설명하는 웹페이지 URL.                                |
| `Discard`    | 선택      | 클라이언트 종료 시 쿠키를 삭제하도록 지정.                               |
| `Domain`     | 선택      | 쿠키가 전송될 도메인을 지정. 서브도메인에도 적용 가능.                   |
| `Max-Age`    | 선택      | 쿠키의 수명을 초 단위로 지정. `0`이면 즉시 삭제됨.                       |
| `Path`       | 선택      | 쿠키가 적용될 URL 경로를 지정. 기본적으로 요청 URL의 경로가 설정됨.      |
| `Port`       | 선택      | 특정 포트에서만 쿠키가 전송되도록 제한. 여러 포트를 지정할 수도 있음.    |
| `Secure`     | 선택      | HTTPS(SSL 보안 연결)에서만 쿠키를 전송하도록 제한.                       |

**Version 1 Cookie 헤더**

- Set-Cookie2 필터 중에서, 현재의 웹 사이트에 들어맞는 필터 정보에 달러 문자〈$）를 붙여서 쿠키와 함께 전송
- 예시

  - 서버 응답 (`Set-Cookie2`)

    ```http
    Set-Cookie2: ID="29046"; Domain=".joes-hardware.com"
    Set-Cookie2: color=blue
    Set-Cookie2: Coupon="hammer027"; Version="1"; Path="/tools"
    Set-Cookie2: Coupon="handvac103"; Version="1"; Path="/tools/cordless"
    ```

  - 클라이언트 요청 (/tools/cordless/specials.html)하면 아래와같은 Cookie2 헤더 전송

    ```
    Cookie: $Version="l";
    ID=n29046"; $Domain=".joes-hardware.com";
    color：="blue";
    Coupon-’hammer027"; $Path=’7tools";
    Coupon="handwcl03"; $Path="/tools/cordless"
    ```

**Version 1 Cookie2 헤더와 버전 협상**

- **Cookie2 헤더 역할**: 클라이언트와 서버 간 쿠키 버전 호환성을 협상.
- **클라이언트 지원 버전 전달**: `Cookie2: $Version="1"` 를 통해 서버에 새로운 쿠키 형식 지원 여부 알림.
- **서버 응답**:
  - `Cookie2` 헤더를 받으면 Set-Cookie가 아닌 `Set-Cookie2` 응답 헤더를 보내야함
  - 클라이언트가 Set-Cookie와 Set-Cookie2 모두 보내면 `Set-Cookie`는 무시.
- **클라이언트의 Version 0 쿠키 처리**:
  - 클라이언트는 Version 0과 Version 1 쿠키 모두 지원해도 `Set-Cookie`를 받으면 Version 0 형식의 `Cookie`를 전송해야함.
  - 하지만 `Cookie2: $Version="1"`을 함께 보내 업그레이드 가능성 전달.

## 11.6..8 쿠키와 세션 추적

- **쿠키 사용 목적**: 사용자를 추적/식별하고 세션을 유지 (예: 온라인 쇼핑 카트).

- **Amazon.com의 세션 관리 흐름**:

<img width="415" alt="Image" src="https://github.com/user-attachments/assets/f27df0b8-7d3c-44f4-82ee-8aecbf4ecfae" />

1. **초기 요청**: 브라우저가 `amazon.com` 요청 (그림 11-5a).
2. **첫 번째 리다이렉트**: 서버가 전자상거래 소프트웨어 URI로 리다이렉트 (그림 11-5b).
3. **리다이렉트 URL 요청**: 클라이언트가 새 URL로 요청 (그림 11-5c).
4. **세션 쿠키 설정**:
   - 서버가 응답에 **두 개의 세션 쿠키**를 설정하고 다시 리다이렉트 (그림 11-5d).
   - 쿠키 비활성화 시, URL 자체에 세션 정보 포함 (뚱뚱한 URL).
5. **쿠키 포함 요청**: 클라이언트가 **세션 쿠키 포함하여 요청** (그림 11-5e).
6. **추가 쿠키 설정**: 서버가 `home.html`로 리다이렉트하면서 **추가 쿠키 두 개** 설정 (그림 11-5f).
7. **최종 요청**: 클라이언트가 `home.html` 요청 시 총 **네 개의 쿠키** 전달 (그림 11-5g).
8. **콘텐츠 제공**: 서버가 `home.html` 응답 (그림 11-5h).

## 11.6.9 쿠키와 캐싱

**쿠키와 캐싱 시 주의점**

쿠키가 포함된 문서를 캐싱할 경우, 보안 및 개인정보 유출 위험이 있음.

### 캐시되지 말아야 할 문서는 명확히 표시

- **쿠키 캐싱 방지**: `Cache-Control: no-cache="Set-Cookie"`
- 캐시를 해도 되는 문서에 `Cache-Control: public` 사용하면 대역폭 절약

### Set-Cookie 헤더 캐싱 주의

**Set-Cookie가 포함된 응답**:

- 본문은 캐시 가능하지만, Set-Cookie 헤더는 신중하게 다뤄야 함.
- 같은 쿠키가 여러 사용자에게 전달되면 사용자 추적 실패 가능성, 보안 위험

**캐시 서버에서 Set-Cookie 제거 문제**:

- 캐시 서버가 Set-Cookie를 제거하면 클라이언트가 필요한 쿠키 없이 데이터 수신.
- 해결책:
  모든 요청 시 원 서버와 재검사하여 클라이언트로 가는 응답에 Set-Cookie 헤더 값을 기술하면 개선 가능

  - 원 서버는 아래와 같은 헤더를 캐시된 문서에 추가함으로써 재검사가 일어나게 할 수 있음

  ```http
  Cache-Control: must-revalidate, max-age=0
  ```

**보수적 캐싱 정책**:

- Set-Cookie 포함된 응답은 캐싱 안 할 수도 있음.
- 일부 캐시는 **이미지는 캐시**하지만 **텍스트 응답은 캐시 안 함**.

### Cookie 헤더가 포함된 요청은 주의

- **개인정보 포함 가능성** → 캐싱 금지 필요.
- 일부 서버는 명확히 캐싱 금지를 표시하지 않음.

- **보수적 캐싱 정책**:
  - **Cookie 헤더 포함된 요청** → 응답을 캐싱하지 않음.
  - **이미지는 캐시, 텍스트는 비캐시**하는 캐시도 존재.
  - **파기 시간 0인 쿠키 설정** → 효율적인 방식, 매번 재검사 강제.

## 11.6.10 쿠키, 보안, 그리고 개인정보

**쿠키 자체의 보안 위험성은 크지 않음**

- 쿠키는 비활성화할 수 있으며, 로그 분석 등으로 대체 가능함.
- 원격 데이터베이스에 개인정보를 저장하고, 키 값을 쿠키에 저장하는 방식이 보안적으로 유리함.

**쿠키의 개인정보 추적 위험**

- 협력업체 웹사이트가 지속 쿠키를 사용하여 사용자를 추적할 수 있음.
- IP 주소, Referer 헤더 등의 정보를 조합하면 마케팅 회사가 사용자 프로필 및 사용 패턴을 수집 가능

**쿠키의 편리함과 정책 준수**

- 개인정보 제공 대상을 명확히 알고, 사이트의 개인정보 정책을 확인하면 쿠키의 위험성을 줄일 수 있음.
- 개인정보 정책에만 유의한다면, 쿠키를 활용한 세션 관리 및 트랜잭션의 편리함이 위험성보다 큼

**CIAC(미 재무성 컴퓨터사고 자문단) 보고서 (1998)**

- 쿠키의 보안 위험성이 과대평가되었다는 평가를 발표함.

```
CIAC 1-034: 인터넷쿠키
（http://attrition.o rg/secu rity/adviso ry/ciac/i-fy98/ciac.i-034.internet.cookies）
문제:

쿠키는 웹 서버가 웹 사용자를 식별하려고 사용하는 작은 데이터 조각이다. 쿠키의 개념과 기능에 대해 이해할 수 없는 수준까지
올라온 수많은 뜬소문들은 사용자를 놀라게 하고 그들의 관리자까지도 걱정을 끼칠 수준이다.

취약성 평가:

웹브라우저 쿠키를 사용하여 시스템의 취약한 부분이 손상되거나 스누핑을 하는 것은 근본적으로 있을 수 없다. 쿠키는 이전에
당신이 웹 서버에 방문한 적이 있는지 말해주거나, 웹 서버로부터 전달받은 약간의 정보（사용자 번호와 같은）를 다음에 다시 접속
하였을 때 서버에게 다시 보내주는 용도일 뿐이다. 쿠키 대부분은 당신이 브라우저를 나가기 전까지만 유지되며 브라우저를 나가
면 삭제된다. 쿠키의 형식 중 하나인 지속 쿠키는 파기 시간을 가지고 있으며 그 파기 시간까지만 당신의 디스크에 저장된다. 지
속 쿠키는 사용자가 언제 사이트로 돌아오는지 식별해서 사용자의 탐색 습관을 추적하는데 사용될 수 있다. 당신이 어디서 왔는
지, 당신이 어떤 페이지에 접근했는지는 웹 서버의 로그 파일에도 존재하며, 그것을 통해서 사용자의 브라우징 습관을 추적할 수
도 있다. 쿠키는 그것을 좀 더 편리하게 해줄 뿐이다.
```
