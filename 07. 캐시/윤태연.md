# 캐시

> [!NOTE]
> 자주 쓰이는 **문서의 사본을 자동으로 보관**하는 HTTP 장치 <br />
> 클라이언트가 요청한 리소스가 캐시에 있다면 서버가 아닌 캐시에서 직접 반환하는 원리

## 캐시의 이점

### **불필요 데이터 전송 감소**

- 똑같은 바이트들을 계속 반복적으로 받으면 그만큼 대역폭을 잡아먹음
- 동일 리소스 반복 전송 방지를 통한 효율성 확보

네트워크 비용 절감을 달성 할 수 있음!

### **네트워크 병목 현상 해결**

광역 통신망 네트워크 속도는 경로상 가장 느린 구간의 속도와 같음, 문서 크기가 클수록 네트워크 대역폭의 영향이 커짐.

<img width="525" alt="image" src="https://github.com/user-attachments/assets/9f5e7e28-d4e2-48f3-a94c-7ca6e57076a5" />

- 클라이언트와 가까운 곳에서 **hit가 돼 빠른 응답**이 가능
- 대역폭이 작은 병목 구간을 통과하지 않아도 됨
- **로컬 캐시 사용 시 30초 걸리던 5MB 파일을 1초 미만**으로 전송 가능

#### 네트워크 종류별 전송 시간 특징

1. **전화식 모뎀 (56Kbps)**
   - 가장 느린 전송 속도
   - 5MB 파일 전송에 약 12분(749초) 소요
   - 작은 HTML 파일(15KB)도 2.19초 소요
2. **DSL (256Kbps)**
   - 모뎀보다 약 4-5배 빠른 속도
   - 5MB 파일 전송에 약 3분(164초) 소요
   - 일반적인 JPEG(40KB) 전송에 1.28초 소요
3. **T1 (1.4Mbps)**
   - DSL보다 약 5배 빠른 속도
   - 5MB 파일 전송에 29초 소요
   - 큰 JPEG(150KB) 전송에도 1초 미만(0.85초) 소요
4. **이더넷 (10Mbps - 100Mbps)**
   - 가장 빠른 전송 속도
   - 느린 이더넷(10Mbps)도 5MB 파일 전송에 4.19초만 소요
   - 빠른 이더넷(100Mbps)은 모든 파일 전송이 1초 미만

특히 큰 파일일수록 캐시를 통한 성능 개선 효과가 극대화됨.

### **갑작스러운 요청 쇄도(Flash Crowds) 처리**

- 인기 있는 이벤트로 인한 트래픽 급증 상황 발생 시 심각한 장애 야기
- **캐싱 사용 시 트래픽 급증 상황에서도 안정적 서비스 제공** 가능

서버 부하 감소와 네트워크 혼잡 방지를 할 수 있음.

### **거리로 인한 지연 감소**

대역폭도 문제지만, **물리적 거리**가 문제일 수 있다. 네트워크를 전달하는 속도인 빛의 속도(300,000km/s)여도!

<img width="507" alt="image" src="https://github.com/user-attachments/assets/b88c7c7b-4cce-4aaa-96e9-b092f0875eaf" />

- 물리적 거리와 네트워크 라우터 각각의 지연시간과 합쳐져 **실제 전송 시간에 큰 영향** 미침
- **클라이언트와 가까운 곳에서 캐시된 데이터 제공**
- 라우터 홉수와 물리적 거리 감소를 통한 응답 시간 단축이 가능 => 수천 킬로미터 거리를 수십 미터로 단축

#### 참고: 예시 - 거리별 지연 시간

1. **보스턴-샌프란시스코 구간 (4,400km)**
   - 편도 15밀리초, 왕복 30밀리초의 기본 지연이 특징
   - 20개 이미지, 4개 동시 커넥션 시 240밀리초(1/4초) 지연이 핵심
   - 실제 라우터 지연까지 더해지면 더 긴 지연 발생이 특징
2. **보스턴-도쿄 구간 (10,800km)**
   - 거리가 2.45배 증가해 지연시간도 비례 증가가 특징
   - 같은 조건에서 600밀리초 지연이 발생하는 것이 핵심
   - 복잡한 웹페이지의 경우 수 초 단위 지연이 가능

보통 기계실 근처 캐시 설치로 지연 최소화가 가능함.

## 캐시 처리 단계/종류

<img width="493" alt="image" src="https://github.com/user-attachments/assets/7d78534f-5bce-4270-9c22-be0db211a6d1" />

### 캐시 적중 & 부적중

> [!NOTE]
>
> - 캐시 적중(Cache Hit): 요청한 데이터가 캐시에 존재해 바로 반환
> - 캐시 부적중(Cache Miss): 요청한 데이터가 캐시에 없어 서버에서 가져와야 하는 상황

### 재검사

캐싱은 항상 서버와의 데이터 무결성을 지켜야한다.

#### **재검사 조건**

- 원 서버의 콘텐츠 변경 가능성에 대한 대비 => 캐시된 데이터의 신선도 확인이 필요한 시점을 상시 점검해야함
- 캐시된 사본의 신선도 확인을 위한 주기적 검사 필요
  - 클라이언트 요청이 있거나,
  - 충분히 오래된 경우 수행

#### **재검사 방식**

<img width="508" alt="image" src="https://github.com/user-attachments/assets/17165863-59ce-4183-a906-950b40400cff" />

- `If-Modified-Since` 헤더를 이용한 조건부 요청으로 할 수 있음
  - 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
- 변경되지 않은 경우 `304 Not Modified` 응답으로 효율성 확보가 특징
- 변경된 경우 `200 OK`와 함께 새로운 컨텐츠 전송, 캐싱

### 적중률 분석

> [!NOTE]
> 캐시가 요청을 처리하는 비율

1. **문서 적중률(캐시 적중비)**
   - 캐시가 요청을 처리하는 비율을 0-100%로 표현
   - 보통 40% 정도면 괜찮은 성능으로 평가되는 것이 특징
   - 캐시 크기, 사용자 패턴, 데이터 변경 주기 등에 영향을 받음
2. **바이트 적중률**
   - 캐시를 통해 제공된 바이트 단위로의 비율 측정
   - 실제 트래픽 감소량을 정확히 파악 가능한 것이 특징
   - 대역폭 비용 측정에 더 유용한 지표로 활용 (트래픽의 모든 바이트에 요금 책정 등)

### 적중 여부 판단

- HTTP 자체로는 캐시 적중/비적중 여부 구분 불가능.. => 캐싱이 되고 있는지는 모른다는 것임!
- 데이터 생성일 & `Date` 헤더 비교하거나 응답 생성 시간인 `Age` 헤더를 통한 간접적 판단을 해야함
- `Via` 헤더에 추가 정보를 포함하는 프락시 캐시도 존재

## 캐시 토폴로지(Cache Topology)

캐시는 한 명의 사용자에게만 할당될 수도 있고 반대로 수천 명의 사용자들 간에 공유될 수도 있다.

\+ Topology 뜻은 어떠한 체계적인 분류 또는 위상 배치를 뜻함. 3D에서는 폴리곤의 기하학적 표면 배치 특성, 네트워크는 그를 구성하는 요소(링크, 노드)들의 배치 형태나 망 구성 방식을 뜻함.

### 캐시 유형

<img width="483" alt="image" src="https://github.com/user-attachments/assets/68a922fa-7ef0-41df-97b5-6e9de5ac5fbb" />

사용 범위에 따라 개인 전용 캐시와 공용 캐시로 구분된다.

#### 개인 전용 캐시

- 브라우저에 내장된 개인용 캐시
- 디스크와 메모리에 자주 사용하는 문서 저장
- 크롬의 `about:cache`나 익스플로러의 임시 파일로 확인 가능

#### 공용 프락시 캐시

- 여러 사용자가 공유하는 프락시 서버 형태
- 동일 문서에 대한 중복 다운로드 방지
- 트래픽 감소 효과가 큰 것이 특징

\+ 6장의 “클라이언트 프락시 설정: 수동”을 보면, 동 프락시를 지정하거나 프락시 자동설정 파일을 설정함으로써 브라우저가 프락시 캐시를 사용하도록 설정할 수 있음.

### 캐시 계층 구조

#### **프락시 캐시 계층**

<img width="488" alt="image" src="https://github.com/user-attachments/assets/52baa26f-e5da-4b38-a80e-837d173dee36" />

- 작은 캐시의 부적중을 큰 부모 캐시가 처리하는 구조
- 클라이언트 주변은 작은 캐시, 상위는 큰 캐시 배치
- 계층이 깊어질수록 성능 저하 우려

\+ 참고: 프락시 캐시를 사용하는 과정

1. 사용자가 웹페이지 요청
2. 먼저 가까운 작은 캐시 확인
3. 없으면 큰 캐시 확인
4. 거기도 없으면 원본 서버로 요청

#### **캐시망 구조**

<img width="489" alt="image" src="https://github.com/user-attachments/assets/494c4f50-55f6-4864-944d-7fc463315771" />

캐시 커뮤니케이션 결정을 동적으로 내릴 수 있는 캐시망을 만들어

- URL 기반의 동적 캐시 선택이 가능한 것
- 캐시 간 콘텐츠 공유와 접근 제어
- ICP, HTCP 등 추가 프로토콜로 기능 확장이 필요

한마디로, URL로 원 서버 - 특정 부모 캐시 동적 선택하거나 로컬 탐색 등을 할 수 있게 된다.

## 캐시 처리 단계

상용 프락시 캐시는 꽤 복잡. 고성능, HTTP 외 다른 고급 기능을 사용하기 때문. 그래서 웹 통신 캐싱을 살펴보자.

### 기본 처리 단계

HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계.

<img width="680" alt="image" src="https://github.com/user-attachments/assets/57acb44d-8480-4395-b144-61dac3e08a81" />

#### 1. 요청 받기

- 네트워크 커넥션에서 들어오는 데이터를 감지하고 읽어들임
- 고성능 캐시는 여러 커넥션의 동시 데이터 수신과 처리가 가능함

#### 2. 파싱

- 요청 메시지를 분해해 헤더를 자료 구조화함
- 대소문자, 날짜 형식 등의 정규화 처리를 수행함

#### 3. 검색

- URL에 해당하는 로컬 사본 존재 여부 확인
  - 메모리, 디스크, 근처 PC 등의 유무를 확인
- 캐시된 객체는 서버 응답 본문, 헤더, 메타데이터 포함
- 로컬에서 가져올 수 없는 경우 원 서버나 부모 프락시에서 가져오거나 실패 반환

#### 4. 신선도 검사

- 캐시된 사본의 신선도를 검사함
- 신선하지 않은 경우 서버와 재검사를 수행함
- HTTP의 신선도 검사 규칙은 많은 설정 옵션으로 인해 복잡함
  - 캐시 제품들이 지원하는 많은 수의 설정 옵션과 비 HTTP 신선도 표준과의 상호작용 등

#### 5. 응답 생성

- 캐시된 서버 응답 헤더를 기반으로 새로운 응답 헤더를 생성함
- 캐시 신선도 정보(`Cache-Control`, `Age`, `Expires`) 및 `Via` 헤더를 추가함
  - 최근엔 `ETag`도 많이 사용하는데 얘는?
- Date 헤더는 원 서버에서 최초 생성된 일시를 표현하므로 수정하지 않음

#### 6. 전송

- 준비된 응답을 클라이언트에게 전송
- 고성능 캐시는 복사 작업 최소화를 통해 효율적 전송 수행

#### 7. 로깅

- 트랜잭션 완료 후 통계를 갱신하고 로그 파일 기록
- 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷 등 다양한 로그 포맷을 지원함, 커스텀도 가능
- 요청 종류, URL 등 트랜잭션 상세 내용 기록

![image](https://github.com/user-attachments/assets/fbf98f63-436b-42e5-affe-786303437ac4)

\+ 이미지는 위 7단계를 도식화한 플로차트를 통해 GET 요청의 처리 흐름을 보여줌

## 캐시 신선도 유지

캐시 처리 단계에서 신선도 유지 계산과 갱신에 많은 계산이 들어간다고 했다.

> [!NOTE]
> 캐시된 사본이 원 서버의 문서와 일치하도록 관리하는 HTTP 메커니즘. 문서 만료와 서버 재검사를 통해 신선도 보장

### 문서 만료 시 유효기간 관리

<img width="568" alt="image" src="https://github.com/user-attachments/assets/a4c851c4-2951-426f-b84f-e3296729932c" />

- `Cache-Control`과 `Expires` 헤더로 문서의 유효기간 명시
- `Cache-Control: max-age`는 문서 최대 나이를 초 단위로 정의
  - `Cache-Control: max-age=484200` : 시간에서 484200초가 지나면 만료
- `Expires`는 절대 유효기간을 날짜로 명시
- 만료 전까지는 서버 접촉 없이 캐시에서 직접 제공 가능

### 서버 재검사 절차/메서드

- 캐시된 문서가 만료되면 원 서버와 변경 여부 검사, 꼭 변경이 일어나진 않았기에!
- 변경된 경우 새로운 사본을 가져와 저장
- 변경되지 않은 경우 새 만료일을 포함한 헤더만 갱신
- 캐시는 만료 전까지 매 요청마다 검증할 필요가 없음

즉, 재검사 이후 '충분히 신선한', 재검사 후 신선한, 에러, 경고(부정확) 이런 상태로 들어올 것임.

### 조건부 메서드를 통한 재검사

헤더 중 최근 변경 일시(`If-Modified-Since`), 엔터티 태그(`If-None-Match`)로 나뉨.

#### **If-Modified-Since (IMS)**

가장 흔히 쓰임, `If-Modified-Since: ＜캐시된마지막수정일＞`로 쓰임

- 특정 날짜 이후 변경 여부 확인
- If-Modified-Since 헤더에 `Last-Modified` 헤더를 포함시켜 함께 동작
- 검사 실행 시 응답 처리 방식
  - 변경 없으면 `304 Not Modified` 응답 수신 => 변경 없을 시 본문 전송하지 않아 효율적임
  - 변경 있으면 `200 OK`와 함께 새 문서 수신
- 캐싱 검사 실행 안해도 되는 것들에 대해 한계가 있음
  - 백그라운드 프로세스로 재작성되는 문서
  - 내용 동일해도 타임스탬프가 변경되는 경우
  - 사소한 변경(철자, 주석 등)
  - 1초 미만 단위의 갱신이 필요한 경우

#### **If-None-Match**

IMS 방식의 한계를 이기기 위해 나옴

```
If-None-Match: "v2.6"
If-None-Match: "v2•4","v2.5","v2.6"
If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
```

- 엔터티 태그(`ETag`)를 통한 문서 버전 확인(`If-None-Match`에 포함), 서버는 현재 태그와 비교해 일치 여부 확인
- 콘텐츠 변경을 정확하게 판단할 수 있음
- 여러 개의 태그를 한번에 비교할 수 있음 : `If-None-Match: "v2.4","v2.5","v2.6"` => 캐시가 여러 버전을 보유한 경우 유용함
- 검사 실행 시 응답 처리 방식
  - 태그 일치: `304 Not Modified` 반환
  - 태그 불일치: `200 OK` + 새 콘텐츠와 새 `ETag` 제공
- 날짜 기반 비교의 한계 보완

### HTTP 캐시 검사기

캐시된 리소스의 신선도를 검증하는 두 가지 방식(엔터티 태그와 최근 변경일시)과 그 특성을 설명하겠움.

검사기 유형엔 '강한 검사기', '약한 검사기' 2가지가 있음.

#### 강한 검사기

- 콘텐츠가 조금이라도 변경되면 반드시 함께 변경됨
- 정확한 일치가 필요한 경우에 사용

#### 약한 검사기

- `W/` 접두어로 표시함 (예: `ETag: W/"v2.6"`)
- 콘텐츠의 중요한 의미 변경 시에만 변경됨
- 사소한 변경은 무시할 수 있음
- 특정 범위 요청 등에는 사용할 수 없음

#### 엔터티 태그 사용 규칙

- HTTP/1.1 서버는 가능한 한 엔터티 태그를 제공해야 함!
- 태그 값은 서로 다른 엔터티에 재사용해서는 안 됨
- 약한 태그도 의미가 다른 엔터티에는 재사용 불가함

#### 검사기 선택 기준

1. 서버가 엔터티 태그 제공 시
   - 반드시 엔터티 태그 검사기 사용
2. `Last-Modified` 값만 제공 시
   - `If-Modified-Since` 검사 사용
3. 둘 다 사용 가능한 경우
   - HTTP/1.0, 1.1 호환성을 위해 모두 사용
   - 모든 조건이 만족되어야 `304 Not Modified` 반환

\+ 서버는 강한 태그 대신 약한 태그를 사용할 수 있으며, Last-Modified 값도 함께 제공하는 것이 권장됨. 상황에 따라 강한/약한 검사기를 적절히 선택해 캐시 효율성을 최적화해야 함.

## 캐시 제어

> [!NOTE]
> HTTP가 문서의 만료 시점까지 캐시를 유지할 수 있도록 서버가 설정하는 다양한 방법을 정의한 시스템

### 캐시 제어 헤더 우선순위

1. `Cache-Control: no-store` : 캐시 저장 금지
2. `Cache-Control: no-cache` : 재검사 없이 캐시 제공 금지
3. `Cache-Control: must-revalidate` : 만료된 캐시 제공 금지
4. `Cache-Control: max-age` : 캐시 유효 시간 지정
5. `Expires` : 캐시 만료 날짜 지정 + 이제 거의 안씀(deprecated)
6. 휴리스틱 방법 : 캐시가 자체적으로 결정

### 주요 헤더별 특징

#### no-cache / no-store

- `no-store` : 캐시의 사본 생성 자체 금지
- `no-cache` : 로컬 저장은 허용하나 재검사 없이 캐시 제공 불가

\+ `Pragma： no-cache`는 HTTP/1.0+ 하위 버전 호환성을 위해 존재함

#### Max-Age / Expires

- `max-age` : 문서가 서버로부터 온 후 신선하다고 간주되는 시간을 초 단위로 표시
  - `Cache-Control: max—age=3600` : 응답 이후 3600초
- `Expires` : 실제 만료 날짜를 명시 => 서버 시간 불일치 문제로 `max-age` 사용 권장
  - `Expires: Fri, 05 Jul 2002, 05:00:00 GMT`

#### Must-Revalidate

- 캐시가 만료된 객체 제공 시 반드시 서버와 재검사 요구
- 서버 접근 불가 시 `504 Gateway Timeout` 오류 반환 필수

### 휴리스틱 만료

> [!NOTE]
> 명시적인 만료 정보가 없을 때 캐시가 경험적(heuristic) 방법으로 최대 나이를 계산하는 방식

#### LM 인자 알고리즘

<img width="441" alt="image" src="https://github.com/user-attachments/assets/bc766cd9-fd08-4157-a125-a9b92da58aec" />

- 문서의 최근 변경 일시 기반으로 신선도 추정
  - `$마지막_수정_이후로_경과한_시간= max(0, $서버의_Date -$서버의_Last_Modified);`
  - `$서버_신선도_한계= int ($마지막_수정_이후로_경과한_시간* $1m_인자) ;`
- 변경이 오래된 문서는 안정적으로 판단해 더 긴 보관 허용
- 최근 변경된 문서는 짧다고 생각하는 캐시 기간 적용
  - 캐시는 판단 근거가 될 정보가 없기 때문
  - 보통 하루 or 한시간이며, 더 보수적인 캐시는 아예 0으로 설정

### 클라이언트 신선도 제약

브라우저의 리프레시/리로드 기능을 통한 캐시 제어가 가능해짐.

#### 주요 `Cache-Control` 요청 지시어

<img width="981" alt="image" src="https://github.com/user-attachments/assets/6c9589c4-4ae6-4023-8520-66345a9ee6df" />

- `max-stale` : 만료된 문서도 허용
- `min-fresh` : 지정 시간 이상 신선한 문서만 허용
- `max-age` : 지정 시간 이상 캐시된 문서 거부
- `no-cache`/`no-store` : 각각 재검사 필수/저장 금지를 의미

\+ 이러한 만료 시스템은 완벽하지 않음. 개발자가 유효기간을 잘못 설정하거나 캐싱 자체가 서버와의 무결성을 지키기 어렵기 때문에 안전하게 하려면 생각보다 유효기간을 짧게 가져가야함.

## 캐시 제어 설정

### 아파치의 HTTP 헤더 제어 방식

#### mod_headers 모듈

> [!NOTE]
> 개별 HTTP 헤더를 설정할 수 있게 해주는 아파치 모듈 <br />
> 정규식과 필터 조합으로 특정 콘텐츠에 헤더 연결이 가능함

예시 설정은 아래와 같음.

```apache
<Files *.html>
  Header set Cache-control no-cache
</Files>
```

#### mod_expires 모듈

> [!NOTE] > `Expires` 헤더를 자동 생성하는 프로그램 로직을 제공하는 모듈 <br />
> 접근/수정 날짜 기준의 유효기간 설정 가능

예시 설정은 아래와 같음.

- `ExpiresDefault A3600`
- `ExpiresDefault "access plus 1 week"`
- `ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"`

#### mod_cern_meta 모듈

> [!NOTE]
> 특정 객체와 HTTP 헤더 파일을 연결시켜주는 모듈 <br />
> 각 파일별 메타파일 생성 통한 헤더 추가 가능

### HTML의 캐시 제어

#### META HTTP-EQUIV 태그

> [!NOTE]
> HTML 문서에 직접 HTTP 헤더 정보를 부여할 수 있는 태그 <br />
> 여러 제약사항으로 인해 권장되지 않는 방식

```html
<html>
  <head>
    <title>My Document</title>
    ‹META HTTP-EQUIV="Cache-control" CONTENT="no-cache">
  </head>
  ...
</html>
```

<img width="762" alt="image" src="https://github.com/user-attachments/assets/d3a1a35d-5521-4277-ad47-2c73e74c438a" />

#### 주요 특징

- HTML 문서 최상단에 위치
- 웹 서버용으로 설계되었으나 **대부분 서버 지원 X**
- 브라우저마다 처리 방식이 다르며 프락시 캐시와 충돌 가능성 존재

#### 한계점

- 서버 부하 증가
- 설정값의 정적 특성
- HTML 외 파일 미지원
- 프락시 캐시와의 동작 불일치

## 자세한 HTTP 캐시 알고리즘

### 나이와 신선도 수명 계산 특성

> [!NOTE]
> HTTP는 문서의 나이와 신선도 수명이라는 두 가지 값을 계산해 캐시된 문서의 제공 가능 여부를 판단함 <br /> > `문서 나이 < 신선도 수명`인 경우에만 제공 가능하다는 단순한 규칙 적용

문서의 나이는 서버가 문서를 보낸(또는 마지막으로 재검사한) 후 그 문서가 '나이를 먹은' 시간의 총합임. 캐시는 응답이 업스트림 캐시에서 왔는지 서버에서 왔는지 알 수 없으므로, `Age` 헤더나 `Date` 헤더를 통해 나이를 판별해야 함.

신선도 수명은 문서가 신선하다고 볼 수 있는 최대 허용 기간으로, 서버의 만료 정보와 클라이언트의 신선도 요구사항을 종합적으로 고려해 결정됨.

### 나이 계산 알고리즘

#### 겉보기 나이 계산

`Date` 헤더를 기반으로 나이를 계산하는 기본적 방식임.

```
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
```

시계 동기화 문제로 인한 오차 가능성 존재해 클록 스큐 보정을 따로 적용해야함.

#### 클록 스큐 보정

클라이언트와 서버 간 시간 설정 차이(클록 스큐)로 인해 나이 계산이 부정확할 수 있음. 음수 값이 나오는 경우를 방지하기 위해 0으로 설정하는 보정 작업 필요함.

#### `Age` 헤더를 통한 점층적 나이 계산

HTTP/1.1은 시계 동기화 문제를 우회하기 위해 `Age` 헤더를 도입함. 문서가 프락시나 캐시를 통과할 때마다 해당 장치들이 상대적 체류 시간을 `Age` 헤더에 누적함.

```
$보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
```

이 방식은 서버 간 시간 비교나 종단 간 시간 비교가 불필요하며, 두 나이 추정값 중 보수적인(가장 큰) 값을 선택함. 비-HTTP/1.1 장치는 `Age` 헤더를 인식하지 못하므로 완전한 채택 전까지는 `Age` 헤더가 상대 나이의 모자란 추정값으로 남게 됨.

#### 네트워크 지연 보상

느린 네트워크나 과부하 서버로 인해 문서 전송이 지연될 경우, 상대 나이 계산만으로는 부정확할 수 있음. HTTP/1.1은 왕복 지연 시간을 측정해 네트워크 지연을 보수적으로 교정함.

```
$응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
```

왕복 지연 시간은 단방향 지연의 보수적인 추정값으로, 오차가 있더라도 문서를 실제보다 오래되어 보이게 만들어 불필요한 재검사만 유발함.

#### 완전한 나이 계산 알고리즘

HTTP 문서가 캐시에 저장된 후 추가로 경과된 시간을 고려한 최종 나이를 계산함.

```
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;
$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;
```

<img width="670" alt="image" src="https://github.com/user-attachments/assets/cba5bbc4-3d25-4606-98d6-e89552e72cbd" />

### 신선도 수명 계산 알고리즘

서버 신선도 한계를 계산하는 펄 알고리즘을 사용해 여전히 서버에서 제공되는 상황에서 도달할 수 있는 최대 나이를 반환할 수 있음.

#### 서버 신선도 제약 계산

서버가 지정한 문서의 최대 유효 기간을 결정하는 과정임. 아래의 우선순위를 따름.

1. `Cache-Control: max-age` 값 확인

   ```
   if ($Max_Age_값이_설정되었나) {
       $서버_신선도_한계 = $Max_Age_값;
   }
   ```

2. `Expires` 헤더 확인

   ```
   elsif ($Expires_값이_설정되었나) {
       $서버_신선도_한계 = $Expires_값 - $Date_값;
   }
   ```

3. `Last-Modified` 기반 휴리스틱 계산

   ```
   elsif ($Last_Modified_값이_설정되었나) {
       $마지막으로_변경된_시각 = max(0, $Date_값 - $Last_Modified_값);
       $서버_신선도_한계 = int($마지막으로_변경된_시각 * $lm_인자);
       $휴리스틱 = 1;
   }
   ```

4. 기본 캐시 수명 적용
   ```
   else {
       $서버_신선도_한계 = $캐시_수명_기본값;
   }
   ```

휴리스틱 방식을 사용할 경우 최소/최대 캐시 수명 제한을 적용해 지나치게 짧거나 긴 값을 방지함.

전체 예시는 아래와 같음.

```perl
sub 서버_신선도_한계 {
    local ($휴리스틱, $서버_신선도_한계, $마지막으로_변경된_시각);
    $휴리스틱 = 0;

    if ($Max_Age_값이_설정되었나) {
        $서버_신선도_한계 = $Max_Age_값;
    }
    elsif ($Expires_값이_설정되었나) {
        $서버_신선도_한계 = $Expires_값 - $Date_값;
    }
    elsif ($Last_Modified_값이_설정되었나) {
        $마지막으로_변경된_시각 = max(0, $Date_값 - $Last_Modified_값);
        $서버_신선도_한계 = int($마지막으로_변경된_시각 * $lm_인자);
        $휴리스틱 = 1;
    }
    else {
        $서버_신선도_한계 = $캐시_수명_기본값;
        $휴리스틱 = 1;
    }

    if ($휴리스틱) {
        if ($서버_신선도_한계 > $캐시_최대_수명_기본값) {
            $서버_신선도_한계 = $캐시_최대_수명_기본값;
        }
        if ($서버_신선도_한계 < $캐시_최소_수명_기본값) {
            $서버_신선도_한계 = $캐시_최소_수명_기본값;
        }
    }

    return ($서버_신선도_한계);
}
```

#### 클라이언트 신선도 요구사항 반영

클라이언트 요청의 `Cache-Control` 헤더에 포함된 제약사항들을 고려해 서버 신선도 한계를 조정함.

1. `max-stale` : 지정된 시간 내에서는 신선하지 않은 콘텐츠도 허용

   ```
   if (아1ax_Stale_값이_설정되었나) {
       if ($Max_Stale_값 = $INT_MAX) {
           $나이_한계 = $INT_MAX;
       }
       else {
           $나이_한계 = 서버_신선도_한계() + $Max_Stale_값;
       }
   }
   ```

2. `min-fresh` : 지정된 시간 동안은 반드시 신선한 상태 유지 필요

   ```
   if ($Min_Fresh_값이_설정되었나) {
       $나이_한계 = min($나이_한계, 서버_신선도_한계() - $Min_Fresh값);
   }
   ```

3. `max-age` : 지정된 나이보다 어린 문서만 허용
   ```
   if ($Max_Age_값이_설정되었나) {
       $나이_한계 = min($나이_한계, $Max_Age_값);
   }
   ```

최종적으로 문서의 나이가 계산된 신선도 한계보다 작을 경우, 해당 문서는 '충분히 신선'하다고 판단해 캐시에서 직접 제공함.

전체 예시는 아래와 같음.

```perl
sub 클라이언트가_수정한_신선도_한계 {
    $나이_한계 = 서버_신선도_한계(); # 예 7-2 함수 호출

    if ($Max_Stale_값이_설정되었나) {
        if ($Max_Stale_값 == $INT_MAX) {
            $나이_한계 = $INT_MAX;
        }
        else {
            $나이_한계 = 서버_신선도_한계() + $Max_Stale_값;
        }
    }

    if ($Min_Fresh_값이_설정되었나) {
        $나이_한계 = min($나이_한계, 서버_신선도_한계() - $Min_Fresh값);
    }

    if ($Max_Age_값이_설정되었나) {
        $나이_한계 = min($나이_한계, $Max_Age_값);
    }

    return $나이_한계;
}
```

## 캐시와 광고 관련 이슈

### 퍼블리셔의 딜레마

> [!NOTE]
> 캐시는 성능과 트래픽 감소에 유익하나 광고 노출 횟수 기반 수익 모델과 충돌함 <br />
> 캐시가 요청을 흡수하면 원 서버는 실제 접근 횟수를 알 수 없게 됨

### 광고 노출 측정을 위한 대응 방안

**캐시 무력화 기법**을 사용함.

- CGI 게이트웨이를 통한 광고 제공
- 매 접근마다 광고 URL 변경
- 캐시 재검사 강제화

또다른 해결 방안은 아래와 같음

1. **로그 마이그레이션** : 이상적인 방법, 캐시 적중 로그를 원 서버에 전달하는 방식
   - 로그 크기와 표준화 부재로 실용성 부족
   - 인증 및 프라이버시 이슈 존재
2. **적중 측정과 사용량 제한** : RFC 2227 기반 Meter 헤더 활용
   - 캐시가 주기적으로 적중 횟수를 서버에 보고
   - 서버가 캐시된 문서의 제공 횟수 제한 가능
