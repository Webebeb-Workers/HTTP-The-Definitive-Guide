# 4 커넥션 관리

## 4.1 TCP 커넥션

- HTTP 통신은 TCP/IP를 통해 이루어짐
- 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌 지 않고 안전하게 전달됨

<img width="415" alt="image" src="https://github.com/user-attachments/assets/c9506550-e278-4d88-b17d-10f90b3f80c4" />

1. URL에서 호스트명 추출
2. 호스트명으로 IP주소 얻음
3. URL로 포트 번호 얻음
4. IP와 포트번호로 TCP 커넥션 생성
5. 브라우저가 서버로 HTTP 요청
6. 서버가 브라우저에게 HTTP 응답
7. 커넥션 종료

### 4.1.1 신뢰할 수 있는 데이터 전송 통로인 TCP

<img width="415" alt="image" src="https://github.com/user-attachments/assets/45559863-6b4c-4ec4-8bd0-e7d4d61a7bfe" />

- TCP는 HTTP의 기반이 되어 데이터를 순서대로 정확하게 전달하는 신뢰성 있는 통신 방식을 제공함

### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송됨

<img width="415" alt="image" src="https://github.com/user-attachments/assets/06b5859a-ecea-4750-887d-3886aaed3d50" />

<img width="419" alt="image" src="https://github.com/user-attachments/assets/42542fbf-95ec-458f-825e-2a8ba894be77" />

- TCP는 IP 패킷（혹은 IP 데이터그램）이라고 불리는 작은 조각을 통해 데이터를 전송함
- TCP/IP 프로토콜 스택에서:

  1. HTTP는 최상위 계층에서 메시지를 전송
  2. TCP는 이 메시지를 세그먼트로 분할
  3. IP는 이 세그먼트를 패킷으로 감싸서 전달
  4. 각 패킷은 IP 패킷 헤더(20B), TCP 세그먼트 헤더(20B), 데이터로 구성

### 4.1.3 TCP 커넥션 유지하기

- TCP 커넥션은 4가지 값(발신지 IP, 발신지 포트, 수신지 IP, 수신지 포트)으로 유일한 커넥션을 생성하고 식별함
- 서로 다른 TCP 커넥션은 이 4가지 값이 모두 동일할 수 없지만 일부 값은 동일할 수 있음

<img width="420" alt="image" src="https://github.com/user-attachments/assets/a8f64f02-aae7-40a7-a113-9e5afa9819c6" />

<img width="416" alt="image" src="https://github.com/user-attachments/assets/424c98bf-0d23-4055-895f-5cacea6dd452" />

### 4.1.4 TCP 소켓 프로그래밍

- 소켓 API: 운영체제는 TCP 커넥션의 생성과 관련된 여러 기능을 제공함
- 소켓 API는 TCP/IP의 복잡성을 추상화하여 서버-클라이언트 간 TCP 커넥션 생성과 데이터 통신을 단순화함

<img width="426" alt="image" src="https://github.com/user-attachments/assets/633d2a30-2ae5-4592-803c-853ddab1feee" />

**클라이언트와 서버가 TCP 소켓 인터페이스를 사용하여 상호작용하는 방법**

<img width="416" alt="image" src="https://github.com/user-attachments/assets/2fbaa2fa-e500-4757-b4bd-e39e8dfa3d2c" />

## 4.2 TCP의 성능에 대한 고려

- HTTP의 성능은 하위 계층인 TCP의 성능에 직접적인 영향을 받으므로, 더 좋은 성능의 HTTP 애플리케이션 개발을 위해서는 TCP 성능의 특성을 이해하는 것이 중요함

### 4.2.1 HTTP 트랜잭션 지연

<img width="416" alt="image" src="https://github.com/user-attachments/assets/d3b2e3ca-a7fe-4fed-8250-fd7f3e115706" />

- HTTP 트랜잭션의 주요 지연 요인을 순서대로 정리하면:

  1. DNS 조회 지연: URI의 호스트명을 IP 주소로 변환하는 시간
  2. TCP 연결 지연: 새로운 TCP 커넥션 설정에 필요한 시간
  3. 요청 전송 지연: HTTP 요청이 TCP를 통해 서버로 전송되는 시간
  4. 응답 전송 지연: 서버의 응답이 클라이언트에게 전송되는 시간

- 이런 TCP 네트워크 지연은 하드웨어 성능, 네트워크와 서버의 전송 속도, 요청과 응답 메시지의 크기, 클라이언트와 서버 간의 거리에 따라 크게 달라짐

### 4.2.2 성능 관련 중요 요소

| 지연 요인              | 설명                                                   |
| ---------------------- | ------------------------------------------------------ |
| TCP 핸드셰이크         | 커넥션 설정을 위한 초기 연결 과정에서의 지연           |
| 느린 시작(slow-start)  | 인터넷 혼잡 제어를 위한 점진적 속도 증가 메커니즘      |
| 네이글(Nagle) 알고리즘 | 작은 데이터를 모아서 한 번에 전송하는 과정의 지연      |
| 확인응답 지연          | 데이터와 응답을 하나의 패킷으로 전송하는 과정의 지연   |
| TIME_WAIT 지연         | 커넥션 종료 후 일정 시간 포트를 재사용하지 못하는 지연 |

### 4.2.3 TCP 커넥션 핸드셰이크 지연

<img width="418" alt="image" src="https://github.com/user-attachments/assets/6780da19-7d02-4006-a247-48035261b541" />

- TCP 핸드셰이크(3-way handshake) 과정을 단계별로 정리하면:

  - 클라이언트 → 서버: SYN 플래그가 설정된 TCP 패킷 전송 (40~60바이트)
  - 서버 → 클라이언트: SYN + ACK 플래그가 설정된 TCP 패킷으로 응답
  - 클라이언트 → 서버: 최종 확인응답(ACK) 전송 (이때 데이터도 함께 전송 가능)

- 작은 HTTP 트랜잭션의 경우, 전체 처리 시간의 50% 이상이 TCP 연결 구성에 소요되는데, 이러한 TCP 구성 지연을 줄이기 위해 HTTP는 기존 커넥션을 재사용하는 방식을 사용함

### 4.2.4 확인응답 지연

- TCP의 데이터 전송 신뢰성 보장 메커니즘 원리:

  1. 각 TCP 세그먼트에 순번과 체크섬 포함
  2. 수신자는 정상 수신시(세그먼트를 온전히 받으면) 확인응답(ACK) 전송
  3. 송신자는 확인응답 미수신 시 재전송 수행

- 확인응답 최적화:

  - 데이터 패킷에 확인응답을 '통합(piggyback)' 전송
  - 0.1~0.2초간 확인응답을 지연시켜 통합 기회 모색
  - 통합 기회가 없으면 별도 패킷으로 전송

- HTTP에서의 한계:
  - 요청-응답 구조로 인해 통합 기회 감소
  - 확인응답 지연으로 인한 성능 저하 발생

### 4.2.5 TCP 느린 시작(slow start)

- 작동 원리:

  - TCP는 새로운 연결에서 처음에는 전송 속도를 제한
  - 성공적인 전송이 확인될 때마다 전송 가능한 패킷 수를 2배로 증가
  - 패킷 전송 성공 → 2개 더 전송 가능 → 4개 → 8개 → ...

- 목적:

  - 인터넷의 급작스러운 부하와 혼잡을 방지
  - ex) 처음부터 많이 보내는 것 = 교통상황 모르고 차량 100대를 한꺼번에 도로에 투입, 점진적 증가 = 차량 몇 대 보내보고 막히면 조절하고 괜찮으면 2배 투입

- 영향:
  - 새로운 TCP 연결은 초기에 속도가 느리고 기존에 쓰던 '튜닝된' TCP 연결이 더 효율적
  - 이로 인해 HTTP는 기존 연결 재사용(지속 커넥션) 방식을 선호

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- 네이글 알고리즘 작동 원리:

  - 작은 패킷들을 모아서 큰 패킷으로 만들어 전송
  - 최대 크기(LAN: 1,500바이트, 인터넷: 수백 바이트)까지 데이터를 버퍼에 누적
  - 이전 패킷의 확인응답을 받았을 때만 작은 패킷 전송 허용

- 목적:

  - 네트워크 효율성 증가
  - 작은 패킷으로 인한 오버헤드 감소 (각 패킷마다 40바이트의 헤더 필요)

- HTTP에서의 문제점:

  - 작은 HTTP 메시지가 불필요하게 지연될 수 있음
  - 확인응답 지연 알고리즘과 충돌 시 심각한 성능 저하
  - 해결책: TCP_NODELAY 설정으로 비활성화하고 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들기

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT의 목적과 동작:

  - TCP 연결 종료 후 일정 시간(보통 2MSL, 약 2분) 동안 해당 포트 재사용 제한
  - 이전 연결의 패킷이 새로운 연결에 섞이는 것을 방지
  - IP주소와 포트번호 조합을 제어 블록에 기록

- 포트 고갈 문제:

  - 가용 포트 수(약 60,000개) ÷ 대기 시간(120초) = 초당 최대 500개 연결 가능
  - 주로 성능 테스트 시 문제 발생(발신지 IP 주소, 발신지 포트, 목적지 IP 주소, 목적지 포트 중 발신지 포트만 변경할 수 있기 때문)
  - 실제 운영 환경에서는 보통 문제되지 않음

- 해결 방안:
  - 더 많은 클라이언트 장비 사용하거나 여러 개의 가상 IP 주소 사용
  - 2MSL 시간 조정 (주의 필요)

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 Connection 헤더

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/dc493130-5121-4b2e-a20b-e799f71a93dc" />

- Connection 헤더는 현재 맺은 커넥션에만 적용되는 옵션을 지정하며, 다음과 같은 세 가지 종류의 토큰을 포함할 수 있음음

  - 현재 커넥션에만 해당되는 HTTP 헤더 필드명
  - 커넥션에 대한 비표준 옵션을 의미하는 임시 토큰
  - 작업 완료 후 커넥션 종료를 의미하는 'close' 값 (Connection: close)

- 홉별(hop-by-hop) 동작:

  - Connection 헤더에 명시된 모든 헤더는 다음 커넥션으로 전달되지 않음
  - 메시지 전달 시 Connection 헤더와 그 안에 명시된 모든 헤더들이 삭제됨
  - Proxy-Authenticate, Transfer-Encoding 등은 Connection 헤더에 명시되지 않아도 홉별 헤더로 처리됨

- 이러한 메커니즘을 통해 HTTP는 중개 서버들 사이에서 특정 커넥션에만 적용되어야 하는 옵션들을 안전하게 관리할 수 있음

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안좋아질 수 있음

<img width="421" alt="Image" src="https://github.com/user-attachments/assets/51fc0e6b-a287-4db1-abbc-7ebd248a40e3" />

- 위 사진의 상황

  - 3개의 이미지를 웹페이지에서 보여주려함
  - 브라우저가 페이지를 보여주려면 4개의 트랜잭션 필요(HTML, 이미지1, 이미지2, 이미지3)

- HTTP 트랜잭션의 순차적 처리의 문제점:

  - 각 요청마다 새로운 커넥션을 생성하면 지연 발생(TCP 3-way handshake, TCP slow start)
  - 지연으로 인한 사용자 경험 저하 (빈 화면)
  - 특정 브라우저는 모든 객체의 크기를 알아야 화면 배치 가능하여 그때까지 텅 빈 화면을 보여줌

- HTTP 커넥션의 성능 향상을 위한 4가지 기술:

  - 병렬 커넥션: 여러 TCP 커넥션으로 동시 요청
  - 지속 커넥션: TCP 커넥션 재활용 (TCP 3-way handshake, TCP slow start 지연 문제 해결)
  - 파이프라인 커넥션: 하나의 TCP 커넥션으로 병렬 요청
  - 다중 커넥션: 요청/응답 중재 (실험적인 기술임)

- 이러한 기술들은 단일 커넥션의 순차적 처리로 인한 성능 저하와 사용자 경험 문제를 해결하기 위해 도입됨

## 4.4 병렬 커넥션

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/ecc2b3e8-89b2-41fd-8cd9-6037ad8091c3" />

- 웹페이지 로딩 시 여러 개의 TCP 커넥션을 동시에 사용하여 여러 HTTP 트랜잭션을 병렬로 처리함으로써 순차적 다운로드보다 빠른 성능을 제공할 수 있음

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 지연 시간 중첩

  - 여러 커넥션의 지연 시간이 겹치면서 전체 지연 시간 감소
  - 각 커넥션별 대기 시간이 병렬로 처리됨

- 대역폭 활용 최적화

  - 하나의 커넥션이 사용하지 않는 대역폭을 다른 커넥션이 활용 가능
  - 전체 가용 대역폭을 더 효율적으로 사용

- 이를 통해 단일 커넥션 방식보다 웹페이지 로딩 속도를 크게 향상시킬 수 있음

### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다

- 효과가 제한적인 경우:

  - 좁은 대역폭(예: 28.8Kbps 모뎀) 환경에서는 병렬 처리의 이점이 거의 없음
  - 오히려 커넥션 생성 부하로 인해 순차적 다운로드보다 더 느려질 수 있음

- 리소스 문제:

  - 다수의 커넥션은 많은 메모리 소모
  - 서버 부하 증가 (예: 100명이 각각 100개 커넥션 = 10,000개 커넥션)

- 실제 제한:

  - 브라우저는 보통 4개 정도의 병렬 커넥션만 허용
  - 서버는 과도한 커넥션 수 제한 가능(연결 요청 거부 또는 연결 끊기)

### 4.4.3 병렬 커넥션은 더 빠르게 '느껴질 수' 있다

- 실제 성능:

  - 반드시 더 빠른 로딩 속도를 보장하지는 않음
  - 총 다운로드 시간이 더 길어질 수도 있음

- 사용자 경험:

  - 여러 객체가 동시에 로드되는 모습을 볼 수 있기 때문에 실제 총 시간이 더 걸려도 사용자는 더 빠르다고 인식함

- 즉, 병렬 커넥션은 실제 성능보다 체감 성능 향상에 더 큰 효과가 있음

### 4.5 지속 커넥션

- HTTP의 사이트 지역성(site locality): 동일 사이트에 여러 리소스 요청하는 것
- HTTP/1.1에서는 이를 효율적으로 처리하기 위해 지속 커넥션(persistent connection)을 도입함
- 지속 커넥션은 요청 처리 완료 후에도 TCP 연결을 유지하여 추가 요청에 재사용할 수 있게 하며, 이를 통해 새로운 연결 설정에 드는 시간을 절약하고 TCP 느린 시작으로 인한 지연을 방지하여 전체적인 성능을 향상시킴

### 4.5.1 지속 커넥션 vs 병렬 커넥션

**병렬 커넥션의 특징과 한계**

- 장점: 여러 파일을 동시에 다운로드해서 전체적인 속도가 빠름
- 단점:
  - 연결할 때마다 시간과 대역폭을 새로 써야 함
  - 새 연결은 처음에는 천천히 시작해서 속도가 느림
  - 한 번에 연결할 수 있는 수가 제한적임

**지속 커넥션의 특징**

- 장점:

  - 커넥션을 맺기 위한 사전작업과 지연을 줄여줌
  - 이미 최적화된 연결 상태를 계속 사용(튜닝된 커넥션 유지)
  - 전체적인 커넥션 수가 줄여줌

- 단점:

  - 관리를 잘 못하면 불필요한 커넥션이 쌓여서 자원 낭비

**현대의 해결책**

- 병렬 커넥션과 지속 커넥션을 함께 사용
- 적은 수의 연결만 만들어서 그것을 계속 재사용
- HTTP/1.0+는 'keep-alive', HTTP/1.1은 '지속' 커넥션 방식 사용

- 이렇게 두 방식의 장점을 조합해서 효율적인 웹 통신을 구현하고 있음

### 4.5.2 HTTP/1.0+21 Keep-Alive 커넥션

<img width="414" alt="Image" src="https://github.com/user-attachments/assets/c4854b60-bdfc-4f6b-b2b0-b99951a93b46" />

- 1996년경부터 HTTP/1.0에서 지속 커넥션(Keep-Alive)을 도입함
- 주요 장점은 성능 향상임
  - 여러 HTTP 요청을 하나의 커넥션으로 처리
  - 커넥션을 반복해서 맺고 끊는 시간 절약
- 초기 버전에는 상호 운용성 관련 설계 문제가 있었으나, 이는 HTTP/1.1에서 해결됨
- 현재도 많은 클라이언트와 서버가 이 기능을 계속 사용하고 있음

### 4.5.3 Keep-Alive 동작

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/1b38f15e-eda2-4dec-820d-6501d3ac863a" />

**현재 상태:**

- HTTP/1.1 공식 명세에서는 제외됨
- 하지만 여전히 브라우저와 서버에서 널리 사용 중
- 따라서 HTTP 애플리케이션은 이를 처리할 수 있어야 함

**동작 방식:**

- 클라이언트: 커넥션 유지를 위해 Connection: Keep-Alive 헤더를 요청에 포함
- 서버: 지원시 같은 헤더로 응답, 미지원시 해당 헤더 없이 응답
- 헤더가 없는 응답을 받으면 클라이언트는 서버가 응답 후 연결을 끊을 것으로 간주
- 이러한 핸드셰이크 방식의 자세한 내용은 HTTP/1.1 이전 버전의 명세인 RFC 2068에서 확인할 수 있음

### 4.5.4 Keep-Alive 옵션

**Keep-Alive의 기본 특성:**

- Keep-Alive는 단순한 요청일 뿐, 반드시 따를 필요는 없음
- 서버/클라이언트는 언제든 커넥션을 끊을 수 있음
- 트랜잭션 수를 제한할 수 있음

**제어 옵션(헤더의 파라미터):**

- timeout: 커넥션 유지 시간
- max: 처리할 HTTP 트랜잭션 수
- 기타 디버깅용 속성들 지원, 이름[=값] 의 형태태

**사용 규칙:**

- Keep-Alive 헤더는 선택사항
- Connection: Keep-Alive 헤더가 있을 때만 사용 가능
- 예시:

  ```
  Connection: Keep-Alive + Keep-Alive: max=5, timeout=120
  ```

- 주의할 점: timeout과 max 파라미터는 이대로 동작한다는 보장은 없음

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

**기본 사용 규칙:**

- HTTP/1.0에서는 기본으로 사용되지 않음
- 커넥션을 유지하려면 모든 메시지에 Connection: Keep-Alive 헤더 필요
- 서버 응답에 해당 헤더가 없으면 연결이 곧 끊어질 것을 의미

**엔터티 본문 처리:**

- Content-Length 값이 정확해야 커넥션을 유지할 수 있음
- 본문이 멀티파트 미디어 형식이거나 청크 전송 인코딩 값이어야 함
- keep-alive 커넥션에서 잘못된 Content-Length 값을 보내는 것은 좋지 않은데, 트랜잭션이 끝나는 시점에 기존 메시지의 끝과 새로운 메시지의 시작점을 정확히 알 수 없기 때문

**프록시 관련:**

- Connection 헤더 규칙을 엄격히 준수해야 함
- 메시지를 전달하거나 캐시에 넣기 전에 Connection 관련 필드 제거 필요
- 멍청한 프록시 서버와의 호환성 주의

**안전성:**

- 오래된 프락시 서버의 실수를 피하기 위해 HTTP/1.0 기기의 Connection 헤더는 무시해야 함
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어졌을 경우, 재요청할 수 있도록 준비되어 있어야 함

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

<img width="417" alt="Image" src="https://github.com/user-attachments/assets/5c3fc327-6425-48b9-af96-47edfae79067" />

**문제의 시작: Connection 헤더의 무조건 전달**

- 멍청한 프록시는 Connection 헤더를 이해하지 못함
- Connection은 홉별(hop-by-hop) 헤더여서 다음 서버로 전달되면 안 되는데, 프록시가 이를 그대로 전달

**문제 진행 과정:**

1. 클라이언트 → 프록시: Keep-Alive 요청
2. 프록시 → 서버: 헤더를 이해 못하고 그대로 전달
3. 서버: 프록시가 Keep-Alive를 요청했다고 오해
4. 프록시: 서버의 Keep-Alive 응답을 클라이언트에 그대로 전달

**결과적 문제:**

- 프록시는 서버의 연결 종료를 계속 대기
- 프록시는 하나의 연결에 하나의 요청만 처리하는 것으로 알고 있음. 따라서 같은 연결로 들어오는 이후 요청들을 모두 무시함
- 브라우저는 타임아웃까지 응답 없이 대기

- 이런 문제 때문에 keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프록시 서버와는 사용하지 말아야 함

**프록시의 헤더 처리 규칙:**

- Connection 헤더 자체를 전달하면 안 됨
- Connection 헤더에 명시된 모든 헤더들도 전달하면 안 됨
- 예: Connection: Keep-Alive가 있다면, Keep-Alive 헤더도 전달 금지

**전달/캐시 금지되는 홉별 헤더들:**

- Proxy-Authenticate
- Proxy-Connection
- Transfer-Encoding
- Upgrade

### 4.5.7 Proxy-Connection 살펴보기

**넷스케이프의 해결책 제안:**

- Connection 헤더 대신 Proxy-Connection 헤더 사용
- 목적: 멍청한 프록시의 무조건 전달 문제 해결

**동작 방식:**

<img width="413" alt="Image" src="https://github.com/user-attachments/assets/47357551-ccc9-41d8-8709-d816904aa49f" />

- 멍청한 프록시: Proxy-Connection 헤더를 전달해도 서버가 무시해서 문제 없음
- 영리한 프록시: Proxy-Connection을 Connection 헤더로 변환하여 적절히 처리

**한계점:**

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/e88e1c29-f97e-4597-9e44-c980cc18d23a" />

- 프록시가 한 개일 때만 정상 작동
- 멍청한 프록시와 영리한 프록시가 섞여 있으면 잘못된 헤더 만들어내는 문제 다시 발생
- 네트워크상에서 보이지 않는 프록시(방화벽, 캐시 서버 등)에게는 Proxy-Connection 헤더를 보내지 못하므로 해결 불가

- 결론: 부분적인 해결책은 되지만, 모든 상황에서 완벽한 해결책이 되지는 못했음

### 4.5.8 HTTP/1.1의 지속 커넥션

**기본 특징:**

- HTTP/1.1은 keep-alive 대신 개선된 `지속 커넥션` 사용
- 기본적으로 모든 커넥션이 지속 커넥션으로 활성화됨

**주요 변화:**

- HTTP/1.0: keep-alive가 선택사항
- HTTP/1.1: 지속 커넥션이 기본값

**동작 방식:**

- 커넥션을 끊으려면 'Connection: close' 헤더 필요
- 'Connection: close' 없으면 연결 유지로 간주
- 단, 영구 연결을 보장하는 것은 아님 (서버/클라이언트가 언제든 종료 가능, Connection： close를 보내지 않는 것이 서버가 커넥션을 영원히 유지하겠다는 것을 뜻하지는 않음)

### 4.5.9 지속 커넥션의 제한과 규칙

**클라이언트의 연결 규칙:**

- 'Connection: close' 헤더를 포함한 요청 후에는 추가 요청 불가
- 추가 요청이 없다면 마지막 요청에 'Connection: close' 헤더 포함 필수

**메시지 길이 요구사항:**

- 모든 메시지는 정확한 길이 정보 포함 필수
  - 정확한 Content-Length 값 사용
  - 청크 전송 인코딩(chunked transfer encoding) 사용

**프록시 서버 규칙:**

- 클라이언트와 서버 각각에 대해 별도의 지속 커넥션 관리
- 클라이언트의 커넥션 관련 기능 지원 범위를 모르면 지속 커넥션 사용 금지 (오래된 프록시의 Connection 헤더 전달 문제 때문)

**서버 동작 규칙:**

- 메시지 전송 중간에 커넥션 종료하지 않음
- 커넥션을 끊기 전에 적어도 하나의 요청에 대한 응답 보장
- 단, Connection 헤더 값과 상관없이 언제든 커넥션 종료 가능

**연결 복구와 재전송:**

- HTTP/1.1 애플리케이션은 중단된 커넥션 복구 가능해야 함. 클라이언트는 안전한 요청의 경우 재전송 가능해야 함
- 클라이언트는 전체 응답 수신 전 연결 종료 시 요청을 다시 보낼 준비가 돼있어야함

**연결 수 제한:**

- 클라이언트: 서버 과부하 방지를 위해 최대 2개의 지속 커넥션만 유지
- 프록시: N명의 사용자 접근 시 서버/상위 프록시와 약 2N개의 커넥션 유지

## 4.6 파이프라인 커넥션

<img width="415" alt="Image" src="https://github.com/user-attachments/assets/292b3b19-c5e6-47ba-9f7f-edf43b19e26f" />

**파이프라이닝의 개념과 장점:**

- 지속 커넥션을 통해 여러 요청을 연속적으로 전송 가능
- 응답을 기다리지 않고 요청들을 큐에 쌓아 전송
- 네트워크 왕복 시간을 줄여 성능 향상

**주요 제약사항:**

- 지속 커넥션 확인 후에만 파이프라이닝 사용 가능
- 응답은 반드시 요청 순서와 동일하게 와야 함
- 커넥션 종료 시 미완료 요청에 대한 재전송 준비 필요

**안전성 관련 제약:**

- POST와 같은 비멱등(nonidempotent) 요청은 파이프라이닝 사용 금지

  - 이유: 오류 발생 시 클라이언트는 어떤 요청까지 서버에서 처리되었는지 알 수 없음 -> 재전송 시 문제 발생 가능성
  - 비멱등 요청은 반드시 하나씩 처리하고 응답을 확인해야 합

- 이런 제약들 때문에 파이프라이닝은 신중하게 사용해야 함

## 4.7 커넥션 끊기에 대한 미스터리

### 4.7.1 '마음대로' 커넥션 끊기

**기본 원칙:**

- 모든든 HTTP 클라이언트, 서버, 프록시는 언제든 커넥션을 종료 가능
- 일반적으로는 메시지 전송 완료 후 커넥션 종료함

**비정상 종료:**

- 에러 상황에서는 메시지 중간에도 종료될 수 있음
- 지속 커넥션의 경우 유휴 상태가 길면 서버는 커넥션 종료할 수 있음

**문제점:**

- 서버가 유휴 상태에 있는 커넥션을 종료하는 시점에 클라이언트가 데이터를 전송하지 않을 것이라고 확신할 수 없어서 클라이언트가 요청 도중에 연결이 끊길 수 있음
- 즉, 커넥션 종료는 언제든 일어날 수 있으며, 이는 예기치 않은 통신 문제를 일으킬 수 있음

### 4.7.2 Content-Length와 Truncation

**Content-Length의 요구사항:**

- 모든 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 함

**오래된 서버의 문제:**

- Content-Length 헤더를 생략하거나 잘못된 값을 보내기도 함

**문제 발생 시 처리 방법:**

- 길이 불일치나 헤더 누락 시 서버에 정확한 길이 재확인 필요
- 캐시 프록시는:
  - 이런 응답을 캐시하지 말아야 함
  - Content-Length를 수정하지 말고 그대로 전달해야 함

### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

**기본 원칙:**

- 커넥션은 에러가 없어도 언제든 종료될 수 있음
- 애플리케이션은 예상치 못한 종료에 대응할 준비 필요

**재시도 규칙:**

- 멱등(idempotent) 요청:

  - GET, HEAD, PUT, DELETE, TRACE, OPTIONS
  - 여러 번 실행해도 같은 결과
  - 자유롭게 재시도 가능

- 비멱등(non-idempotent) 요청:

  - POST 등
  - 반복 실행 시 다른 결과 발생
  - 자동 재시도 금지
  - 사용자 확인 후 재시도 필요

**파이프라이닝 관련:**

- 서버는 미처리 요청 남겨둔 채 연결 종료 가능
- 비멱등 요청은 파이프라이닝 사용 금지
- 이전 요청의 응답을 받은 후 재전송 필요

### 4.7.4 우아한 커넥션 끊기

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/8230bd4d-ca35-4c5a-8401-6fa708f0f589" />

- TCP 커넥션은 입력/출력 큐를 가진 양방향(bidirectional) 통신으로, 한쪽의 출력 큐 데이터는 상대방의 입력 큐로 전달됨

**전체 끊기와 절반 끊기**

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/b26cdab6-95e2-44f1-b811-73f645f92556" />

- 전체 끊기(close()):

  - 입력과 출력 채널 모두 종료
  - 양방향 통신 완전 중단

- 절반 끊기(shutdown()):

  - 입력 또는 출력 채널 중 하나만 선택적으로 종료 가능
  - 나머지 채널은 계속 통신 가능

**TCP 끊기와 리셋 에러**

<img width="415" alt="Image" src="https://github.com/user-attachments/assets/19856022-ff34-41e0-80f3-29d997b99e28" />

- 전체 끊기와 절반 끊기의 선택:

  - 단순한 HTTP 통신: 전체 끊기 사용 가능
  - 파이프라인 지속 커넥션: 절반 끊기 사용 필요

- 안전한 종료 방식:

  - 출력 채널 종료: 안전함 (상대방이 데이터 수신 완료 확인 가능)
  - 입력 채널 종료: 위험함 (상대방이 추가 데이터 전송 시 문제 발생)

- 입력 채널 종료의 위험성:

  - 종료된 채널로 데이터 전송 시 'connection reset by peer' 발생
  - 운영체제가 버퍼의 미처리 데이터 모두 삭제
  - 파이프라인에서 특히 심각한 문제 (여러 응답 데이터 손실 가능)

**우아하게 커넥션 끊기**

- 권장되는 우아한 종료 방식:

  - 자신의 출력 채널 먼저 종료
  - 상대방의 출력 채널 종료 대기

- 현실적인 구현 어려움:

  - 상대방의 절반 끊기 구현 여부 불확실
  - 상대방의 종료 여부 확인 불가능

- 실제 구현 방안:

  - 출력 채널 절반 끊기 수행
  - 입력 채널 주기적 상태 검사
  - 타임아웃 시 강제 종료 실행

- 즉, '우아한 종료'는 이상적이지만 실제로는 타임아웃과 강제 종료를 포함한 방어적인 구현이 필요함
