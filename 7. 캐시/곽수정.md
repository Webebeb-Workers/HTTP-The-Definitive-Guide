# 7. 캐시

캐시의 성능 특성과 어떻게 그 성능을 측정하는지, 효과적인 사용법과 동작 과정에 대해 알아보는 챕터

## 7.1 불필요한 데이터 전송

캐시 사용 시 보관된 서버 응답을 전달해 원 서버의 중복 트래픽 낭비를 방지하는 역할을 함

## 7.2 대역폭 병목

네트워크 병목도 줄여주는 역할을 함

- 많은 네트워크가 원격 서버보다 `로컬 네트워크 클라이언트`에 더 넓은 대역폭 제공
- 클라이언트 > 서버 접근 시 경로에 있는 가장 느린 네트워크 속도와 같음
- 클라이언트 > 빠른 LAN에 있는 캐시로부터 사본 가져오는 경우 성능 대폭 개선 가능

<img width="570" alt="image" src="https://github.com/user-attachments/assets/56743327-355f-4c03-b883-d99ac1e55bcd" />

<img width="589" alt="image" src="https://github.com/user-attachments/assets/543ffd64-5816-4107-9988-4e3e1583ca98" />

## 7.3 갑작스런 요청 쇄도 (Flash Crowds)

- 갑작스런 요청 쇄도 시 불필요한 트래픽 급증 > 웹 서버의 심각한 장애 야기 가능
- 이러한 상황에서도 대처 솔루션으로써 캐싱이 중요함

## 7.4 거리로 인한 지연

- 대역폭이 아니더라도 거리로 인한 문제 발생 가능
- 모든 네트워크 라우터는 인터넷 트래픽을 지연시키지만 클라이언트 ↔️ 서버 사이의 라우터 수와 무관하게 빛의 속도에 의한 지연 유발 가능
- 보통 수준으로 복잡한 웹 페이지 = 빛의 속도로 인한 지연이 수 초에 달할 수도 있음

<img width="583" alt="image" src="https://github.com/user-attachments/assets/2ed90962-b323-4980-8311-af16f73d80f1" />

## 7.5 적중과 부적중

- **cache hit(캐시 적중)**: 수신받은 요청에 대응하는 사본 존재하는 경우
- **cache miss(캐시 부적중)**: 수신받은 요청에 대응하는 사본 존재하지 않는 경우

<img width="590" alt="image" src="https://github.com/user-attachments/assets/b0a7637c-5002-4571-bdb8-45633bcc00cd" />

### 7.5.1 재검사 (Revalidation)

- **HTTP 재검사**: 신선도 검사 = 사본이 여전히 최신인지 점검함
  - 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사 가능
- 캐시는 스스로 언제든지 사본 재검사 가능하지만 수백만개의 사본을 재검사 하기에는 네트워크 대역폭이 부족하기 때문에 충분히 오래된 경우에만 재검사 함

1. 사본의 재검사 필요 시 원 서버에 작은 재검사 요청 전공
2. 콘텐츠 변경 X일 경우 서버는 `304 Not Modified` 응답 보냄
3. 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선함을 임시로 표시하고 클라이언트에게 제공

- 해당 방법은 **재검사 적중** 혹은 **느린 적중**이라함
- 속도: 순수 캐시 적중 > 재검사 적중 > 캐시 부적중

<img width="583" alt="image" src="https://github.com/user-attachments/assets/91d919c0-beee-4dda-b07a-1230adcd2dec" />

**HTTP가 제공하는 캐시 재확인 도구**

- `If-Modified-Since` 헤더
  - 서버에게 보내는 GET 요청에 포함해 캐시된 시간 이후 변경된 경우에만 사본 보내달라는 의미 내포
  - 아래 3가지 케이스는 `If-Modified-Since` 요청이 서버에 도착했을 때 일어날 수 있는 상황임

1. 재검사 적중

- 서버 객체 미변경 시 HTTP `304 Not Modified` 응답 수신

<img width="580" alt="image" src="https://github.com/user-attachments/assets/ba2dff15-fc62-4544-a6c9-79aaff3ed642" />

2. 재검사 부적중

- 서버 객체가 캐시된 사본과 다른 경우 `콘텐츠 전체 + HTTP 200 OK` 응답 수신

3. 객체 삭제

- 서버 객체 삭제되었을 땐 `404 Not Found` 응답 수신 + `캐시는 사본 삭제`

### 7.5.2 적중률

- **캐시 적중률(문서 적중률)**: 캐시가 요청을 처리하는 비율
  - 0%: 모든 요청이 캐시 부적중
  - 100%: 모든 요청이 캐시 적중
  - 적중률 40%라면 웹 캐시로 괜찮은 편

### 7.5.3 바이트 적중률

- **바이트 적중률**: 캐시를 통해 제공된 모든 바이트의 비율

- **문서 적중률 vs 바이트 적중률**
  - 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌
  - 문서 적중률 개선 시 전체 대기시간 (지연) 감소 (트랜잭션 시간, e.g. TCP 커넥션 맺는 시간으로 인간 지연)
  - 바이트 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌
  - 바이트 단위 적중률 개선은 대역폭 절약을 최적화함

### 7.5.4 적중과 부적중의 구별

- 클라이언트는 HTTP를 통해 캐시 적중이었는지 원 서버 접근이었는지 알 방법이 없음 (둘 다 200 OK)
- 대신 응답이 캐시에서 왔는지 알 수 있는 방법
  - `Date 헤더`: 응답 생성일이 현재 시각보다 오래된 경우 캐시된 것임
  - `Age 헤더`: 응답이 얼마나 오래되었는지 알려줌

> Q. 응답 생성일은 원래 현재 시각보다 더 오래되지 않나?

## 7.6 캐시 토폴로지

- **개인 전용 캐시**: 한 명에게만 할당된 캐시
- **공용 캐시**: 사용자 집단에게 자주 쓰이는 캐시

### 7.6.1 개인 전용 캐시

- 웹 브라우저는 개인 전용 캐시 내장하고 있음
  - 자주 쓰이는 문서 > 개인용 컴퓨터의 디스크, 메모리에 저장
  - 사용자가 캐시 사이즈와 설정 수정 가능
  - 브라우저 내에 캐싱된 콘텐츠 목록 확인 가능

<img width="581" alt="image" src="https://github.com/user-attachments/assets/d872bc97-200c-41c7-aab8-f4ca148010b4" />

### 7.6.2 공용 프락시 캐시

- 공용 캐시 = 캐시 프락시 서버 = 캐시 프락시라고 불리는 특별한 종류의 공유된 프락시 서버
- 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버 접근함
- 여러 사용자가 접근하기 때문에 불필요한 트래픽 줄일 수 있음

<img width="582" alt="image" src="https://github.com/user-attachments/assets/e104cb31-8303-45c0-87b7-bd9a636a08da" />

- 개인 전용 캐시는 클라이언트마다 제각각 가져오기 때문에 같은 문서를 네트워크 여러번 거쳐오게 됨
- 굥용 캐시는 자주 찾는 객체 단 한번만 가져와 모든 요청에 대해 공유된 사본 사용, 네트워크 트래픽 감소

- 수동 프락시 설정 혹은 프락시 자동설정 파일 설정 > 브라우저가 프락시 캐시 사용 가능
- 인터셉트 프락시 사용해 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제 가능

### 7.6.3 프락시 캐시 계층들

- 작은 캐시에서 캐시 부적중 발생 > 더 큰 부모가 필터링된 트래픽 처리하도록 하는 계층이 합리적인 경우도 있음
- 클라이언트 주위에는 작고 저렴한 캐시 사용 & 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시 사용

<img width="582" alt="image" src="https://github.com/user-attachments/assets/dbf42e70-a9f9-43e3-b8ff-4a7587cbf634" />

- 대신 캐시 계층이 깊어질 수록 (프락시 연쇄가 길어질수록) 중간 프락시는 현저한 성능 저하 발생함

### 7.6.4 캐시망, 콘텐츠 라우팅 피어링

- 프락시 캐시는 어떤 부모 캐시와 대화할지, 요청이 캐시를 완전히 우회해 원 서버로 가게 할지 `캐시 커뮤니케이션 결정`을 동적으로 내림
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음에 나열된 일들 모두 할 수 있음

  - URL에 근거해 부모 캐시와 원 서버 중 하나를 동적으로 선택함
  - URL에 근거해 특정 부모 캐시를 동적으로 선택함
  - 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들이 캐싱된 콘텐츠에 부분적으로 접근할 수 있도록 허용함 & 캐시를 통한 인터넷 트랜짓 (Internet transit)은 허용 X

- `형제 캐시`: 선택적 피어링을 지원하는 캐시

  - HTTP는 형제 캐시 지원 X
  - 인터넷 캐시 프로토콜 (ICP)나 하이퍼텍스트 캐시 프로토콜 (HTCP)와 같은 프로토콜을 이용해 HTTP 확장함

<img width="584" alt="image" src="https://github.com/user-attachments/assets/cc59b5a1-777d-4a71-aedb-c38c79f66216" />

> Q. 선택적 피어링은 무엇이고 형제 캐시는 언제 사용되는가?

## 7.7 캐시 처리 단계

HTTP GET 메시지 처리 시 이루어지는 캐시 처리 일곱 단계

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽음
2. 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출
3. 검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아옴 (그리고 로컬에 저장한다)
4. 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어봄
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만듦
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌
7. 로깅 - 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남김

<img width="594" alt="image" src="https://github.com/user-attachments/assets/7f088a65-5cf2-4ad0-b6a3-7218dd9ef216" />

### 7.7.1 단계 1: 요청 받기

- 캐시가 네트워크 커넥션에서의 활동 감지하고, 들어오는 데이터 읽음
- 고성능 캐시는 여러 개의 들어오는 커넥션들로부터 데이터 동시에 읽어들이고, 메시지 전체가 도착하기 전에 트랜잭션 처리 시작함

### 7.7.2 단계 2: 파싱

- 요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담음

### 7.7.3 단계 3: 검색

- URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사함
- 로컬 복사본은 메모리 혹은 디스크, 근처의 다른 컴퓨터에 존재
- 로컬에서 문서를 가져오지 못하는 경우 원 서버나 부모 프락시에서 가져오거나 실패 반환함
- 캐싱된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지, 얼마나 자주 사용되었는지 등등 메타데이터 포함함

### 7.7.4 단계 4: 신선도 검사

- 신선하지 않은 문서를 제공하기 전 어떤 변경점이 있었는지 검사하기 위해 서버와 재검사함

### 7.7.5 단계 5: 응답 생성

- 캐시된 서버 응답 헤더를 토대로 응답 헤더 생성함
  - 이러한 기저 헤더들은 캐시에 의해 수정/추가됨
- 클라이언트에 맞게 헤더 조정하는 책임 가짐
  - HTTP 버전에 맞게 헤더 변역
  - 캐시 신선도 정보 삽입 (Cache-Control, Age, Expires 헤더) 으로 요청이 프락시 캐시를 거쳐갔다는 헤더 포함
- 캐시는 Date 헤더 조정하면 안됨! (원 서버에서 최초로 생겨난 일시임)

### 7.7.6 단계 6: 전송

- 응답 헤더 준비되면 클라이언트에게 전달
- 프락시 캐시는 클라이언트와 커넥션을 유지할 필요가 있음
- 고성능 캐시는 종종 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서의 콘텐츠 복사를 피해 데이터를 효과적으로 전송하기 위해 노력함

> Q. 어떻게 버퍼 사이에서 문서의 콘텐츠 복사를 피한다는건지 모르겠음

### 7.7.7 단계 7: 로깅

- 로그 파일과 캐시 사용에 대한 통계 기록
- 트랜잭션 완료 후 통계 캐시 적중과 부적중 횟수 갱신
- 요청 종류, URL, 어떤 일이 일어났는지 로그파일에 기록
- 가장 많이 사용되는 캐시 로그 포맷: 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷, 커스텀 로그 파일도 허용

### 7.7.8 캐시 처리 플로 차트

<img width="590" alt="image" src="https://github.com/user-attachments/assets/79a6bf4f-fdec-4318-ae25-8c3341e84b55" />

## 7.8 사본을 신선하게 유지하기

- 캐시된 사본 === 서버 원본이 가능하도록 해주는 매커니즘: 문서 만료와 서버 재검사

### 7.8.1 문서 만료

- Cache-Control, Expires 헤더: 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌
  - 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우함

<img width="593" alt="image" src="https://github.com/user-attachments/assets/97a0d699-723b-429b-9d0e-82d808ca23a0" />

### 7.8.2 유효기간과 나이

- HTTP/1.0+ - Expires, HTTP/1.1 - Cache-Control: max-age 헤더를 통해 유효기간 명시

<img width="597" alt="image" src="https://github.com/user-attachments/assets/6b2275bb-23d1-4904-8be9-f60619419255" />

### 7.8.3 서버 재검사

- 캐시된 문서 만료 !== 원 서버에 현재 존재하는 원본과 다르다.
- 캐시된 문서 만료 === 검사할 시간이 되었다. === 서버 재검사

- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신함

- 매 요청마다 신선도 검사할 필요 없이 문서가 만료되었을 때만 재검사 하면 됨
- 캐시가 반환해야하는 응답
  - ‘충분히 신선한’ 캐시된사본
  - 원 서버와 재검사되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
  - 에러 메시지(재검사해야 하는 원 서버가 다운된 경우)
  - 경고 메시지가 부착된 캐시된 사본(부정확하다면)

### 7.8.4 조건부 메서드와의 재검사

<img width="597" alt="image" src="https://github.com/user-attachments/assets/1447321d-9e6c-4562-bd40-50d2c34ffb4f" />
