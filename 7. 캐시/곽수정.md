# 7. 캐시

캐시의 성능 특성과 어떻게 그 성능을 측정하는지, 효과적인 사용법과 동작 과정에 대해 알아보는 챕터

## 7.1 불필요한 데이터 전송

캐시 사용 시 보관된 서버 응답을 전달해 원 서버의 중복 트래픽 낭비를 방지하는 역할을 함

## 7.2 대역폭 병목

네트워크 병목도 줄여주는 역할을 함

- 많은 네트워크가 원격 서버보다 `로컬 네트워크 클라이언트`에 더 넓은 대역폭 제공
- 클라이언트 > 서버 접근 시 경로에 있는 가장 느린 네트워크 속도와 같음
- 클라이언트 > 빠른 LAN에 있는 캐시로부터 사본 가져오는 경우 성능 대폭 개선 가능

<img width="570" alt="image" src="https://github.com/user-attachments/assets/56743327-355f-4c03-b883-d99ac1e55bcd" />

<img width="589" alt="image" src="https://github.com/user-attachments/assets/543ffd64-5816-4107-9988-4e3e1583ca98" />

## 7.3 갑작스런 요청 쇄도 (Flash Crowds)

- 갑작스런 요청 쇄도 시 불필요한 트래픽 급증 > 웹 서버의 심각한 장애 야기 가능
- 이러한 상황에서도 대처 솔루션으로써 캐싱이 중요함

## 7.4 거리로 인한 지연

- 대역폭이 아니더라도 거리로 인한 문제 발생 가능
- 모든 네트워크 라우터는 인터넷 트래픽을 지연시키지만 클라이언트 ↔️ 서버 사이의 라우터 수와 무관하게 빛의 속도에 의한 지연 유발 가능
- 보통 수준으로 복잡한 웹 페이지 = 빛의 속도로 인한 지연이 수 초에 달할 수도 있음

<img width="583" alt="image" src="https://github.com/user-attachments/assets/2ed90962-b323-4980-8311-af16f73d80f1" />

## 7.5 적중과 부적중

- **cache hit(캐시 적중)**: 수신받은 요청에 대응하는 사본 존재하는 경우
- **cache miss(캐시 부적중)**: 수신받은 요청에 대응하는 사본 존재하지 않는 경우

<img width="590" alt="image" src="https://github.com/user-attachments/assets/b0a7637c-5002-4571-bdb8-45633bcc00cd" />

### 7.5.1 재검사 (Revalidation)

- **HTTP 재검사**: 신선도 검사 = 사본이 여전히 최신인지 점검함
  - 전체 객체를 가져오지 않고도 콘텐츠가 여전히 신선한지 빠르게 검사 가능
- 캐시는 스스로 언제든지 사본 재검사 가능하지만 수백만개의 사본을 재검사 하기에는 네트워크 대역폭이 부족하기 때문에 충분히 오래된 경우에만 재검사 함

1. 사본의 재검사 필요 시 원 서버에 작은 재검사 요청 전공
2. 콘텐츠 변경 X일 경우 서버는 `304 Not Modified` 응답 보냄
3. 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선함을 임시로 표시하고 클라이언트에게 제공

- 해당 방법은 **재검사 적중** 혹은 **느린 적중**이라함
- 속도: 순수 캐시 적중 > 재검사 적중 > 캐시 부적중

<img width="583" alt="image" src="https://github.com/user-attachments/assets/91d919c0-beee-4dda-b07a-1230adcd2dec" />

**HTTP가 제공하는 캐시 재확인 도구**

- `If-Modified-Since` 헤더
  - 서버에게 보내는 GET 요청에 포함해 캐시된 시간 이후 변경된 경우에만 사본 보내달라는 의미 내포
  - 아래 3가지 케이스는 `If-Modified-Since` 요청이 서버에 도착했을 때 일어날 수 있는 상황임

1. 재검사 적중

- 서버 객체 미변경 시 HTTP `304 Not Modified` 응답 수신

<img width="580" alt="image" src="https://github.com/user-attachments/assets/ba2dff15-fc62-4544-a6c9-79aaff3ed642" />

2. 재검사 부적중

- 서버 객체가 캐시된 사본과 다른 경우 `콘텐츠 전체 + HTTP 200 OK` 응답 수신

3. 객체 삭제

- 서버 객체 삭제되었을 땐 `404 Not Found` 응답 수신 + `캐시는 사본 삭제`

### 7.5.2 적중률

- **캐시 적중률(문서 적중률)**: 캐시가 요청을 처리하는 비율
  - 0%: 모든 요청이 캐시 부적중
  - 100%: 모든 요청이 캐시 적중
  - 적중률 40%라면 웹 캐시로 괜찮은 편

### 7.5.3 바이트 적중률

- **바이트 적중률**: 캐시를 통해 제공된 모든 바이트의 비율

- **문서 적중률 vs 바이트 적중률**
  - 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌
  - 문서 적중률 개선 시 전체 대기시간 (지연) 감소 (트랜잭션 시간, e.g. TCP 커넥션 맺는 시간으로 인간 지연)
  - 바이트 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여줌
  - 바이트 단위 적중률 개선은 대역폭 절약을 최적화함

### 7.5.4 적중과 부적중의 구별

- 클라이언트는 HTTP를 통해 캐시 적중이었는지 원 서버 접근이었는지 알 방법이 없음 (둘 다 200 OK)
- 대신 응답이 캐시에서 왔는지 알 수 있는 방법
  - `Date 헤더`: 응답 생성일이 현재 시각보다 오래된 경우 캐시된 것임
  - `Age 헤더`: 응답이 얼마나 오래되었는지 알려줌

> Q. 응답 생성일은 원래 현재 시각보다 더 오래되지 않나?

## 7.6 캐시 토폴로지

- **개인 전용 캐시**: 한 명에게만 할당된 캐시
- **공용 캐시**: 사용자 집단에게 자주 쓰이는 캐시

### 7.6.1 개인 전용 캐시

- 웹 브라우저는 개인 전용 캐시 내장하고 있음
  - 자주 쓰이는 문서 > 개인용 컴퓨터의 디스크, 메모리에 저장
  - 사용자가 캐시 사이즈와 설정 수정 가능
  - 브라우저 내에 캐싱된 콘텐츠 목록 확인 가능

<img width="581" alt="image" src="https://github.com/user-attachments/assets/d872bc97-200c-41c7-aab8-f4ca148010b4" />

### 7.6.2 공용 프락시 캐시

- 공용 캐시 = 캐시 프락시 서버 = 캐시 프락시라고 불리는 특별한 종류의 공유된 프락시 서버
- 로컬 캐시에서 문서를 제공하거나, 사용자 입장에서 서버 접근함
- 여러 사용자가 접근하기 때문에 불필요한 트래픽 줄일 수 있음

<img width="582" alt="image" src="https://github.com/user-attachments/assets/e104cb31-8303-45c0-87b7-bd9a636a08da" />

- 개인 전용 캐시는 클라이언트마다 제각각 가져오기 때문에 같은 문서를 네트워크 여러번 거쳐오게 됨
- 굥용 캐시는 자주 찾는 객체 단 한번만 가져와 모든 요청에 대해 공유된 사본 사용, 네트워크 트래픽 감소

- 수동 프락시 설정 혹은 프락시 자동설정 파일 설정 > 브라우저가 프락시 캐시 사용 가능
- 인터셉트 프락시 사용해 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제 가능

### 7.6.3 프락시 캐시 계층들

- 작은 캐시에서 캐시 부적중 발생 > 더 큰 부모가 필터링된 트래픽 처리하도록 하는 계층이 합리적인 경우도 있음
- 클라이언트 주위에는 작고 저렴한 캐시 사용 & 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시 사용

<img width="582" alt="image" src="https://github.com/user-attachments/assets/dbf42e70-a9f9-43e3-b8ff-4a7587cbf634" />

- 대신 캐시 계층이 깊어질 수록 (프락시 연쇄가 길어질수록) 중간 프락시는 현저한 성능 저하 발생함

### 7.6.4 캐시망, 콘텐츠 라우팅 피어링

- 프락시 캐시는 어떤 부모 캐시와 대화할지, 요청이 캐시를 완전히 우회해 원 서버로 가게 할지 `캐시 커뮤니케이션 결정`을 동적으로 내림
- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음에 나열된 일들 모두 할 수 있음

  - URL에 근거해 부모 캐시와 원 서버 중 하나를 동적으로 선택함
  - URL에 근거해 특정 부모 캐시를 동적으로 선택함
  - 부모 캐시에 가기 전에 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들이 캐싱된 콘텐츠에 부분적으로 접근할 수 있도록 허용함 & 캐시를 통한 인터넷 트랜짓 (Internet transit)은 허용 X

- `형제 캐시`: 선택적 피어링을 지원하는 캐시

  - HTTP는 형제 캐시 지원 X
  - 인터넷 캐시 프로토콜 (ICP)나 하이퍼텍스트 캐시 프로토콜 (HTCP)와 같은 프로토콜을 이용해 HTTP 확장함

<img width="584" alt="image" src="https://github.com/user-attachments/assets/cc59b5a1-777d-4a71-aedb-c38c79f66216" />

> Q. 선택적 피어링은 무엇이고 형제 캐시는 언제 사용되는가?
