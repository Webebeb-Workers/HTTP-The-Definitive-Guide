# 7. 캐시

- 웹 캐시는 자주 사용되는 문서의 로컬 사본을 저장하여 원 서버 대신 제공함으로써, 네트워크 비용과 지연시간을 줄이고 서버 부하를 감소시키는 HTTP 장치

## 7.1 불필요한 데이터 전송

- 서버가 동일한 문서를 여러 클라이언트에게 반복해서 전송하는 낭비를 줄여줌
- 첫 번째 서버 응답을 저장해 두었다가 이후 요청들에 재사용함으로써 네트워크 트래픽과 서버 부하를 감소시킴

## 7.2 대역폭 병목

**네트워크 대역폭**

- 데이터가 전송될 수 있는 통로의 '너비'

**네트워크 환경**

- 로컬 네트워크는 원격 서버보다 더 넓은 대역폭 제공
- 네트워크 속도는 경로상 가장 느린 구간의 속도로 제한됨

**캐시의 이점**

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/e6c75c7b-df89-4e19-a9da-3ffe04ea3aab" />

- 로컬 네트워크의 캐시를 활용하면 빠른 속도로 데이터 접근 가능
- ex) 샌프란시스코 지사에 있는 사용자는 애틀랜타의 본사로부터 5MB 크기의 물품 목록 파일을 받는데 30초가 걸릴 수 있음, 만약 문서가 샌프란시스코의 사무실에 캐시되어 있다면, 로컬 사용자는 같은 문서를 이더넷 접속을 통해 1초 미만의 시간에 가져올 수 있음

**대역폭과 전송 시간의 관계**

- 대역폭은 네트워크 속도와 문서 크기에 따라 전송 시간에 영향을 줌

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/680e454f-64d7-4001-a2fd-ddff1dfdd207" />

> 트래픽, 네트워크, 네트워크 속도, 대역폭 이 뭘까?

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 정의: 갑작스런 사건(뉴스 속보, 스팸 메일, 유명 인사 관련 사건 등)으로 많은 사람이 동시에 특정 웹 문서에 접근하는 현상
- 영향: 급격한 트래픽 증가로 네트워크와 서버 장애 야기
- 해결책: 캐싱

## 7.4 거리로 인한 지연

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c41e2885-3766-4318-9068-e77f9609abe0" />

**발생 원인**

- 모든 네트워크 라우터는 인터넷 트래픽을 지연시킴
- 빛의 속도로 인한 물리적 한계
  - 보스턴-샌프란시스코(4,400km): 왕복 30밀리초
  - 보스턴-샌프란시스코, 4개의 커넥션, 20개 이미지가 있는 웹페이지: 240밀리초의 지연
  - 보스턴-도쿄(10,800km), 4개의 커넥션, 20개 이미지가 있는 웹페이지: 600밀리초의 지연

**해결책**

- 근거리에 캐시 설치해서 문서가 전송되는 거리를 수천km → 수십m로 줄이기

## 7.5 적중과 부적중

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/41699872-62ee-4a3e-99ac-beb19a1f8599" />

**캐시 적중(Cache Hit)**

- 요청한 문서의 사본이 캐시에 있음
- 캐시에서 바로 응답 가능

**캐시 부적중(Cache Miss)**

- 요청한 문서의 사본이 캐시에 없음
- 원 서버로 요청을 전달해야 함

### 7.5.1 재검사(Revalidation)

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/050603c7-55e8-416d-903f-00237fb28c78" />

**필요성**

- 원 서버의 콘텐츠가 변경될 수 있어서 캐시된 데이터의 신선도 확인 필요

**작동 방식**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/68c7b6d3-12af-499a-bfea-1c4d7efe3716" />

- 전체 객체를 다시 받지 않고 신선도만 빠르게 확인
- If-Modified-Since 헤더 추가해서 서버에 요청,
  - 재검사 부적중: 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄
  - 재검사 적중: 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답 보냄
  - 객체 삭제: 만약 서버 객체가 삭제됐다면, 서버는 404 Not Found 응답을 보내고 캐시는 사본을 삭제함

**재검사 시점**

- 클라이언트 요청 시점
- 캐시된 데이터가 충분히 오래되었을 때

**재검사 적중(느린 적중)**

- 서버 확인 필요하기 때문에 순수 캐시 적중보다는 느림
- 서버로부터 객체 데이터 받아올 필요가 없기 때문에 캐시 부적중보다는 빠름

### 7.5.2 적중률(문서 적중률, 캐시 적중률)

**정의**

- 캐시가 요청을 처리하는 비율
- 0(0%) ~ 1(100%) 사이의 값

**영향 요소**

- 캐시 크기
- 사용자들의 관심사 유사도
- 데이터 변경/개인화 빈도
- 캐시 설정

**현실적 성능**

- 40% 정도면 괜찮은 수준
- 보통 크기의 캐시로도 트래픽 감소와 성능 개선 가능

### 7.5.3 바이트 적중률

**바이트 적중률**

- 캐시로 제공된 모든 바이트의 비율
- 실제 트래픽 절감 정도를 정확히 반영
- 대역폭 절약 측정에 유용

**두 지표의 차이점**

문서 적중률: 트랜잭션 횟수와 관련 → 지연 시간 개선 가능
바이트 적중률: 실제 데이터량과 관련 → 대역폭 절약 최적화 가능

**중요성**

두 지표 모두 캐시 성능 평가에 필요
각각 다른 관점의 성능을 보여줌

### 7.5.4 적중과 부적중의 구별

**HTTP의 한계**

- 응답이 캐시에서 왔는지 서버에서 왔는지 직접적으로 알려주지 않음
- 둘 다 200 OK 응답 코드 사용

**구별 방법**

- Via 헤더: 일부 프락시 캐시는 추가 정보 제공
- Date 헤더: 응답 생성 시각과 현재 시각 비교
- Age 헤더: 응답이 얼마나 오래되었는지 표시

## 7.6 캐시 토폴로지

<img width="425" alt="Image" src="https://github.com/user-attachments/assets/7fdf0324-106e-46bc-9d3f-6c5478c0928d" />

### 7.6.1 개인 전용 캐시(Private Cache)

**정의**

- 한 명의 사용자 전용, 한 명에게만 할당된 캐시
- 개인만을 위한 캐시로, 한 명의 사용자가 자주 찾는 페이지를 담음

**장점**

- 많은 에너지나 저장 공간 필요하지 않으므로, 작고 저렴함

**브라우저 캐시 특징**

- 웹브라우저는 개인 전용 캐시를 내장하고 있음
- 자주 쓰이는 문서를 컴퓨터의 디스크와 메모리에 캐시해 놓음
- 사용자가 캐시 사이즈와 설정 조정 가능
- 캐시 내용 확인 가능
  - 인터넷 익스플로러: 도구 > 인터넷 옵션 > 검색 기록 > 설정 > 파일 보기에서 캐시 콘텐츠 얻을 수 있음
  - 구글 크롬: 특별한 URL인 about:cache를 통해 연결되는 페이지에서 캐시 콘텐츠 목록 볼 수 있음

> 요즘에는 어떻게 볼 수 있지?

### 7.6.2 공용 프락시 캐시(Public Cache)

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c4a7c7b6-8812-4f0e-bc47-dc0841e7db80" />

**정의**

- '프락시 캐시' 또는 '캐시 프락시 서버'라고 불림
- 여러 사용자가 공유하는 캐시 서버로, 사용자 집단이 자주 찾는 페이지 저장

**장점**

- 공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 더 많이 줄일 수 있음

**설정 방법**

- 브라우저에 수동 프락시 지정 또는 프락시 자동설정 파일 사용(6장 클라이언트의 프락시설정: 수동) -> 브라우저가 프락시 캐시 사용하도록 설정
- 인터셉트 프락시 사용 -> 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제

### 7.6.3 프락시 캐시 계층들

<img width="424" alt="Image" src="https://github.com/user-attachments/assets/b21dd14c-d778-4390-bd84-c4b476da4af3" />

**기본 구조**

- 작은 캐시(1단계) → 큰 캐시(상위 단계)

**작동 방식**

- 1단계: 작고 저렴한 로컬 캐시 사용
- 2단계: 더 크고 강력한 공유 캐시 사용
- 하위 캐시 실패 시 상위 캐시에서 처리

**주의점**

- 캐시 계층이 깊어지면 성능 저하 발생
- 프락시 연쇄가 길수록 속도 감소

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

**캐시망의 특징**

- 단순한 캐시 계층 구조가 아닌 복잡한 캐시망
- 캐시들 간 동적 통신과 결정: 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내림

**주요 기능**

- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 아래 일을 할 수 있음
  - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아보기
  - 제한적 캐시 접근 허용: 다른 캐시 서버들이 우리 캐시에 저장된 데이터는 사용할 수 있지만, 우리 캐시 서버를 통해 외부 인터넷에 접속하는 것은 허용하지 않음

**형제 캐시(Brother Cache)**

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/7dc59288-930d-40ff-814b-84000d212c55" />

- 서로 다른 조직들이 상호 이득을 위해 캐시를 연결하여 서로를 찾아볼 수 있도록 함
- HTTP는 형제 캐시를 지원하지 않아서, 인터넷 캐시 프로토콜(ICP), 하이퍼텍스트 캐시 프로토콜(HTCP) 등 특별 프로토콜 사용해 HTTP를 확장함 (20장 자세히)
