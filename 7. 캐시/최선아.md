# 7. 캐시

- 웹 캐시는 자주 사용되는 문서의 로컬 사본을 저장하여 원 서버 대신 제공함으로써, 네트워크 비용과 지연시간을 줄이고 서버 부하를 감소시키는 HTTP 장치

## 7.1 불필요한 데이터 전송

- 서버가 동일한 문서를 여러 클라이언트에게 반복해서 전송하는 낭비를 줄여줌
- 첫 번째 서버 응답을 저장해 두었다가 이후 요청들에 재사용함으로써 네트워크 트래픽과 서버 부하를 감소시킴

## 7.2 대역폭 병목

**네트워크 대역폭**

- 데이터가 전송될 수 있는 통로의 '너비'

**네트워크 환경**

- 로컬 네트워크는 원격 서버보다 더 넓은 대역폭 제공
- 네트워크 속도는 경로상 가장 느린 구간의 속도로 제한됨

**캐시의 이점**

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/e6c75c7b-df89-4e19-a9da-3ffe04ea3aab" />

- 로컬 네트워크의 캐시를 활용하면 빠른 속도로 데이터 접근 가능
- ex) 샌프란시스코 지사에 있는 사용자는 애틀랜타의 본사로부터 5MB 크기의 물품 목록 파일을 받는데 30초가 걸릴 수 있음, 만약 문서가 샌프란시스코의 사무실에 캐시되어 있다면, 로컬 사용자는 같은 문서를 이더넷 접속을 통해 1초 미만의 시간에 가져올 수 있음

**대역폭과 전송 시간의 관계**

- 대역폭은 네트워크 속도와 문서 크기에 따라 전송 시간에 영향을 줌

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/680e454f-64d7-4001-a2fd-ddff1dfdd207" />

> 트래픽, 네트워크, 네트워크 속도, 대역폭 이 뭘까?

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 정의: 갑작스런 사건(뉴스 속보, 스팸 메일, 유명 인사 관련 사건 등)으로 많은 사람이 동시에 특정 웹 문서에 접근하는 현상
- 영향: 급격한 트래픽 증가로 네트워크와 서버 장애 야기
- 해결책: 캐싱

## 7.4 거리로 인한 지연

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c41e2885-3766-4318-9068-e77f9609abe0" />

**발생 원인**

- 모든 네트워크 라우터는 인터넷 트래픽을 지연시킴
- 빛의 속도로 인한 물리적 한계
  - 보스턴-샌프란시스코(4,400km): 왕복 30밀리초
  - 보스턴-샌프란시스코, 4개의 커넥션, 20개 이미지가 있는 웹페이지: 240밀리초의 지연
  - 보스턴-도쿄(10,800km), 4개의 커넥션, 20개 이미지가 있는 웹페이지: 600밀리초의 지연

**해결책**

- 근거리에 캐시 설치해서 문서가 전송되는 거리를 수천km → 수십m로 줄이기

## 7.5 적중과 부적중

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/41699872-62ee-4a3e-99ac-beb19a1f8599" />

**캐시 적중(Cache Hit)**

- 요청한 문서의 사본이 캐시에 있음
- 캐시에서 바로 응답 가능

**캐시 부적중(Cache Miss)**

- 요청한 문서의 사본이 캐시에 없음
- 원 서버로 요청을 전달해야 함

### 7.5.1 재검사(Revalidation)

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/050603c7-55e8-416d-903f-00237fb28c78" />

**필요성**

- 원 서버의 콘텐츠가 변경될 수 있어서 캐시된 데이터의 신선도 확인 필요

**작동 방식**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/68c7b6d3-12af-499a-bfea-1c4d7efe3716" />

- 전체 객체를 다시 받지 않고 신선도만 빠르게 확인
- If-Modified-Since 헤더 추가해서 서버에 요청,
  - 재검사 부적중: 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄
  - 재검사 적중: 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답 보냄
  - 객체 삭제: 만약 서버 객체가 삭제됐다면, 서버는 404 Not Found 응답을 보내고 캐시는 사본을 삭제함

**재검사 시점**

- 클라이언트 요청 시점
- 캐시된 데이터가 충분히 오래되었을 때

**재검사 적중(느린 적중)**

- 서버 확인 필요하기 때문에 순수 캐시 적중보다는 느림
- 서버로부터 객체 데이터 받아올 필요가 없기 때문에 캐시 부적중보다는 빠름

### 7.5.2 적중률(문서 적중률, 캐시 적중률)

**정의**

- 캐시가 요청을 처리하는 비율
- 0(0%) ~ 1(100%) 사이의 값

**영향 요소**

- 캐시 크기
- 사용자들의 관심사 유사도
- 데이터 변경/개인화 빈도
- 캐시 설정

**현실적 성능**

- 40% 정도면 괜찮은 수준
- 보통 크기의 캐시로도 트래픽 감소와 성능 개선 가능

### 7.5.3 바이트 적중률

**바이트 적중률**

- 캐시로 제공된 모든 바이트의 비율
- 실제 트래픽 절감 정도를 정확히 반영
- 대역폭 절약 측정에 유용

**두 지표의 차이점**

문서 적중률: 트랜잭션 횟수와 관련 → 지연 시간 개선 가능
바이트 적중률: 실제 데이터량과 관련 → 대역폭 절약 최적화 가능

**중요성**

두 지표 모두 캐시 성능 평가에 필요
각각 다른 관점의 성능을 보여줌

### 7.5.4 적중과 부적중의 구별

**HTTP의 한계**

- 응답이 캐시에서 왔는지 서버에서 왔는지 직접적으로 알려주지 않음
- 둘 다 200 OK 응답 코드 사용

**구별 방법**

- Via 헤더: 일부 프락시 캐시는 추가 정보 제공
- Date 헤더: 응답 생성 시각과 현재 시각 비교
- Age 헤더: 응답이 얼마나 오래되었는지 표시

## 7.6 캐시 토폴로지

<img width="425" alt="Image" src="https://github.com/user-attachments/assets/7fdf0324-106e-46bc-9d3f-6c5478c0928d" />

### 7.6.1 개인 전용 캐시(Private Cache)

**정의**

- 한 명의 사용자 전용, 한 명에게만 할당된 캐시
- 개인만을 위한 캐시로, 한 명의 사용자가 자주 찾는 페이지를 담음

**장점**

- 많은 에너지나 저장 공간 필요하지 않으므로, 작고 저렴함

**브라우저 캐시 특징**

- 웹브라우저는 개인 전용 캐시를 내장하고 있음
- 자주 쓰이는 문서를 컴퓨터의 디스크와 메모리에 캐시해 놓음
- 사용자가 캐시 사이즈와 설정 조정 가능
- 캐시 내용 확인 가능
  - 인터넷 익스플로러: 도구 > 인터넷 옵션 > 검색 기록 > 설정 > 파일 보기에서 캐시 콘텐츠 얻을 수 있음
  - 구글 크롬: 특별한 URL인 about:cache를 통해 연결되는 페이지에서 캐시 콘텐츠 목록 볼 수 있음

> 요즘에는 어떻게 볼 수 있지?

### 7.6.2 공용 프락시 캐시(Public Cache)

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c4a7c7b6-8812-4f0e-bc47-dc0841e7db80" />

**정의**

- '프락시 캐시' 또는 '캐시 프락시 서버'라고 불림
- 여러 사용자가 공유하는 캐시 서버로, 사용자 집단이 자주 찾는 페이지 저장

**장점**

- 공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 더 많이 줄일 수 있음

**설정 방법**

- 브라우저에 수동 프락시 지정 또는 프락시 자동설정 파일 사용(6장 클라이언트의 프락시설정: 수동) -> 브라우저가 프락시 캐시 사용하도록 설정
- 인터셉트 프락시 사용 -> 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제

### 7.6.3 프락시 캐시 계층들

<img width="424" alt="Image" src="https://github.com/user-attachments/assets/b21dd14c-d778-4390-bd84-c4b476da4af3" />

**기본 구조**

- 작은 캐시(1단계) → 큰 캐시(상위 단계)

**작동 방식**

- 1단계: 작고 저렴한 로컬 캐시 사용
- 2단계: 더 크고 강력한 공유 캐시 사용
- 하위 캐시 실패 시 상위 캐시에서 처리

**주의점**

- 캐시 계층이 깊어지면 성능 저하 발생
- 프락시 연쇄가 길수록 속도 감소

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

**캐시망의 특징**

- 단순한 캐시 계층 구조가 아닌 복잡한 캐시망
- 캐시들 간 동적 통신과 결정: 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내림

**주요 기능**

- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 아래 일을 할 수 있음
  - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아보기
  - 제한적 캐시 접근 허용: 다른 캐시 서버들이 우리 캐시에 저장된 데이터는 사용할 수 있지만, 우리 캐시 서버를 통해 외부 인터넷에 접속하는 것은 허용하지 않음

**형제 캐시(Brother Cache)**

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/7dc59288-930d-40ff-814b-84000d212c55" />

- 서로 다른 조직들이 상호 이득을 위해 캐시를 연결하여 서로를 찾아볼 수 있도록 함
- HTTP는 형제 캐시를 지원하지 않아서, 인터넷 캐시 프로토콜(ICP), 하이퍼텍스트 캐시 프로토콜(HTCP) 등 특별 프로토콜 사용해 HTTP를 확장함 (20장 자세히)

## 7.7 캐시 처리 단계

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/ce223b05-475d-4d27-9514-da5f6896cc0e" />

- HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져있음:

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽음
2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아오고 저장
4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어봄
5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만듬
6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌
7. 로깅: 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남김

### 7.7.1 단계 1: 요청 받기

- 캐시가 네트워크에서 들어오는 데이터를 감지하고 읽기 시작함
- 고성능 캐시는 여러 커넥션에서 동시에 데이터를 읽어들여, 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작함

> 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다는게 무슨 소리지?

### 7.7.2 단계 2: 파싱

- 캐시가 요청 메시지를 파싱하여 헤더를 조작하기 쉬운 자료 구조에 담음
- 이를 통해 캐싱 소프트웨어가 헤더 필드를 효율적으로 처리하고 조작할 수 있게 됨

### 7.7.3 단계 3: 검색

- 캐시가 URL에 해당하는 로컬 사본이 있는지 확인함
- 로컬 복사본은 메모리, 디스크, 또는 근처의 다른 컴퓨터에 있을 수 있음
- 고급 캐시는 빠른 알고리즘을 사용하여 로컬 캐시에서 객체를 찾고, 없으면 원 서버나 부모 프락시에서 가져오거나 실패를 반환함
- 캐시된 객체에는 서버 응답 본문과 헤더, 그리고 메타데이터(캐시된 시간, 사용 빈도 등)가 포함됨

> 고급 캐시는 어떤 빠른 알고리즘을 사용하는거지?

### 7.7.4 단계 4: 신선도 검사

- 캐시된 문서는 일정 기간 동안 신선하다고 간주되며, 이 기간 동안 서버와의 접촉 없이 제공할 수 있음
- 그러나 신선도 한계를 넘으면 문서는 '신선하지 않은' 것으로 간주되어, 캐시는 서버와 재검사를 통해 문서의 변경 여부를 확인해야 함
- 신선도 검사 규칙은 복잡하며, 다양한 설정 옵션과 비 HTTP 신선도 표준과의 상호작용으로 더더욱 복잡해짐

### 7.7.5 단계 5: 응답 생성

- 캐시는 캐시된 서버 응답 헤더를 기반으로 응답 헤더를 생성하여, 원 서버에서 온 것처럼 보이도록 함
- 캐시는 클라이언트에 맞게 해더를 조정해야함. 예를 들어 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했으면 적절하게 번역해야 함
- 캐시는 신선도 정보를 삽입하며(예: Cache-Control, Age, Expires), 요청이 프락시 캐시를 거쳤음을 알리기 위해 Via 헤더를 포함할 수 있음
- 단, Date 헤더는 객체가 원 서버에서 최초로 생성된 시간을 나타내므로 캐시가 수정해서는 안됨

### 7.7.6 단계 6: 전송

- 응답 헤더가 준비되면 캐시가 클라이언트에게 응답을 전송함
- 고성능 캐시는 네트워크 I/O 버퍼와 로컬 저장장치 사이에서 문서 내용을 복사하지 않고, 데이터를 효과적으로 전송하려고 노력함
- 프락시 캐시는 클라이언트와의 커넥션을 유지해야 함

> 두 번째 꺼 무슨 소리지??

### 7.7.7 단계 7: 로깅

- 캐시는 로그 파일과 캐시 사용 통계를 유지함
- 트랜잭션이 완료된 후, 캐시는 캐시 적중과 부적중 횟수 등을 갱신하고, 로그 파일에 요청 종류, URL, 발생한 상황 등을 기록함
- 가장 많이 사용되는 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만, 많은 캐시 제품이 커스텀 로그 파일을 지원함

### 7.7.8 캐시 처리 플로 차트

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/a9b26899-6a75-42b5-a360-ad492d3aa94e" />

## 7.8 사본을 신선하게 유지하기

- 캐시된 사본이 서버의 문서와 항상 일치하지 않을 수 있음
- 문서는 시간이 지나면서 변경되므로, 캐시된 데이터는 서버의 최신 데이터와 일치하도록 관리되어야 함
- HTTP는 캐시된 사본을 서버와 일치하도록 유지하기 위해 문서 만료와 서버 재검사라는 간단한 메커니즘을 제공함

### 7.8.1 문서 만료

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/1cc24076-0f41-4e8e-96ec-74ecfed5a3ad" />

- HTTP는 Cache-Control과 Expires 헤더를 사용하여 원 서버가 각 문서에 유효기간을 설정할 수 있도록 해줌
- 캐시된 문서는 만료되기 전에는 서버와의 접촉 없이 제공될 수 있지만, 만약 문서가 만료되면 캐시는 서버와 재검사를 통해 변경사항을 확인하고 신선한 사본을 받아와야 함

### 7.8.2 유효기간과 나이

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/cbc2a770-8ebc-4094-b340-9e04f3415847" />

- 서버는 HTTP 응답 본문에 Expires 또는 Cache-Control: max-age 헤더를 사용하여 문서의 유효기간을 설정하는 방법을 설명함
- Expires는 절대 시간을, Cache-Control: max-age는 상대 시간을 초 단위로 명시함.
- 예) 2002년 6월 29일 오전 9시 30분에 (5일 뒤) 만료되는 페이지를 설정할 때,
  - Expires 헤더는 "Fri, 05 Jul 2002, 05:00:00 GMT"로 설정될 수 있음
  - Cache-Control: max-age=484200는 5일을 초로 환산한 값을 사용함

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은, 해당 문서가 원 서버와 실제로 다르다는 것이 아니라 같은지 다른지 검사할 시간임을 뜻함
- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 새로운 사본을 가져와 저장하고 클라이언트에 전달함
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 헤더만 갱신하고 기존 사본을 유지함
- 이는 서버 트래픽을 절약하고 사용자 응답 시간을 개선하는 방식으로, 캐시는 문서의 신선도를 매번 검증하지 않고 문서가 만료됐을 때만 재검사를 수행함

### 7.8.4 조건부 메서드와의 재검사

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/b6df089a-f1dc-4846-82b0-d9c0e218174a" />

- HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해줌
- 이 요청은 서버가 캐시와 다른 문서를 가지고 있을 때만 객체 본문을 반환하도록 함
- 조건부 GET은 If-Modified-Since와 If-None-Match 헤더를 통해 작동하며, 이 헤더들은 서버가 문서의 수정 여부나 태그가 일치하는지 확인한 후에 응답을 반환함
- 이를 통해 효율적인 캐시 재검사가 가능해짐

### 7.8.5 If-Modified-Since: 날짜 재검사

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/c1937a53-ba0b-4485-911a-29611e372e24" />

```
If-Modified-Since: ＜캐시된마지막수정일＞
```

- 캐시된 문서가 특정 날짜 이후로 변경되었는지를 확인하는 HTTP 조건부 헤더임
- 이 요청은 서버에게 문서가 변경된 경우에만 본문을 보내달라고 요청함
- 만약 변경되지 않았다면, 서버는 304 Not Modified 응답을 보내며 본문을 포함하지 않음. 이때 응답은 갱신이 필요한 정보만 제공됨, 예를 들어 새 만료 날짜 같은 정보는 보내줌
- If-Modified-Since 헤더는 Last-Modified 서버 응답 헤더와 함께 동작하며, 서버는 문서의 최신 수정 일시를 기준으로 재검사를 진행함
- 일부 웹 서버는 If-Modified-Since 헤더를 실제 날짜 비교 대신 문자열 비교로 처리하여, 정확히 일치하지 않으면 변경된 것으로 간주함

> 마지막 문장 이해 못함...시간을 나타내는 문자열이니 실제 날짜 비교나 문자열 비교나 같은 것 아닌가...?

### 7.8.6 If-None-Match: 엔터티 태그 재검사

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/fed28523-065a-47c8-a96d-b9c07bc89eb2" />

- If-None-Match 헤더는 서버의 엔터티 태그(ETag)를 활용하여 캐시 문서가 변경되었는지 확인하는 방법임
- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황에서 유용하게 사용됨
- 엔터티 태그는 문서의 버전 정보를 나타내며, 서버는 문서가 변경될 때마다 새로운 엔터티 태그를 부여함
- 클라이언트는 If-None-Match 헤더를 통해 서버에게 캐시된 문서의 엔터티 태그를 보내고, 서버는 해당 태그가 현재 문서의 태그와 다를 경우에만 새 문서를 반환함
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있음
  ```
  If-None-Match: "v2.6"
  If-None-Match: "v2•4","v2.5","v2.6"
  If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
  ```

### 7.8.7 ETag - 약한 검사기와 강한 검사기

- 강한 검사기: 콘텐츠가 변경되면 엔터티 태그도 반드시 변경됨. 변경된 내용이 없으면 태그도 변하지 않음
- 약한 검사기: 콘텐츠의 중요하지 않은 변경은 허용되지만, 의미 있는 변경이 있을 경우 태그도 변경됨. `W/` 접두사를 사용하여 약한 검사기를 구분함
  ```
  ETag: W/"v2.6"
  If-None-Match: W/"v2.6"
  ```
- 서버는 약한 검사기를 사용하여 작은 변경을 허용하고, 강한 검사기를 사용하여 큰 변경을 정확히 반영함

> 캐시에서 약한 엔터티 태그일 때 '변경'또는 '변경하지 않음'을 설정할 수 있는건가?

### 언제 ETag를 사용하고 언제 Last-Modified 일시를 사용하는가

- 엔터티 태그가 제공되면 클라이언트는 이를 반드시 사용하여 검사를 해야 하고, Last-Modified 값만 제공되면 If-Modified-Since를 사용해야 함
- 두 값이 모두 제공되면, 클라이언트는 두 가지 검사 정책을 모두 사용해서 HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 해야 함
- HTTP/1.1 서버는 엔터티 태그를 보내야 하며, 가능하면 약한 엔터티 태그는 Last-Modified 값을 함께 보내는 것이 좋음
- 만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안됨
