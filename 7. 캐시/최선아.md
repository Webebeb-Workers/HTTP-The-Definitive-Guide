# 7. 캐시

- 웹 캐시는 자주 사용되는 문서의 로컬 사본을 저장하여 원 서버 대신 제공함으로써, 네트워크 비용과 지연시간을 줄이고 서버 부하를 감소시키는 HTTP 장치

## 7.1 불필요한 데이터 전송

- 서버가 동일한 문서를 여러 클라이언트에게 반복해서 전송하는 낭비를 줄여줌
- 첫 번째 서버 응답을 저장해 두었다가 이후 요청들에 재사용함으로써 네트워크 트래픽과 서버 부하를 감소시킴

## 7.2 대역폭 병목

**네트워크 대역폭**

- 데이터가 전송될 수 있는 통로의 '너비'

**네트워크 환경**

- 로컬 네트워크는 원격 서버보다 더 넓은 대역폭 제공
- 네트워크 속도는 경로상 가장 느린 구간의 속도로 제한됨

**캐시의 이점**

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/e6c75c7b-df89-4e19-a9da-3ffe04ea3aab" />

- 로컬 네트워크의 캐시를 활용하면 빠른 속도로 데이터 접근 가능
- ex) 샌프란시스코 지사에 있는 사용자는 애틀랜타의 본사로부터 5MB 크기의 물품 목록 파일을 받는데 30초가 걸릴 수 있음, 만약 문서가 샌프란시스코의 사무실에 캐시되어 있다면, 로컬 사용자는 같은 문서를 이더넷 접속을 통해 1초 미만의 시간에 가져올 수 있음

**대역폭과 전송 시간의 관계**

- 대역폭은 네트워크 속도와 문서 크기에 따라 전송 시간에 영향을 줌

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/680e454f-64d7-4001-a2fd-ddff1dfdd207" />

> 트래픽, 네트워크, 네트워크 속도, 대역폭 이 뭘까?

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 정의: 갑작스런 사건(뉴스 속보, 스팸 메일, 유명 인사 관련 사건 등)으로 많은 사람이 동시에 특정 웹 문서에 접근하는 현상
- 영향: 급격한 트래픽 증가로 네트워크와 서버 장애 야기
- 해결책: 캐싱

## 7.4 거리로 인한 지연

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c41e2885-3766-4318-9068-e77f9609abe0" />

**발생 원인**

- 모든 네트워크 라우터는 인터넷 트래픽을 지연시킴
- 빛의 속도로 인한 물리적 한계
  - 보스턴-샌프란시스코(4,400km): 왕복 30밀리초
  - 보스턴-샌프란시스코, 4개의 커넥션, 20개 이미지가 있는 웹페이지: 240밀리초의 지연
  - 보스턴-도쿄(10,800km), 4개의 커넥션, 20개 이미지가 있는 웹페이지: 600밀리초의 지연

**해결책**

- 근거리에 캐시 설치해서 문서가 전송되는 거리를 수천km → 수십m로 줄이기

## 7.5 적중과 부적중

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/41699872-62ee-4a3e-99ac-beb19a1f8599" />

**캐시 적중(Cache Hit)**

- 요청한 문서의 사본이 캐시에 있음
- 캐시에서 바로 응답 가능

**캐시 부적중(Cache Miss)**

- 요청한 문서의 사본이 캐시에 없음
- 원 서버로 요청을 전달해야 함

### 7.5.1 재검사(Revalidation)

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/050603c7-55e8-416d-903f-00237fb28c78" />

**필요성**

- 원 서버의 콘텐츠가 변경될 수 있어서 캐시된 데이터의 신선도 확인 필요

**작동 방식**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/68c7b6d3-12af-499a-bfea-1c4d7efe3716" />

- 전체 객체를 다시 받지 않고 신선도만 빠르게 확인
- If-Modified-Since 헤더 추가해서 서버에 요청,
  - 재검사 부적중: 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄
  - 재검사 적중: 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 HTTP 304 Not Modified 응답 보냄
  - 객체 삭제: 만약 서버 객체가 삭제됐다면, 서버는 404 Not Found 응답을 보내고 캐시는 사본을 삭제함

**재검사 시점**

- 클라이언트 요청 시점
- 캐시된 데이터가 충분히 오래되었을 때

**재검사 적중(느린 적중)**

- 서버 확인 필요하기 때문에 순수 캐시 적중보다는 느림
- 서버로부터 객체 데이터 받아올 필요가 없기 때문에 캐시 부적중보다는 빠름

### 7.5.2 적중률(문서 적중률, 캐시 적중률)

**정의**

- 캐시가 요청을 처리하는 비율
- 0(0%) ~ 1(100%) 사이의 값

**영향 요소**

- 캐시 크기
- 사용자들의 관심사 유사도
- 데이터 변경/개인화 빈도
- 캐시 설정

**현실적 성능**

- 40% 정도면 괜찮은 수준
- 보통 크기의 캐시로도 트래픽 감소와 성능 개선 가능

### 7.5.3 바이트 적중률

**바이트 적중률**

- 캐시로 제공된 모든 바이트의 비율
- 실제 트래픽 절감 정도를 정확히 반영
- 대역폭 절약 측정에 유용

**두 지표의 차이점**

문서 적중률: 트랜잭션 횟수와 관련 → 지연 시간 개선 가능
바이트 적중률: 실제 데이터량과 관련 → 대역폭 절약 최적화 가능

**중요성**

두 지표 모두 캐시 성능 평가에 필요
각각 다른 관점의 성능을 보여줌

### 7.5.4 적중과 부적중의 구별

**HTTP의 한계**

- 응답이 캐시에서 왔는지 서버에서 왔는지 직접적으로 알려주지 않음
- 둘 다 200 OK 응답 코드 사용

**구별 방법**

- Via 헤더: 일부 프락시 캐시는 추가 정보 제공
- Date 헤더: 응답 생성 시각과 현재 시각 비교
- Age 헤더: 응답이 얼마나 오래되었는지 표시

## 7.6 캐시 토폴로지

<img width="425" alt="Image" src="https://github.com/user-attachments/assets/7fdf0324-106e-46bc-9d3f-6c5478c0928d" />

### 7.6.1 개인 전용 캐시(Private Cache)

**정의**

- 한 명의 사용자 전용, 한 명에게만 할당된 캐시
- 개인만을 위한 캐시로, 한 명의 사용자가 자주 찾는 페이지를 담음

**장점**

- 많은 에너지나 저장 공간 필요하지 않으므로, 작고 저렴함

**브라우저 캐시 특징**

- 웹브라우저는 개인 전용 캐시를 내장하고 있음
- 자주 쓰이는 문서를 컴퓨터의 디스크와 메모리에 캐시해 놓음
- 사용자가 캐시 사이즈와 설정 조정 가능
- 캐시 내용 확인 가능
  - 인터넷 익스플로러: 도구 > 인터넷 옵션 > 검색 기록 > 설정 > 파일 보기에서 캐시 콘텐츠 얻을 수 있음
  - 구글 크롬: 특별한 URL인 about:cache를 통해 연결되는 페이지에서 캐시 콘텐츠 목록 볼 수 있음

> 요즘에는 어떻게 볼 수 있지?

### 7.6.2 공용 프락시 캐시(Public Cache)

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/c4a7c7b6-8812-4f0e-bc47-dc0841e7db80" />

**정의**

- '프락시 캐시' 또는 '캐시 프락시 서버'라고 불림
- 여러 사용자가 공유하는 캐시 서버로, 사용자 집단이 자주 찾는 페이지 저장

**장점**

- 공용 캐시에는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 더 많이 줄일 수 있음

**설정 방법**

- 브라우저에 수동 프락시 지정 또는 프락시 자동설정 파일 사용(6장 클라이언트의 프락시설정: 수동) -> 브라우저가 프락시 캐시 사용하도록 설정
- 인터셉트 프락시 사용 -> 브라우저 설정 없이 HTTP 요청이 캐시를 통하도록 강제

### 7.6.3 프락시 캐시 계층들

<img width="424" alt="Image" src="https://github.com/user-attachments/assets/b21dd14c-d778-4390-bd84-c4b476da4af3" />

**기본 구조**

- 작은 캐시(1단계) → 큰 캐시(상위 단계)

**작동 방식**

- 1단계: 작고 저렴한 로컬 캐시 사용
- 2단계: 더 크고 강력한 공유 캐시 사용
- 하위 캐시 실패 시 상위 캐시에서 처리

**주의점**

- 캐시 계층이 깊어지면 성능 저하 발생
- 프락시 연쇄가 길수록 속도 감소

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

**캐시망의 특징**

- 단순한 캐시 계층 구조가 아닌 복잡한 캐시망
- 캐시들 간 동적 통신과 결정: 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화하여, 어떤 부모 캐시와 대화할 것인지, 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할 것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내림

**주요 기능**

- 캐시망 안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 아래 일을 할 수 있음
  - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL에 근거하여 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아보기
  - 제한적 캐시 접근 허용: 다른 캐시 서버들이 우리 캐시에 저장된 데이터는 사용할 수 있지만, 우리 캐시 서버를 통해 외부 인터넷에 접속하는 것은 허용하지 않음

**형제 캐시(Brother Cache)**

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/7dc59288-930d-40ff-814b-84000d212c55" />

- 서로 다른 조직들이 상호 이득을 위해 캐시를 연결하여 서로를 찾아볼 수 있도록 함
- HTTP는 형제 캐시를 지원하지 않아서, 인터넷 캐시 프로토콜(ICP), 하이퍼텍스트 캐시 프로토콜(HTCP) 등 특별 프로토콜 사용해 HTTP를 확장함 (20장 자세히)

## 7.7 캐시 처리 단계

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/ce223b05-475d-4d27-9514-da5f6896cc0e" />

- HTTP GET 메시지 하나를 처리하는 기본적인 캐시 처리 절차는 일곱 단계로 이루어져있음:

1. 요청 받기: 캐시는 네트워크로부터 도착한 요청 메시지를 읽음
2. 파싱: 캐시는 메시지를 파싱하여 URL과 헤더들을 추출
3. 검색: 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아오고 저장
4. 신선도 검사: 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어봄
5. 응답 생성: 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만듬
6. 발송: 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줌
7. 로깅: 선택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남김

### 7.7.1 단계 1: 요청 받기

- 캐시가 네트워크에서 들어오는 데이터를 감지하고 읽기 시작함
- 고성능 캐시는 여러 커넥션에서 동시에 데이터를 읽어들여, 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작함

> 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작한다는게 무슨 소리지?

### 7.7.2 단계 2: 파싱

- 캐시가 요청 메시지를 파싱하여 헤더를 조작하기 쉬운 자료 구조에 담음
- 이를 통해 캐싱 소프트웨어가 헤더 필드를 효율적으로 처리하고 조작할 수 있게 됨

### 7.7.3 단계 3: 검색

- 캐시가 URL에 해당하는 로컬 사본이 있는지 확인함
- 로컬 복사본은 메모리, 디스크, 또는 근처의 다른 컴퓨터에 있을 수 있음
- 고급 캐시는 빠른 알고리즘을 사용하여 로컬 캐시에서 객체를 찾고, 없으면 원 서버나 부모 프락시에서 가져오거나 실패를 반환함
- 캐시된 객체에는 서버 응답 본문과 헤더, 그리고 메타데이터(캐시된 시간, 사용 빈도 등)가 포함됨

> 고급 캐시는 어떤 빠른 알고리즘을 사용하는거지?

### 7.7.4 단계 4: 신선도 검사

- 캐시된 문서는 일정 기간 동안 신선하다고 간주되며, 이 기간 동안 서버와의 접촉 없이 제공할 수 있음
- 그러나 신선도 한계를 넘으면 문서는 '신선하지 않은' 것으로 간주되어, 캐시는 서버와 재검사를 통해 문서의 변경 여부를 확인해야 함
- 신선도 검사 규칙은 복잡하며, 다양한 설정 옵션과 비 HTTP 신선도 표준과의 상호작용으로 더더욱 복잡해짐

### 7.7.5 단계 5: 응답 생성

- 캐시는 캐시된 서버 응답 헤더를 기반으로 응답 헤더를 생성하여, 원 서버에서 온 것처럼 보이도록 함
- 캐시는 클라이언트에 맞게 해더를 조정해야함. 예를 들어 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했으면 적절하게 번역해야 함
- 캐시는 신선도 정보를 삽입하며(예: Cache-Control, Age, Expires), 요청이 프락시 캐시를 거쳤음을 알리기 위해 Via 헤더를 포함할 수 있음
- 단, Date 헤더는 객체가 원 서버에서 최초로 생성된 시간을 나타내므로 캐시가 수정해서는 안됨

### 7.7.6 단계 6: 전송

- 응답 헤더가 준비되면 캐시가 클라이언트에게 응답을 전송함
- 고성능 캐시는 네트워크 I/O 버퍼와 로컬 저장장치 사이에서 문서 내용을 복사하지 않고, 데이터를 효과적으로 전송하려고 노력함
- 프락시 캐시는 클라이언트와의 커넥션을 유지해야 함

> 두 번째 꺼 무슨 소리지??

### 7.7.7 단계 7: 로깅

- 캐시는 로그 파일과 캐시 사용 통계를 유지함
- 트랜잭션이 완료된 후, 캐시는 캐시 적중과 부적중 횟수 등을 갱신하고, 로그 파일에 요청 종류, URL, 발생한 상황 등을 기록함
- 가장 많이 사용되는 로그 포맷은 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이지만, 많은 캐시 제품이 커스텀 로그 파일을 지원함

### 7.7.8 캐시 처리 플로 차트

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/a9b26899-6a75-42b5-a360-ad492d3aa94e" />

## 7.8 사본을 신선하게 유지하기

- 캐시된 사본이 서버의 문서와 항상 일치하지 않을 수 있음
- 문서는 시간이 지나면서 변경되므로, 캐시된 데이터는 서버의 최신 데이터와 일치하도록 관리되어야 함
- HTTP는 캐시된 사본을 서버와 일치하도록 유지하기 위해 문서 만료와 서버 재검사라는 간단한 메커니즘을 제공함

### 7.8.1 문서 만료

<img width="422" alt="Image" src="https://github.com/user-attachments/assets/1cc24076-0f41-4e8e-96ec-74ecfed5a3ad" />

- HTTP는 Cache-Control과 Expires 헤더를 사용하여 원 서버가 각 문서에 유효기간을 설정할 수 있도록 해줌
- 캐시된 문서는 만료되기 전에는 서버와의 접촉 없이 제공될 수 있지만, 만약 문서가 만료되면 캐시는 서버와 재검사를 통해 변경사항을 확인하고 신선한 사본을 받아와야 함

### 7.8.2 유효기간과 나이

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/cbc2a770-8ebc-4094-b340-9e04f3415847" />

- 서버는 HTTP 응답 본문에 Expires 또는 Cache-Control: max-age 헤더를 사용하여 문서의 유효기간을 설정하는 방법을 설명함
- Expires는 절대 시간을, Cache-Control: max-age는 상대 시간을 초 단위로 명시함.
- 예) 2002년 6월 29일 오전 9시 30분에 (5일 뒤) 만료되는 페이지를 설정할 때,
  - Expires 헤더는 "Fri, 05 Jul 2002, 05:00:00 GMT"로 설정될 수 있음
  - Cache-Control: max-age=484200는 5일을 초로 환산한 값을 사용함

### 7.8.3 서버 재검사

- 캐시된 문서가 만료되었다는 것은, 해당 문서가 원 서버와 실제로 다르다는 것이 아니라 같은지 다른지 검사할 시간임을 뜻함
- 재검사 결과 콘텐츠가 변경되었다면, 캐시는 새로운 사본을 가져와 저장하고 클라이언트에 전달함
- 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 헤더만 갱신하고 기존 사본을 유지함
- 이는 서버 트래픽을 절약하고 사용자 응답 시간을 개선하는 방식으로, 캐시는 문서의 신선도를 매번 검증하지 않고 문서가 만료됐을 때만 재검사를 수행함

### 7.8.4 조건부 메서드와의 재검사

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/b6df089a-f1dc-4846-82b0-d9c0e218174a" />

- HTTP는 캐시가 서버에게 ‘조건부 GET’이라는 요청을 보낼 수 있도록 해줌
- 이 요청은 서버가 캐시와 다른 문서를 가지고 있을 때만 객체 본문을 반환하도록 함
- 조건부 GET은 If-Modified-Since와 If-None-Match 헤더를 통해 작동하며, 이 헤더들은 서버가 문서의 수정 여부나 태그가 일치하는지 확인한 후에 응답을 반환함
- 이를 통해 효율적인 캐시 재검사가 가능해짐

### 7.8.5 If-Modified-Since: 날짜 재검사

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/c1937a53-ba0b-4485-911a-29611e372e24" />

```
If-Modified-Since: ＜캐시된마지막수정일＞
```

- 캐시된 문서가 특정 날짜 이후로 변경되었는지를 확인하는 HTTP 조건부 헤더임
- 이 요청은 서버에게 문서가 변경된 경우에만 본문을 보내달라고 요청함
- 만약 변경되지 않았다면, 서버는 304 Not Modified 응답을 보내며 본문을 포함하지 않음. 이때 응답은 갱신이 필요한 정보만 제공됨, 예를 들어 새 만료 날짜 같은 정보는 보내줌
- If-Modified-Since 헤더는 Last-Modified 서버 응답 헤더와 함께 동작하며, 서버는 문서의 최신 수정 일시를 기준으로 재검사를 진행함
- 일부 웹 서버는 If-Modified-Since 헤더를 실제 날짜 비교 대신 문자열 비교로 처리하여, 정확히 일치하지 않으면 변경된 것으로 간주함

> 마지막 문장 이해 못함...시간을 나타내는 문자열이니 실제 날짜 비교나 문자열 비교나 같은 것 아닌가...?

### 7.8.6 If-None-Match: 엔터티 태그 재검사

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/fed28523-065a-47c8-a96d-b9c07bc89eb2" />

- If-None-Match 헤더는 서버의 엔터티 태그(ETag)를 활용하여 캐시 문서가 변경되었는지 확인하는 방법임
- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황에서 유용하게 사용됨
- 엔터티 태그는 문서의 버전 정보를 나타내며, 서버는 문서가 변경될 때마다 새로운 엔터티 태그를 부여함
- 클라이언트는 If-None-Match 헤더를 통해 서버에게 캐시된 문서의 엔터티 태그를 보내고, 서버는 해당 태그가 현재 문서의 태그와 다를 경우에만 새 문서를 반환함
- 캐시가 객체에 대한 여러 개의 사본을 갖고 있는 경우, If-None-Match 헤더에 여러 개의 엔터티 태그를 포함시킬 수 있음
  ```
  If-None-Match: "v2.6"
  If-None-Match: "v2•4","v2.5","v2.6"
  If-None-Match: "foobar","A34FAC0095","Profiles in Courage"
  ```

### 7.8.7 ETag - 약한 검사기와 강한 검사기

- 강한 검사기: 콘텐츠가 변경되면 엔터티 태그도 반드시 변경됨. 변경된 내용이 없으면 태그도 변하지 않음
- 약한 검사기: 콘텐츠의 중요하지 않은 변경은 허용되지만, 의미 있는 변경이 있을 경우 태그도 변경됨. `W/` 접두사를 사용하여 약한 검사기를 구분함
  ```
  ETag: W/"v2.6"
  If-None-Match: W/"v2.6"
  ```
- 서버는 약한 검사기를 사용하여 작은 변경을 허용하고, 강한 검사기를 사용하여 큰 변경을 정확히 반영함

> 캐시에서 약한 엔터티 태그일 때 '변경'또는 '변경하지 않음'을 설정할 수 있는건가?

### 언제 ETag를 사용하고 언제 Last-Modified 일시를 사용하는가

- 엔터티 태그가 제공되면 클라이언트는 이를 반드시 사용하여 검사를 해야 하고, Last-Modified 값만 제공되면 If-Modified-Since를 사용해야 함
- 두 값이 모두 제공되면, 클라이언트는 두 가지 검사 정책을 모두 사용해서 HTTP/1.0과 HTTP/1.1 캐시 모두 적절히 응답할 수 있도록 해야 함
- HTTP/1.1 서버는 엔터티 태그를 보내야 하며, 가능하면 약한 엔터티 태그는 Last-Modified 값을 함께 보내는 것이 좋음
- 만약 HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안됨

## 7.9 캐시 제어

HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있음

1. **`Cache-Control: no-store`** → 캐시에 저장하지 않음.
2. **`Cache-Control: no-cache`** → 항상 원 서버에서 검증 후 캐시 사용.
3. **`Cache-Control: must-revalidate`** → 만료된 캐시는 반드시 재검증 필요.
4. **`Cache-Control: max-age`** → 지정된 초(sec) 동안 캐시 유지.
5. **`Expires`** → 특정 날짜까지 캐시 유지.
6. **휴리스틱 캐싱** → 명시적 만료 정보 없이 캐시가 자체적으로 판단.

### 7.9.1 no-cache와 no-store 응답 헤더

HTTP/1.1에서는 객체의 캐싱을 제한하거나 검증된 캐시만 제공하도록 여러 메커니즘을 제공함

- **`Cache-Control: no-store`**

  - 응답의 사본을 캐시에 저장하는 것을 금지함.
  - 캐시는 응답을 전달한 후 즉시 삭제해야 함.

- **`Cache-Control: no-cache`**

  - 캐시에 저장은 가능하지만, **반드시 원 서버와 재검증 후 제공**해야 함.
  - 더 적절한 헤더 명칭은 Do-Not-Serve-From-Cache-Without-Revalidation(재검증 없이 캐시에서 제공하지 마라)

- **`Pragma: no-cache`**
  - HTTP/1.0+ 와의 하위 호환성을 위해 HTTP/1.1에 포함됨.
  - HTTP/1.1에서는 Pragma:no-cache만 이해할 수 있는 HTTP/1.0에 대응해야하는 경우가 아니면 `Cache-Control: no-cache`를 사용하는 것이 권장됨.

### 7.9.2 Max-Age 응답 헤더

`Cache-Control: max-age` 헤더는 문서가 **서버로부터 온 후 경과된 시간(초 단위)**를 나타냄, 캐시 신선도를 결정함

- **`Cache-Control: max-age=3600`**

  - 문서는 **최대 3600초(1시간) 동안 신선**한 상태로 유지됨.

- **`Cache-Control: s-maxage=3600`**

  - `max-age`와 동일하지만 **공용(공유) 캐시**에만 적용됨.
  - `s-maxage`는 프록시 캐시에 영향을 주며, 클라이언트의 개인 캐시는 영향받지 않음.

- **최대 나이를 0으로 설정 (`max-age=0`)**
  - 캐시된 문서는 **매번 원 서버에서 검증해야 함**.

### 7.9.3 Expires 응답 헤더

`Expires` 헤더는 문서의 만료 시간을 **절대 날짜와 시간(GMT 기준)**으로 설정한다. 하지만 **HTTP/1.1에서는 `Cache-Control: max-age` 사용이 권장됨**.

- **예제:**

  ```plaintext
  Expires: Fri, 05 Jul 2002 05:00:00 GMT
  ```

- **Deprecated(더 이상 사용 권장되지 않음) 이유**

  - 서버 간 **시계 동기화 문제**로 인해 정확성이 떨어짐.
  - **상대적인 경과 시간(`Cache-Control: max-age`)이 더 신뢰성 높음**.

- **만료 강제 설정 (`Expires: 0`)**

  - 몇몇 서버는 문서를 항상 만료시키기 위해 `Expires: 0`을 사용하지만, 이는 **문법적으로 잘못된 방식**이며 일부 소프트웨어와 충돌할 수 있음.
  - 대신 **`Cache-Control: no-cache` 또는 `max-age=0`**을 사용하는 것이 바람직함.

### 7.9.4 Must-Revalidate 응답 헤더

`must-revalidate` 헤더는 **캐시된 객체가 만료되었을 경우, 반드시 원 서버와 재검사 후 제공해야 함**을 의미함

- **예제:**

  ```plaintext
  Cache-Control: must-revalidate
  ```

- **주요 특징**

  - 신선한 캐시된 사본은 자유롭게 제공 가능.
  - 만료된 객체는 원 서버와의 재검사 없이는 제공 불가.
  - 원 서버가 응답하지 않으면 캐시는 504 Gateway Timeout 오류 반환.

- **사용 목적**
  - 만료된 콘텐츠가 제공되지 않도록 엄격한 캐싱 규칙을 적용할 때 사용.

### 7.9.5 휴리스틱 만료

### **7.9.5 휴리스틱 만료 요약**

- **휴리스틱 만료**: 만약 `Cache-Control: max-age`나 `Expires` 헤더가 없다면, 캐시는 경험적인 방법(heuristic)으로 최대 나이를 계산함.
- **경고**: 최대 나이가 24시간보다 크면 `Heuristic Expiration` 경고 헤더가 추가됨.
- **LM 인자 알고리즘**: 최근 변경 일시를 이용해 캐시의 신선도 기간을 계산.

  - **로직**: 문서가 최근에 변경되었으면 짧은 기간만 캐시하고, 오랫동안 변경되지 않았다면 긴 기간 캐시 가능.
  - **펄 의사코드**:
    ```perl
    $마지막_수정_이후로_경과한_시간 = max(0, $서버의_Date - $서버의_Last_Modified);
    $서버_신선도_한계 = int($마지막_수정_이후로_경과한_시간 * $lm_인자);
    ```
    <img width="425" alt="Image" src="https://github.com/user-attachments/assets/d49b4349-c80a-4146-a513-542f37c54c8b" />

- **상한 설정**: 일반적으로 휴리스틱 신선도 기간에 상한을 설정하여 지나치게 길어지지 않도록 함.
  - **일반적으로 1주일, 보수적인 사이트는 1일**로 설정.
- **기본 신선도**: 신선도에 대한 아무런 단서가 없는 문서에 대해 기본 신선도 기간을 설정(보통 1시간 또는 1일).
- **보수적인 캐시**는 신선도 기간을 0으로 설정하여 매번 재검사함.

- **주의 사항**

  - 아직 많은 서버가 `Expires`와 `max-age` 헤더를 생성하지 못하므로, 휴리스틱 신선도 계산이 자주 발생함.
  - 캐시의 기본 만료 값을 신중하게 선택해야 함.

### 7.9.6 클라이언트 신선도 제약

| 지시어                                      | 목적                                                                                                                                                                                          |
| ------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Cache-Control: max-stale                    | 캐시는 신선하지 않은 문서라도 자유롭게 제공할 수 있다. 만약 `<s>` 매개변수가 지정되면, 클라이언트는 만료시간이 그 매개변수의 값만큼 지난 문서도 받아들인다. 이것은 캐싱 규칙을 느슨하게 한다. |
| Cache-Control: min-fresh = `<s>`            | 클라이언트는 지금으로부터 적어도 `<s>`초 후까지 신선한 문서만을 받아들인다. 이것은 캐싱 규칙을 엄격하게 한다.                                                                                 |
| Cache-Control: max-age = `<s>`              | 캐시는 `<s>`초보다 오래동안 캐시된 문서를 반환할 수 없다. 나이가 유효기간을 넘어서게 되는 max-stale 지시어가 함께 설정되지 않는 이상, 이 지시어는 캐싱 규칙을 더 엄격하게 만든다.             |
| Cache-Control: no-cache<br>Pragma: no-cache | 이 클라이언트는 캐시된 리소스는 재검사하기 전에는 받아들이지 않을 것이다.                                                                                                                     |
| Cache-Control: no-store                     | 이 캐시는 저장소에서 문서의 흔적을 최대한 빨리 삭제해야 한다. 그 문서에는 민감한 정보가 포함되어 있기 때문이다.                                                                               |
| Cache-Control: only-if-cached               | 클라이언트는 캐시에 들어있는 사본만을 원한다.                                                                                                                                                 |

- **리프레시 버튼**: 웹 브라우저는 프락시 캐시나 브라우저 캐시의 신선하지 않은 콘텐츠를 갱신하기 위한 리프레시(또는 리로드) 버튼을 제공. 이 버튼은 `Cache-Control` 요청 헤더가 추가된 GET 요청을 보내어 서버로부터 콘텐츠를 강제로 가져오거나 재검사함.
- **Cache-Control 요청 헤더**: 클라이언트는 `Cache-Control` 요청 헤더를 사용하여 만료 제약을 설정할 수 있음.

  - **엄격한 만료 제약**: 최신 콘텐츠를 유지해야 하는 애플리케이션에서는 만료를 엄격하게 설정.
  - **느슨한 신선도 요구사항**: 성능, 신뢰성, 비용 개선을 위해 신선도 요구 사항을 덜 엄격하게 설정 가능.

- **주요 포인트**

  - 정확한 리프레시 동작은 브라우저, 문서, 중간 캐시 설정에 따라 달라짐.
  - `Cache-Control` 요청 헤더를 통해 신선도 요구사항을 세밀하게 조정할 수 있음.

### 7.9.7 주의할 점

- **문서 만료의 한계**: 이러한 문서 만료는 완벽한 시스템이 아님. 퍼블리셔가 잘못 설정하여 유효기간을 너무 길게 설정하면, 만료되기 전까지는 캐시에 어떤 변경 사항도 반영되지 않음.
- **퍼블리셔의 유효기간 설정 문제**: 많은 퍼블리셔들이 유효기간을 길게 설정하지 않으며, 일부는 아예 유효기간을 설정하지 않음. 이로 인해 캐시가 문서의 신선도를 알기 어려운 경우도 발생.

## 7.10 캐시 제어 설정

- 웹 서버들은 캐시 제어 및 만료 HTTP 헤더를 설정하는 다양한 방법을 제공함
- 이 절에서는 **아파치 웹 서버**의 캐시 제어 지원 방식에 대해 간략히 다룸

### 7.10.1 아파치로 HTTP 헤더 제어하기

- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정할 수 있는 여러 가지 메커니즘을 제공함.
- 대부분의 경우 기본적으로 비활성화되어 있어 사용하려면 활성화가 필요하고, 일부 기능은 아파치 확장 모듈이 필요함.

- **mod_headers**

  - 개별 HTTP 헤더를 설정할 수 있는 모듈임.
  - 아파치 설정 파일에 헤더 설정을 추가할 수 있으며, 정규식과 필터를 이용해 특정 콘텐츠에 헤더를 연결할 수 있음.
  - 예시: 특정 디렉터리의 모든 HTML 파일에 대해 캐시를 비활성화하는 방법
    ```apache
    <Files *.html>
      Header set Cache-control no-cache
    </Files>
    ```

- **mod_expires**
  - 만료 날짜를 자동으로 생성하는 모듈임.
  - 문서에 마지막으로 접근한 날이나 수정한 날을 기준으로 유효기간을 설정할 수 있음.
  - 파일 유형별로 다른 만료 날짜를 설정할 수 있으며, 편리한 형식으로 유효기간을 지정할 수 있음.
  - 예시:
    ```apache
    ExpiresDefault A3600
    ExpiresDefault M86400
    ExpiresDefault "access plus 1 week"
    ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
    ```
- **mod_cern_meta**
  - HTTP 헤더들을 특정 객체와 연결시키는 모듈임.
  - 제어하려는 파일에 대응되는 메타파일을 생성하고, 해당 메타파일에 원하는 헤더를 추가하여 제어함.

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- HTML 2.0은 `<META HTTP-EQUIV>` 태그를 도입하여 웹 서버 설정 파일 없이 HTML 문서 내에서 HTTP 헤더를 손쉽게 설정할 수 있게 함.
- `<META HTTP-EQUIV="Cache-control" CONTENT="no-cache">`와 같은 태그를 사용하여 HTML 문서를 캐시하지 않도록 설정 가능.
  ```html
  <html>
    <head>
      <title>My Document</title>
      <meta
        http-equiv="Cache-control"
        content="no-cache"
      />
    </head>
    ...
  </html>
  ```
- HTTP 서버는 이 태그를 파싱하여 HTTP 응답에 적절한 헤더를 추가하도록 설계됨.
- 하지만 대부분의 웹 서버나 프락시는 이 기능을 지원하지 않음. 서버의 부하를 증가시키고 설정값이 정적이며 다른 타입의 파일을 지원하지 않기 때문임 .
- 몇몇 브라우저는 `<META HTTP-EQUIV>` 태그를 파싱하여 HTTP 헤더처럼 처리하나, 이는 프락시 캐시와 다른 캐시 제어 규칙을 적용하게 되어 캐시 만료에 대한 동작에 혼란을 일으킬 수 있음.
  > 왜일까?
- 따라서 문서의 캐시 제어는 올바르게 설정된 서버에서 보내온 HTTP 헤더를 사용하는 것이 확실한 방법임.

## 7.11 자세한 알고리즘

- HTTP 신선도 계산 아로길즘에 대해 자세히 보자

### 7.11.1 나이와 신선도 수명

**캐시 신선도 판단 기본 원칙**

- 캐시된 사본의 나이가 신선도 수명보다 작으면 신선한 것임

```
$충분히_신선한가 = ($나이 < $신선도_수명);
```

**문서의 나이**

- 서버가 문서를 보낸 후 그 문서가 '나이를 먹은' 시간의 총합
- 문서의 나이는 Age 헤더 또는 Date 헤더를 통해 판별 (Age 헤더 방식 권장)

**신선도 수명**

- 문서가 신선하다고 볼 수 있는 수명
- 신선도 수명 < 문서 나이 → 더 이상 신선하지 않음
- 문서의 유효기간과 클라이언트의 신선도 관련 요청을 고려하여 계산

> 3번째 무슨 말이지? (신선도 수명의 계산에는 문서의 유효기간과 신선도에 영향을 주
> 는 클라이 언트의 모든 요청을 고려한다.)

**클라이언트 신선도 요구사항**

- Cache-Control: max-stale → 약간 신선하지 않은 문서도 허용
- Cache-Control: min-fresh → 조만간 신선하지 않게 될 문서도 거부

**최종 판단**

- 서버 만료 정보 + 클라이언트 신선도 요구사항 = 최대 신선도 수명 결정

### 7.11.2 나이 계산

**응답의 나이 정의**

- 응답이 서버에서 생성(또는 재검사)된 시점부터 현재까지의 총 시간
- 인터넷 라우터/게이트웨이 이동 시간 + 캐시 머문 시간 포함

**HTTP/1.1 나이 계산 알고리즘은 캐시된 문서의 총 나이를 계산함**

```
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된*겉보기*나이 = max($겉보기_나이, $Age_헤더값);
$응답*지연*추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가*우리의*캐시에*도착했을*때의*나이 = $보정된*겉보기*나이 + $응답*지연*추정값;
$사본이*우리의*캐시에*머무른*시간 = $현재*시각 - $응답을_받은_시각;

$나이 = $문서가*우리의*캐시에*도착했을*때의*나이 + $사본이*우리의*캐시에*머무른\_시간;
```

**기본 계산**
$나이 = $문서가*우리의*캐시에*도착했을*때의*나이 + $사본이*우리의*캐시에*머무른\_시간;

**계산 시 고려사항**

- 로컬 캐시 시간: 쉽게 계산 가능 (장부 기록으로 확인)
- 응답 나이: 서버 시계 비동기화 및 출처 불명(캐시에서 왔는지 원서버에서 왔는지)으로 어려움

  - ex) 캐시 서버를 여러 번 거치는 경우

    1. 원본 서버가 문서를 생성한 시점: '18:00:00 GMT'
    2. A 지역 CDN이 원본 서버로부터 문서를 받아 저장함
    3. 30초 후 ('18:00:30 GMT'), B 지역 CDN이 A 지역 CDN으로부터 문서를 받아 다시 저장함
    4. 20초 후 ('18:00:50 GMT'), 클라이언트가 요청을 ㄹ보냄 -> B 지역 CDN이 응답을 반환함

    - 응답 헤더

    ```http
    HTTP/1.1 200 OK
    Date: Tue, 04 Mar 2025 18:00:00 GMT
    Age: 20
    ```

    - 문제점: 실제로는 원본 서버에서 응답이 생성된 지 50초가 지났음, Age:20 값은 B 지역 CDN에 보관된 시간(20초)만 표시함 -> 응답이 실제보다 신선해보이는 문제 발생

    - -> 완전한 나이 계산 알고리즘 필요

**겉보기 나이는 Date 헤더에 기반한다**

- 모든 컴퓨터가 똑같이 정확한 시계를 가지고 있다면 캐시된 문서의 나이는 단순히 `현재 시각 - 서버가 문서를 보낸 시간` 이 될 것임

```
// 이상적인 경우 (모든 컴퓨터가 정확한 시계)
$겉보기_나이 = $응답을_받은_시각 - $Date_헤더값;
$문서가_우리의_캐시에_도착했을_때의_나이 = $겉보기_나이;
```

```
// 현실적인 경우 (클록 스큐 보정)
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$문서가*우리의*캐시에*도착했을*때의*나이 = $겉보기*나이;
```

- Date 헤더: 원 서버가 문서를 보낸 시간을 표시
- 클록 스큐(Clock Skew): 클라이언트와 서버 간 시계 설정에 차이가 나는 것
- 겉보기 나이를 부정확하게 만들거나 음수 값 발생 가능
- 음수 값 처리: max() 함수로 0으로 변환
- Date 헤더 보존: 프락시와 캐시는 원 서버의 Date 헤더를 변경 금지

**점층적 나이 계산**

- HTTP/1.1 해결책 - Age 헤더 누적

  - 클록 스큐 문제 우회를 위해 상대적 나이를 Age 헤더에 누적
  - 서버 간 또는 종단 간 시간 비교 불필요
  - 각 프락시 통과 시마다 Age 헤더 값 증가

- 나이 계산 알고리즘

  ```
  $겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
  $보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
  $문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이;
  ```

- 비-HTTP/1.1 장치: Age 헤더를 인식하지 못해 Age 헤더를 누적하지 않거나 삭제 가능성
- 보수적 접근: 두 나이 추정값(Date 기반, Age 기반) 중 더 큰 값을 선택
- 신선도 우선: HTTP는 더 신선한 콘텐츠를 위해 Age 헤더 오류 용인

> 비-HTTP/1.1 이 뭐지?

**네트워크 지연에 대한 보상**

- 문제점

  - 네트워크 혼잡 및 서버 과부하로 인한 지연
  - Date 헤더는 출발 시간만 표시, 전송 시간은 포함하지 않음
  - 프락시/캐시 연쇄 통과 시 상당한 지연 발생 가능
  - -> 모자란 문서 나이 측정

- HTTP/1.1 보상 방법

  - 단방향(서버 -> 캐시) 지연 측정 어려움 → 왕복 지연(캐시 -> 서버 -> 캐시) 계산으로 보수적 교정 적용
  - 만약 오차가 있다면, 문서를 실제보다 오래되어 보이게 만들어서 불필요한 재검사를 하게 만듦

- 네트워크 지연 보상 알고리즘

  ```
  $겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
  $보정된_겉보기_나이 = max($겉보기_나이, $Age_헤더값);
  $응답_지연_추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
  $문서가_우리의_캐시에_도착했을_때의_나이 = $보정된_겉보기_나이 + $응답_지연_추정값;
  ```

### 7.11.3 완전한 나이 계산 알고리즘

<img width="401" alt="Image" src="https://github.com/user-attachments/assets/29239589-0ec9-4c54-90fa-fce6d5d3720f" />

- 문서에 대한 요청이 캐시에 도착했을 때, 우리는 그 문서의 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알아야함

```
// 캐시된 문서의 최종 나이 계산
$나이 = $문서가_우리의_캐시에_도착했을_때의_나이 + $사본이_우리의_캐시에_머무른_시간;

// 캐시 체류 시간 계산
$사본이_우리의_캐시에_머무른_시간 = $현재_시각 - $응답을_받은_시각;
```

```
// 최종 HTTP/1.1 나이 계산 알고리즘
$겉보기_나이 = max(0, $응답을_받은_시각 - $Date_헤더값);
$보정된*겉보기*나이 = max($겉보기_나이, $Age_헤더값);
$응답*지연*추정값 = ($응답을_받은_시각 - $요청을_보낸_시각);
$문서가*우리의*캐시에*도착했을*때의*나이 = $보정된*겉보기*나이 + $응답*지연*추정값;
$사본이*우리의*캐시에*머무른*시간 = $현재*시각 - $응답을_받은_시각;
$나이 = $문서가*우리의*캐시에*도착했을*때의*나이 + $사본이*우리의*캐시에*머무른\_시간;
```

### 7.11.4 신선도 수명 계산

- 신선도 수명 정의

  - 문서가 특정 클라이언트에게 제공 가능한 상태로 유지되는 시간
  - 서버와 클라이언트의 제약조건에 따라 결정됨

- 서버 측 고려사항

  - 문서의 변경 및 발행 빈도
  - 문서 유형별 신선도 기간 차이 (안정된 보고서 vs 정기간행물)

- 클라이언트 측 고려사항
  - 속도 우선: 약간 신선하지 못한 콘텐츠 허용 가능
  - 최신성 우선: 가장 최신 콘텐츠 요구

## 7.12 캐시와 광고

- 캐시는 사용자를 도와 더 좋은 경험을 제공하고, 트래픽을 줄일 수 있도록 도와줌

### 7.12.1 광고 회사의 딜레마

**콘텐츠 제공자의 기대**

- 캐시 활용으로 서버 비용 절감, 네트워크 비용 절감, 빠른 로딩 가능.
- 더 많은 콘텐츠 소비와 광고 노출 증가.

**광고 수익 모델과 충돌**

- 광고 수익은 소비자가 광고를 볼 때마다 발생.
- 캐시가 광고 요청을 가로채면 원 서버에서 실제 접근 횟수를 알 수 없음.
- 광고가 캐시에서 제공되면 원 서버의 HTTP 요청이 감소하여 수익 감소 문제 발생.

### 7.12.2 퍼블리셔의 응답

**광고 회사의 캐시 무력화 전략**

- 캐시가 광고 시청 수를 가로채지 못하도록 캐시 무력화 기법 사용
- CGI 게이트웨이 활용
- URL 변경 기법: 매 요청마다 광고 URL을 변경하여 캐싱을 무력화.

> CGI 게이트웨이란?

**브라우저 캐시 대응**

- 프락시 캐시뿐만 아니라, 웹브라우저 캐시도 대응해야함
- 광고 시청 수를 관리하려는 과도한 시도가 일반 콘텐츠의 캐싱 효과를 감소시킴.

**이상적인 해결책**

- 캐시를 허용하고, 캐시가 적중 횟수를 콘텐츠 제공자에게 보고해야 함.
- 한 가지 방법: 원 서버와 재검사하도록 캐시 설정
  - 매 접근 시 원 서버에 캐시 적중을 알림.
  - 본문 데이터 전송 없이 트랜잭션 수행.
  - 그러나 트랜잭션 속도가 느려지는 단점 존재.

### 7.12.3 로그 마이그레이션

**이상적인 해결책**

- 서버로 요청을 보내지 않고 캐시가 적중 로그를 유지하여 서버에게 전달.
- 일부 대형 캐시 제공자는 특정 콘텐츠 제공자에게 수동으로 로그 제공.

**문제점**

- 로그 크기 문제: 적중 로그가 너무 커서 옮기기 어려움.
- 표준화 부족: 개별 콘텐츠 제공자별로 로그를 분리하고 관리하는 표준이 없음.
- 인증 및 프라이버시 이슈: 로그 공유 시 사용자 데이터 보호 문제 발생.

**현황과 해결책**

- 효율적인 로그 재분산 전략이 제안되었으나 실용적인 수준까지 발전하지 못함.
- 복잡성과 협력 문제로 인해 웹 소프트웨어 벤더들이 적극적으로 채택하지 않음.
- 광고 수익을 조정하는 인프라 개발을 위해 벤처 기업들이 설립됨.

> 현재는 어떨까?

### 7.12.4 적중 측정과 사용량 제한

**개요**

- RFC 2227은 HTTP 캐시 적중량 측정과 사용량 제한을 위한 간단한 방법을 정의.
- `Meter` 헤더를 추가하여 특정 URL에 대한 캐시 적중 횟수를 서버에 정기적으로 보고.

**주요 기능**

1. 캐시 적중량 측정

   - 캐시는 특정 문서의 적중 횟수를 기록.
   - 일정 주기마다 원 서버에 보고하여 캐시된 콘텐츠의 실제 조회 수 파악 가능.

2. 사용량 제한

   - 서버는 캐시된 리소스가 제공될 수 있는 횟수나 처리 시간의 한계를 설정할 수 있으며, 캐시는 이 제한에 도달하면 원 서버에 보고하도록 강제될 수 있다.
