# 1. 불필요한 데이터 전송
- 서버는 동일한 문서를 여러 클라이언트에게 반복 전송하며 불필요한 데이터 전송이 발생한다. 
- 이는 네트워크 대역폭을 낭비하고 서버 부하를 증가시킨다. 
- `캐시`를 활용하면 첫 번째 응답을 저장하고 이후 요청에 재사용하여 중복 트래픽을 줄일 수 있다.

# 2. 대역폭 병목
<img width="575" alt="image" src="https://github.com/user-attachments/assets/0194187d-57f8-4410-a64d-db74eac859b7" />

- 원격 서버보다 로컬 네트워크가 더 빠르기 때문에, 캐시된 데이터를 가져오면 전송 속도가 크게 향상된다. 
- 네트워크 대역폭과 종류에 따라 전송 속도 차이가 크며, 캐싱은 특히 큰 문서 전송 시 효과적이다.

# 3. 갑작스런 요청 쇄도（Flash Crowds）
<img width="574" alt="image" src="https://github.com/user-attachments/assets/7f42e54f-a510-42af-9bff-4c54bfcddcb6" />

- 속보로 인해 다수가 동시에 웹 문서에 접근하면 네트워크와 서버에 과부하가 걸릴 수 있다.
- 캐싱을 활용하면 이러한 트래픽 급증으로 인한 장애를 줄일 수 있다.

# 4. 거리로 인한 지연
<img width="570" alt="image" src="https://github.com/user-attachments/assets/d100a085-e4aa-4865-b7f4-3c95108b8b4e" />

- 라우터를 거치면서 트래픽이 지연될 뿐만 아니라, 빛의 속도 자체도 유의미한 지연을 초래한다.
- 하지만 캐시를 활용하면 데이터 전송 거리를 줄일 수 있다.

# 5. 적중과 부적중
<img width="576" alt="image" src="https://github.com/user-attachments/assets/37c939f7-f739-4404-af4d-300899905d74" />

- **캐시 적중** : 요청에 대응하는 사본이 캐시에 있을 경우, 해당 사본을 이용해 요청을 처리한다.
- **캐시 부적중** : 요청에 대응하는 사본이 캐시에 없을 경우, 원 서버로 요청을 전달한다.

## 5.1 재검사
### 재검사
- 캐시된 사본이 최신인지 주기적으로 확인하기 위해 원 서버와 확인하는 과정이다.
- 전체 객체를 가져오지 않고 빠르게 신선도를 확인할 수 있는 요청을 HTTP에서 제공한다.

### 재검사 적중
<img width="578" alt="image" src="https://github.com/user-attachments/assets/b39b3da2-75c7-4f6c-94a1-14210f056542" />

- 캐시가 사본의 신선도를 검사하기 위해 원 서버에 작은 요청을 보낸다.
- 콘텐츠가 변경되지 않으면, 서버는 304 Not Modified 응답을 보내고 캐시는 해당 사본을 신선하다고 표시한 뒤 클라이언트에 제공한다.
- 재검사 적중은 원 서버와의 검사를 거쳐야 하므로 캐시 적중보다 느리지만, 캐시 부적중보다는 빠르다.

### HTTP 도구
- `If-Modified-Since` 헤더를 사용하여 서버에게 해당 시간 이후에 변경된 경우만 사본을 요청한다.
- 서버 응답:
    - 변경되지 않은 경우: `304 Not Modified`
    - 변경된 경우: 새 객체와 함께 `200 OK`
    - 삭제된 경우: `404 Not Found`

## 5.2 적중률
- 캐시 적중률(문서 적중률)은 요청 처리에서 캐시가 처리한 비율을 나타내며, 0%는 모든 요청이 부적중, 100%는 모든 요청이 적중임을 의미한다.
- 적중률은 캐시 크기, 사용자 관심사, 데이터 변경 빈도 등에 따라 달라지며, 40%의 적중률도 좋은 편으로 간주된다. 
- 캐시는 자주 사용되는 문서를 보관해 트래픽을 줄이고 성능을 향상시킨다.

### 5.3 바이트 적중률
- 문서 적중률은 모든 문서의 접근을 나타내지만, 크기가 다른 문서들로 인해 전체 트래픽을 정확히 반영하지 못한다. 이를 보완하기 위해 바이트 단위 적중률이 사용된다.
- 바이트 단위 적중률은 캐시에서 제공된 바이트의 비율을 나타내며, 100%는 모든 트래픽이 캐시에서 왔음을 의미한다.
- 문서 적중률은 웹 트랜잭션의 외부 요청을 줄여 대기 시간을 줄이고, 바이트 단위 적중률은 대역폭 절약을 최적화한다.

> Q. 트래픽과 대역폭의 관계?

### 5.4 적중과 부적중의 구별
- HTTP는 클라이언트에게 응답이 캐시 적중인지 원 서버 접근인지를 알 수 있는 방법을 제공하지 않는다.
- 일부 프락시 캐시는 Via 헤더에 추가 정보를 포함하지만, 클라이언트는 Date 헤더를 사용해 응답의 생성일을 비교하거나, Age 헤더를 사용해 응답이 얼마나 오래되었는지 확인할 수 있다.

# 6. 캐시 토폴로지
<img width="573" alt="image" src="https://github.com/user-attachments/assets/52cad860-de1b-4101-8287-18f28ec2fea4" />

- **개인 전용 캐시 (private cache)** : 한 명의 사용자만을 위한 캐시, 해당 사용자만 자주 찾는 페이지를 저장한다.
- **공유된 캐시 (public cache)** : 여러 사용자가 공유하는 캐시, 사용자 집단에게 자주 쓰이는 페이지를 저장한다.

## 6.1 개인 전용 캐시
- **개인 전용 캐시** : 웹 브라우저 내장, 자주 쓰이는 문서를 디스크와 메모리에 캐시해 놓는다.
- 브라우저 캐시 관리: 사용자 설정으로 캐시 사이즈 조정 가능, 캐시된 문서를 확인할 수 있다.
  - 예: 인터넷 익스플로러에서는 "임시 파일"로 저장하며, 구글 크롬은 about:cache를 통해 캐시 콘텐츠를 확인할 수 있다.

> Q. about:cache는 현재 크롬에서 더 이상 사용할 수 없나?

## 6.2 공용 프락시 캐시
<img width="568" alt="image" src="https://github.com/user-attachments/assets/f255ebd4-9127-4ce2-8eb3-e4c376dc247a" />

- 공용 캐시(프락시 캐시)는 여러 사용자가 공유하는 캐시로, 자주 요청되는 문서를 한 번만 가져와서 모든 사용자에게 제공함으로써 네트워크 트래픽을 줄인다.
- 개인 전용 캐시에서는 각 사용자가 동일한 문서를 여러 번 네트워크를 통해 가져오지만, 공용 캐시는 이를 한 번만 가져와서 여러 사용자가 공유하게 된다.
- 프락시 캐시는 수동으로 설정하거나 자동설정 파일을 통해 브라우저에서 사용하도록 할 수 있다.
- 또한, 인터셉트 프락시를 사용하면 브라우저 설정 없이 HTTP 요청을 캐시를 거치도록 강제할 수 있다.

## 6.3 프락시 캐시 계층들
<img width="574" alt="image" src="https://github.com/user-attachments/assets/3e40a76b-d99f-45f6-873b-78221c141de6" />

- 작은 캐시에서 캐시 부적중이 발생하면 더 큰 부모 캐시가 트래픽을 처리하는 계층 구조가 효율적이다.
- 클라이언트 근처에는 작은 캐시를 사용하고, 상위 계층에서는 많은 사용자가 공유하는 문서를 저장한다.
- 캐시 계층이 깊어지면 요청은 여러 캐시를 거쳐야 하며, 프락시 연쇄가 길어질수록 성능 저하가 발생할 수 있다.

## 6.4 캐시망, 콘텐츠 라우팅, 피어링
<img width="573" alt="image" src="https://github.com/user-attachments/assets/a66b12d6-26c0-4c9b-8d2a-6b4fb69d1af2" />

- 몇몇 네트워크 아키텍처는 복잡한 캐시망을 만들어, 프락시 캐시가 동적으로 부모 캐시나 원 서버로 요청을 보낸다. 
    - URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택한다.
    - URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.
    - 부모 캐시에게 가기 전에 캐시된 사본을 로컬에서 찾아본다.
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓（Internet transit）’은 허용하지 않는다.
- 다른 조직들이 상호 이득을 위해 캐시를 연결하여 콘텐츠를 공유하고, 선택적 피어링을 지원하는 캐시는 `형제 캐시`라 불린다.
- HTTP는 형제 캐시를 지원하지 않으므로 ICP나 HTCP로 확장된다.

> Q. ICP와 HTCP란?

# 7. 캐시 처리 단계
## 단계 1： 요청 받기
- 캐시는 네트워크 커넥션에서의 활동을 감지하고, 들어오는 데이터를 읽어들인다.
- 고성능 캐시는 여러 연결에서 데이터를 동시에 읽고, 메시지 도착 전 트랜잭션 처리를 시작한다.

## 단계 2： 파싱
- 캐시는 요청 메시지를 파싱하여 헤더를 조작하기 쉬운 구조로 저장한다.

## 단계 3： 검색
- 캐시는 URL을 확인해 로컬 사본이 있는지 검사하며, 메모리, 디스크 또는 다른 컴퓨터에 저장된 사본을 찾는다. 
- 고성능 캐시는 빠른 알고리즘으로 이를 판단하며, 없을 경우 원 서버나 부모 프록시에서 가져오거나 실패를 반환한다. 
- 캐시된 객체에는 서버 응답 본문, 원 서버 헤더, 캐시 유지 기간 및 사용 빈도 등의 메타데이터가 포함된다.

## 단계 4： 신선도 검사
- HTTP는 일정 기간 동안 캐시가 서버 문서의 사본을 보관할 수 있도록 하며, 이 기간 동안 문서는 ‘신선’한 것으로 간주되어 서버와의 접촉 없이 제공된다. 
- 그러나 신선도 한계를 초과하면 ‘신선하지 않은’ 상태가 되어, 제공 전에 서버와 변경 여부를 재검사해야 한다.
- 신선도 규칙은 복잡하며, 다양한 설정 옵션과 비 HTTP 신선도 표준과의 상호작용으로 인해 더욱 어려워졌다.

## 단계 5： 응답 생성
- 캐시는 원 서버에서 온 것처럼 보이도록 캐시된 서버 응답 헤더를 기반으로 응답 헤더를 생성하고 수정한다. 
- 또한, 클라이언트에 맞게 헤더를 조정할 책임이 있으며, HTTP 버전 차이를 번역해야 한다.
- 캐시는 Cache-Control, Age, Expires 등의 신선도 정보를 추가하고, Via 헤더로 프록시 경유 여부를 알린다. 
- 그러나 Date 헤더는 원 서버에서 생성된 시간을 나타내므로 변경하지 않아야 한다.

## 단계 6： 전송
- 응답 헤더가 준비되면, 캐시는 응답을 클라이언트에게 전달한다. 
- 프락시 캐시는 클라이언트와의 연결을 유지해야 하며, 고성능 캐시는 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서 콘텐츠 복사를 피하여 데이터를 효율적으로 전송하려고 한다.

## 단계 7： 로깅
- 대부분의 캐시는 트랜잭션 후 통계를 갱신하고, 요청 종류와 URL 등을 포함한 로그를 기록한다.
- 주요 로그 포맷으로는 스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷이 있으며, 일부 캐시 제품은 사용자 정의 로그 파일을 허용한다.

## 캐시 처리 플로 차트
<img width="575" alt="image" src="https://github.com/user-attachments/assets/9cfab195-ab9f-4ad6-87c0-ef64bc29ddbc" />

# 8. 사본을 신선하게 유지하기
- 캐시된 문서는 시간이 지남에 따라 서버의 원본 문서와 일치하지 않을 수 있다. 
- 문서가 주기적으로 변경되므로, 오래된 데이터를 제공하는 캐시는 불필요하고, 캐시는 서버의 데이터와 일치하도록 관리해야 한다.
- HTTP는 캐시된 사본이 서버와 일치하도록 유지할 수 있는 메커니즘을 제공하며, 이를 **문서 만료**와 **서버 재검사**라고 부른다.

## 8.1 문서 만료
<img width="578" alt="image" src="https://github.com/user-attachments/assets/8607c301-59a5-4613-b4ee-dbb8ba660a11" />

- HTTP는 `Cache-Control`과 `Expires` 헤더를 사용하여 원 서버가 문서의 유효기간을 설정할 수 있게 한다. 
- 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 유지될 수 있는지 결정한다. 
- 캐시된 문서는 만료되기 전에 서버와의 접촉 없이 제공될 수 있지만, 문서가 만료되면 서버와 다시 검사를 통해 신선한 사본을 받아와야 한다.

## 8.2 유효기간과 나이
<img width="610" alt="image" src="https://github.com/user-attachments/assets/440535a3-afcb-4764-a529-ffb779f167cd" />

- 서버는 `Expires`나 `Cache-Control: max-age` 헤더를 사용하여 문서의 유효기간을 명시한다. 
- `Expires`는 절대 시간을 기준으로, `Cache-Control: max-age`는 상대적인 시간(초 단위)으로 유효기간을 설정한다.
- 2002년 6월 29일 오전 9시 30분에 5일간의 할인이 시작되고, 7월 5일 자정에 만료되는 웹페이지의 경우
  - **Expires** : Fri, 05 Jul 2002, 05:00:00 GMT
  - **Cache-Control** : max-age=484200

## 8.3 서버 재검사
- 캐시된 문서가 만료되었다고 해서 문서가 원 서버와 다르다는 의미는 아니며, 단지 재검사가 필요함을 뜻한다.
- 재검사 후, 콘텐츠가 변경되면 캐시는 새로운 사본을 가져와 저장하고 클라이언트에 전달한다.
- 변경되지 않았다면, 캐시는 만료일을 포함한 헤더만 갱신한다. 이 방식은 매 요청마다 신선도를 확인하는 대신 한 번의 재검사를 통해 서버 트래픽을 줄이고 사용자 응답 시간을 개선한다.
- HTTP 프로토콜은 캐시가 "충분히 신선한" 사본을 제공하거나, 재검사를 통해 신선함을 보장하거나, 오류/경고 메시지를 포함할 것을 요구한다.

## 8.4 조건부 메서드와의 재검사
- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.
- 캐시는 서버에게 "조건부 GET" 요청을 보내, 캐시된 문서와 서버의 문서가 다를 경우에만 객체 본문을 요청한다.
- 이를 통해 신선도 검사와 객체 요청이 하나의 조건부 GET으로 결합된다.
- 조건부 GET은 GET 요청에 특별한 조건부 헤더를 추가하여, 웹 서버는 조건이 참일 때만 객체를 반환한다.
- 캐시 재검사에 유용한 조건부 헤더는 If-Modified-Since와 If-None-Match이다. 모든 조건부 헤더는 if-로 시작한다.

<img width="613" alt="image" src="https://github.com/user-attachments/assets/36f36b7e-65d6-468c-8004-574a10bce9e2" />

## 8.5 If-Modified-Since： 날짜 재검사
<img width="577" alt="image" src="https://github.com/user-attachments/assets/4a4160ea-c210-4633-824a-19878dc7773e" />

- `If-Modified-Since` 헤더는 클라이언트가 서버에 문서가 특정 날짜 이후에 변경되었는지 확인하도록 요청하는 헤더이다.
- 이를 통해 효율적으로 캐시를 재검사할 수 있다. 이 요청은 주로 "IMS 요청"이라 불린다.
  - **문서가 변경된 경우** : 서버는 새로운 문서와 함께 갱신된 헤더를 반환한다.
  - **변경되지 않은 경우** : 서버는 `304 Not Modified` 응답을 보내고, 본문은 반환하지 않는다. 필요한 헤더만 갱신된다.
- `If-Modified-Since`는 서버의 `Last-Modified` 헤더와 함께 사용되며, 이를 통해 서버는 문서가 변경되었는지 확인하고 적절한 응답을 보낸다.
- 일부 서버는 날짜 비교 대신 일련번호 비교를 할 수도 있다.

## 8.6 If-None-Match： 엔터티 태그 재검사
<img width="580" alt="image" src="https://github.com/user-attachments/assets/36cdb871-366c-4e49-87a2-9be5c0837791" />

- 최근 변경 일시(If-Modified-Since)로 재검사를 하는 데 어려움이 있을 수 있다.
  - 어떤 문서는 일정 간격으로 갱신되지만 실제 데이터는 변하지 않으며, 변경 시각만 바뀐다.
  - 문서의 일부 사소한 변경(예: 철자나 주석 수정)은 전 세계의 캐시들이 다시 읽어들이기에 충분히 중요한 변화가 아닐 수 있다.
  - 일부 서버는 문서의 정확한 변경 일시를 판별할 수 없으며, 1초보다 짧은 간격으로 갱신되는 경우 변경일에 대한 정밀도가 부족할 수 있다.
- 이런 상황을 해결하려면 `If-None-Match` 헤더를 사용할 수 있다.
  - 퍼블리셔가 문서를 변경하면, 새로운 엔터티 태그를 할당할 수 있다.
  - 엔터티 태그가 변경되면, 캐시는 If-None-Match 헤더를 사용해 새 문서의 사본을 요청할 수 있다.
  - 예를 들어, 캐시가 "v2.6" 태그를 갖고 있을 때, 서버는 태그가 변경되지 않았으면 304 Not Modified 응답을 보내고, 변경되었으면 새 콘텐츠와 함께 200 OK 응답을 보낸다.
  - 여러 개의 엔터티 태그를 If-None-Match 헤더에 포함시킬 수도 있다.
    - 예: `If-None-Match: "v2.6", "v2.5", "foobar"` 

> Q. 어느 경우에 여러 개의 엔터티 태그를 If-None-Match 헤더에 포함할까?

## 8.7 약한 검사기와 강한 검사기
- 캐시는 엔터티 태그를 사용하여 서버의 최신 버전과 비교하며, 이는 최근 변경일시를 사용하는 것과 유사하다.
- 엔터티 태그는 강한 검사기와 약한 검사기로 나눌 수 있다.
  - **강한 검사기** : 콘텐츠가 변경될 때마다 값이 바뀌며, 항상 변경된 내용을 반영한다.
  - **약한 검사기** : 콘텐츠의 중요한 의미가 변경되면 값이 바뀌며, 일부 변경은 허용된다.
- 서버는 약한 검사기를 사용해 일부 변경만으로도 캐시를 무효화하지 않고, 이를 구분하기 위해 "W/" 접두사를 사용한다.
- 서버는 강한 엔터티 태그와 약한 엔터티 태그를 의미가 다른 엔터티에 대해 재사용해서는 안 된다. 
  - 캐시 항목은 유효기간과 관계없이 오래 보관될 수 있기 때문에, 과거의 검사기를 사용해 다시 검사를 시도할 수도 있기 때문이다.

> Q. 한 리소스에 대해 Strong ETag와 Weak ETag는 혼용해서 사용될 수 있는가?

## 8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가
- HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환하면 엔터티 태그 검사기를 사용해야 하며, 서버가 Last-Modified만 반환하면 If-Modified-Since 검사를 사용할 수 있다.
- 엔터티 태그와 최근 변경일시가 모두 제공되면, 클라이언트는 두 가지 재검사 정책을 모두 사용해야 한다.
- HTTP/1.1 서버는 가능하다면 엔터티 태그 검사기를 사용해야 하며, 약한 엔터티 태그를 사용해도 된다. Last-Modified 값을 함께 보내는 것도 권장된다.
- HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를 모두 받으면, 304 Not Modified 응답은 조건을 모두 만족할 때만 반환해야 한다.

# 9. 캐시 제어
## 9.1 no-cache 와 no-store 응답 헤더
- `no-store` : 응답의 사본 저장을 금지하며, 캐시는 해당 응답을 저장하지 않고 즉시 삭제한다.
- `no-cache` : 캐시에 저장될 수는 있지만, 클라이언트가 사용하기 전에 반드시 서버와 재검사를 해야 한다.
- `Pragma: no-cache` : HTTP/1.0과의 하위 호환성을 위한 것으로, HTTP/1.1에서는 `Cache-Control: no-cache`를 사용하는 것이 권장된다.

## 9.2 Max-Age 응답 헤더
- `max-age=3600` : 문서는 3600초(1시간) 동안 신선하다고 판단된다.
- `s-maxage=3600` : max-age와 유사하지만, 공유 캐시에만 적용된다.
- `max-age=0` : 캐시를 방지하거나 항상 서버에서 새로 가져오도록 요청할 수 있다.

## 9.3 Expires 응답 헤더
- `Expires: Fri, 05 Jul 2002, 05:00:00 GMT` : 해당 날짜 이후 문서는 만료된다.
- `문제점` : 서버 시계가 부정확할 수 있어 절대 시간보다 상대 시간(max-age)이 선호된다.
- `Expires: 0` : 문법적으로 올바르지 않으며, 일부 소프트웨어에서 문제를 일으킬 수 있으므로 생성하지 않는 것이 좋다.

## 9.4 Must-Revalidate 응답 헤더
- 캐시는 성능을 개선하기 위해 만료된 객체를 제공하도록 설정될 수 있다.
- `Cache-Control: must-revalidate`는 캐시가 만료된 객체를 제공하기 전에 반드시 원 서버와 재검사를 수행해야 함을 의미한다.
  - 캐시가 만료된 객체를 제공하려 할 때 → 원 서버와 재검사 수행
  - 원 서버가 응답 불가능하면 → `504 Gateway Timeout` 오류 반환

## 9.5 휴리스틱 만료
- `Cache-Control: max-age`나 `Expires` 헤더가 없으면, 캐시는 경험적(heuristic) 방법으로 최대 나이를 계산한다.
### 휴리스틱 만료(Heuristic Expiration)**
- 알고리즘을 사용해 최대 나이를 추정한다.
- 결과값이 24시간 이상이면 **"Warning 13: Heuristic Expiration"** 헤더를 추가한다.(대부분 브라우저는 표시 안 함)

### LM(Last-Modified) 인자 알고리즘
- 문서의 최근 변경 일시(Last-Modified)를 기반으로 신선도 지속 기간을 추정한다.
- 변경된 지 오래된 문서는 더 오래 캐싱 가능, 최근 변경된 문서는 짧게 캐싱한다.
- **계산식** : 

<img width="575" alt="image" src="https://github.com/user-attachments/assets/1bcde91f-0997-4a56-885f-b97feb9486ee" /> 

```
신선도 한계 = (서버 응답 시각 - 문서의 최근 변경 시각) * LM 인자(예: 0.2)
```

- **보편적인 방식**
  - 휴리스틱 신선도 유지기간은 지나치게 길어지는 것을 방지하기 위해 보통 1주일, 보수적인 경우 하루로 설정된다.
  - 최근 변경일이 없으면 캐시는 신선도를 판단하기 어렵고, 기본 유지기간을 보통 1시간 또는 하루로 설정한다.
  - 보수적인 캐시는 0으로 설정해 매번 신선도를 검사하도록 강제한다.
  - 많은 서버가 여전히 만료 관련 헤더를 제공하지 않으므로, 캐시의 만료 기본값을 신중히 선택해야 한다.

## 9.6 클라이언트 신선도 제약
<img width="608" alt="image" src="https://github.com/user-attachments/assets/2d91659c-907c-48b7-8fd8-db54da92904f" />

- 웹 브라우저는 리프레시(새로고침) 또는 리로드(강제 새로고침) 버튼을 통해 캐시된 콘텐츠를 강제로 갱신할 수 있다.
- **리프레시 동작** :
  - Cache-Control 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버에서 새 콘텐츠 가져온다.
  - 정확한 동작은 브라우저, 문서 설정, 중간 캐시 설정에 따라 달라진다.

- **Cache-Control 요청 헤더 사용** :
  - 더 엄격한 만료 정책 적용 → 최신 문서를 유지하려는 애플리케이션(예: 수동 새로고침 버튼).
  - 더 느슨한 만료 정책 적용 → 성능, 신뢰성, 비용 최적화를 위한 절충안.

## 9.7 주의할 점
- 문서 만료 시스템은 완벽하지 않으며, 유효기간 설정이 길거나 아예 없을 경우 캐시는 문서의 신선도를 정확히 판단하기 어렵다.

# 10. 캐시 제어 설정
- 서버는 캐시 제어와 만료 HTTP 헤더를 설정하는 다양한 메커니즘을 제공한다.

## 10.1 아파치로 HTTP 헤더 제어하기
- 아파치 웹 서버는 HTTP 캐시 제어 헤더를 설정하는 다양한 메커니즘을 제공하며, 일부는 기본적으로 비활성화되어 있어 활성화해야 사용 가능하다.

### mod_headers
- 개별 HTTP 헤더를 설정할 수 있게 해준다.
- 예: 특정 디렉터리의 모든 HTML 파일에 Cache-Control: no-cache 헤더 설정.
```
<Files *.html>
  Header set Cache-control no-cache
</Files>
```

### mod_expires
- 만료 날짜가 포함된 Expires 헤더를 자동으로 생성한다.
- 예: "access plus 1 month", "modification plus 2 days 6 hours 12 minutes"와 같은 형식을 사용해 파일별로 만료 날짜 설정.
```
ExpiresDefault A3600
ExpiresDefault M86400
ExpiresDefault "access plus 1 week"
ExpiresByType text/html "modification plus 2 days 6 hours 12 minutes"
```

### mod_cern_meta
- 파일에 대응되는 메타파일을 생성하여 해당 메타파일에 헤더를 추가하는 방식으로 파일과 HTTP 헤더를 연결시킨다.

## 10.2 HTTP-EQUIV 통한 HTML 캐시 제어
<img width="581" alt="image" src="https://github.com/user-attachments/assets/4a70ed87-4f87-470e-8010-38bffd7ee83f" />

- HTML 2.0에서 도입된 `<META HTTP-EQUIV>` 태그는 웹 서버 설정 없이 HTML 문서에서 직접 HTTP 헤더를 정의할 수 있도록 돕는다. 
- 이 태그는 문서의 최상단에 위치하며, 예를 들어 Cache-Control: no-cache와 같은 캐시 제어 정보를 포함할 수 있다.
```
<HTML>
  <HEAD>
    <TITLE>My Document</TITLE>
    <META HTTP-EQUIV="Cache-control” CONTENT="no-cache">
  </HEAD>
```
- 즉, `<META HTTP-EQUIV>` 태그는 원래 웹 서버가 HTML을 처리할 때 헤더를 삽입하는 데 사용되며, 웹 서버가 해당 헤더를 응답에 포함시킨다.
- 하지만 이 기능은 대부분의 웹 서버나 프락시에서 지원되지 않는다. 그 이유는 서버에 부담을 주고, 이 방식은 HTML 파일 외의 다른 타입 파일에는 적용되지 않기 때문이다.
- 문제는 몇몇 브라우저가 이 태그를 파싱하여 실제 HTTP 헤더처럼 처리하는 점이다. 
- 그러나 이러한 브라우저는 프락시 캐시와 다른 캐시 제어 규칙을 적용할 수 있기 때문에, 캐시 만료 동작에 혼란을 초래할 수 있다.
- 결과적으로, 문서의 캐시 제어를 정확하게 요청하고 전달하려면, 올바르게 설정된 웹 서버에서 직접 보내는 HTTP 헤더를 사용하는 것이 가장 확실한 방법이다.