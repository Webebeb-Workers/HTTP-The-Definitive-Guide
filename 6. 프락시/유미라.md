# 웹 중개자
<img width="578" alt="image" src="https://github.com/user-attachments/assets/46a6eecd-2126-4e52-bded-dcfc9fb494c1" />

- 웹 프락시 서버는 클라이언트와 서버 간의 중개 역할을 하며, 클라이언트는 프락시 서버를 통해 서버와 통신한다. 
- 프락시 서버는 HTTP 서버이자 클라이언트의 기능을 모두 수행하며, 요청을 처리하고 응답을 반환해야 한다.

## 개인 프락시와 공유 프락시
- **개인 프락시** : 한 명의 클라이언트만 사용, 주로 사용자 컴퓨터에서 실행한다.
- **공용 프락시** : 여러 클라이언트가 공유, 관리가 용이하고 캐시 프락시 같은 경우 사용자 수가 많을수록 효율적이다.

## 프락시 대 게이트웨이
- **프락시** : 같은 프로토콜을 사용하는 클라이언트와 서버를 연결한다. 예: HTTP 프락시
- **게이트웨이** : 서로 다른 프로토콜을 사용하는 클라이언트와 서버를 연결하고, 프로토콜 변환을 수행한다. 예: HTTP/POP 게이트웨이
- 실제로는 두 개념이 겹치는 경우가 많고, 일부 프락시는 프로토콜 변환 기능을 포함하기도 한다.

# 왜 프락시를 사용하는가?
- 프락시 서버는 보안을 개선하고 성능을 높이며 비용을 절감하는 등 다양한 실용적인 역할을 한다. 
- 모든 HTTP 트래픽을 모니터링하고 수정할 수 있어, 이를 통해 부가적인 가치를 제공하는 여러 유용한 웹 서비스를 구현할 수 있다.

## 어린이 필터
<img width="582" alt="image" src="https://github.com/user-attachments/assets/3f76efec-b5be-4d84-98fa-00173259ec5e" />

- 필터링 프락시는 초등학교처럼 어린이에게 교육 콘텐츠를 제공하면서 부적절한 성인 콘텐츠를 차단하는 데 사용된다. 
- 프락시는 교육 콘텐츠에는 제한 없이 접근을 허용하고, 부적절한 사이트에 대한 접근은 강제로 차단할 수 있다.

## 문서 접근 제어자
<img width="574" alt="image" src="https://github.com/user-attachments/assets/bbbfd918-fbc5-4c6c-a058-b442af3846cc" />

- 프락시 서버는 여러 웹 서버와 리소스에 대한 단일 접근 제어 전략을 구현하고 감사 추적을 가능하게 한다.
- 이는 대기업 환경이나 분산된 조직에서 유용하며, 다양한 웹 서버에 대한 접근 제어를 중앙 프락시 서버에서 관리하고 갱신할 수 있다. 

## 보안 방화벽
<img width="574" alt="image" src="https://github.com/user-attachments/assets/d7b49c9a-a968-4aea-81dd-687a7849c0f4" />

- 프락시 서버는 네트워크 보안 강화에 사용되며, 응용 레벨 프로토콜 흐름을 통제한다. 
- 트래픽을 세밀하게 분석하고, 바이러스를 제거하는 기능을 제공하는 후크(hook)를 통해 보안을 강화한다.

## 웹 캐시
<img width="576" alt="image" src="https://github.com/user-attachments/assets/9834cc75-352d-4a63-85e7-94e7b6a594a8" />

-  프락시 캐시는 인기 있는 문서를 로컬에 저장해 빠르게 제공함으로써 인터넷 통신 속도를 개선하고 비용을 절감한다.

## 대리 프락시
<img width="570" alt="image" src="https://github.com/user-attachments/assets/fc49d534-4a9d-4694-a2a3-357747959b61" />

- 웹 서버처럼 요청을 받아 실제 콘텐츠가 있는 서버와 통신해 사용자에게 전달한다.
- 예 : 느린 웹 서버의 성능 개선(서버 가속기로 활용), 콘텐츠 라우팅과 결합해 복제 콘텐츠의 분산 네트워크 구축

## 콘텐츠 라우터
<img width="571" alt="image" src="https://github.com/user-attachments/assets/ce348d5c-1644-4c80-8a63-aeb20ec2d99e" />

- 프락시 서버는 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작할 수 있다. 
- 이를 통해 성능 향상을 원하는 사용자에게는 가까운 복제 캐시로, 필터링 서비스에 가입한 사용자에게는 필터링 프락시를 거치도록 요청을 전달하는 등 맞춤형 서비스를 제공할 수 있다.

## 트랜스코더
<img width="583" alt="image" src="https://github.com/user-attachments/assets/5e70a072-4f31-421d-b0ea-2a2f683157a8" />

- 트랜스코딩 프락시는 콘텐츠를 전달하기 전에 포맷을 수정한다.
- 이미지 변환, 텍스트 압축, 웹페이지 축소, 외국어 번역 등으로 다양한 기기와 상황에 맞는 콘텐츠를 제공한다.

## 익명화 프락시
<img width="576" alt="image" src="https://github.com/user-attachments/assets/9531b266-f1cc-4c18-9a52-7f733d23d625" />

- 익명화 프락시는 HTTP 메시지에서 개인 정보를 식별할 수 있는 요소(IP 주소, 헤더, 쿠키 등)를 제거해 개인 정보 보호와 익명성을 보장한다.
- 예를 들어, User-Agent 헤더에서 컴퓨터 정보 제거, From 헤더에서 이메일 주소 삭제, Referer 헤더와 Cookie 헤더를 제거해 신원 정보를 숨긴다.

# 프락시는 어디에 있는가?
## 프락시 서버 배치
<img width="573" alt="image" src="https://github.com/user-attachments/assets/5b14bf51-91f4-4d21-b548-e65ed3293ef1" />

### 출구 프락시
- 출구 프락시는 로컬 네트워크와 외부 인터넷 사이의 트래픽을 제어하는 역할을 한다. 
- 이를 통해 해커로부터 보호하거나, 인터넷 요금을 절감하고 성능을 개선할 수 있다. 
- 예를 들어, 초등학교에서는 부적절한 콘텐츠의 접근을 차단하기 위해 필터링 출구 프락시를 사용할 수 있다.

### 접근 프락시
- 접근(입구) 프락시는 ISP의 접속 지점에 배치되어 고객 요청을 처리하다.
- 자주 요청되는 문서를 캐시하여 다운로드 속도를 개선하고 대역폭 비용을 절감한다.

### 대리 프락시
- 대리 프락시(리버스 프락시)는 네트워크의 끝에 위치하여 웹 서버로 향하는 요청을 처리하고, 필요할 때만 웹 서버와 통신한다. 
- 이 프락시는 웹 서버의 앞에 위치해 보안을 강화하고, 캐시 기능을 통해 성능을 개선할 수 있다. 
- 대리 프락시는 웹 서버의 이름과 IP 주소로 스스로를 가장해 모든 요청을 자신에게 유도한다.

### 네트워크 교환 프락시
- 네트워크 교환 프락시는 인터넷 피어링 교환 지점에 배치되어 트래픽 흐름을 감시하고 캐시를 활용하여 혼잡을 완화하는 역할을 한다.

## 프락시 계층
<img width="570" alt="image" src="https://github.com/user-attachments/assets/abce1ffe-ec57-4f0d-b109-7275376ee868" />

- 프락시 계층은 여러 프락시 서버들이 서로 연결된 구조로, 메시지가 최종 원 서버에 도달할 때까지 여러 프락시를 거친다. 
- 이 계층에서는 프락시 서버들이 부모-자식 관계를 가지며, 인바운드 프락시(서버에 가까운)와 아웃바운드 프락시(클라이언트에 가까운)로 구분된다. 
- 예를 들어, 프락시 2는 프락시 3의 자식이고, 프락시 3은 프락시 2의 부모이다.

### 프락시 계층 콘텐츠 라우팅
<img width="570" alt="image" src="https://github.com/user-attachments/assets/7cd19110-0a9b-4964-87fd-0105a9f3a66d" />

- 프락시 계층은 일반적으로 고정적이지 않으며, 프락시 서버는 다양한 조건에 따라 메시지를 다른 프락시 서버나 원 서버로 동적으로 라우팅할 수 있다.
- 예를 들어, 요청된 객체에 따라 가까운 캐시 서버나 압축 프락시로 메시지를 보낸다.
- 프락시 서버는 상황에 맞게 부모 프락시나 원 서버로 요청을 라우팅할 수 있다.

### 동적 부모 선택 예시
- **부하 균형** : 자식 프락시는 부모 프락시의 작업량을 기준으로 선택하여 부하를 분산한다.
- **지리적 인접성** : 자식 프락시는 원 서버의 위치를 고려해 해당 지역을 담당하는 부모를 선택한다.
- **프로토콜/타입 라우팅** : 자식 프락시는 요청의 프로토콜이나 URI 유형에 따라 다른 부모나 원 서버로 라우팅할 수 있다.
- **특별 서비스 라우팅** : 유료 서비스 가입자는 성능 개선을 위해 캐시나 압축 엔진으로 라우팅될 수 있다.

> 동적 부모 라우팅 로직은 제품마다 다르게 구현된다.

## 어떻게 프락시가 트래픽을 처리하는가
<img width="577" alt="image" src="https://github.com/user-attachments/assets/b4f218e1-7919-4772-b3d8-fda3bf0368a0" />

### 클라이언트를 수정한다
- 구글 크롬과 마이크로소프트의 웹 브라우저를 포함한 많은 웹 클라이언트들은 수동 또는 자동으로 프락시 설정을 지원한다. 
- 클라이언트가 프락시를 사용하도록 설정되면, 클라이언트는 HTTP 요청을 원 서버로 직접 보내지 않고 의도적으로 프락시 서버를 통해 요청을 전달한다.

### 네트워크를 수정한다
- 인터셉트 프락시는 클라이언트가 알지 못한 채 웹 트래픽을 가로채어 프락시로 전달하는 기술이다.
- 이 방식은 HTTP 트래픽을 감시하고 가로채는 스위칭 장치나 라우팅 장치를 필요로 하며, 클라이언트는 이를 인식하거나 제어할 수 없다.
- 이를 통해 트래픽은 의도적으로 프락시로 리디렉션된다.

### DNS 이름공간을 수정한다
- 대리 프락시(리버스 프락시)는 웹 서버 앞에 위치하며, 클라이언트의 요청을 직접 처리하는 대신 웹 서버에 전달한다.
- 이 프락시는 웹 서버의 이름과 IP 주소를 대신 사용하여, 모든 요청이 대리 프락시로 향하게 된다. 
- 이 과정은 수동으로 DNS 이름 테이블을 편집하거나, 동적 DNS 서버를 통해 자동으로 처리될 수 있다.
- 일부 시스템에서는 실제 서버의 주소와 이름이 변경되고, 대리 프락시에게는 기존 주소와 이름이 할당된다.

### 웹 서버를 수정한다
- 웹 서버는 HTTP 리다이렉션 명령(응답 코드 305)을 클라이언트에게 보내어 요청을 프락시로 리다이렉트할 수 있다.
- 클라이언트는 이 리다이렉션을 받은 후, 프락시 서버와의 트랜잭션을 시작하게 된다.

# 클라이언트 프락시 설정
## 클라이언트 프락시 설정 : 수동
- 웹 클라이언트는 프락시를 수동으로 설정할 수 있다. 
- 구글 크롬과 마이크로소프트 인터넷 익스플로러는 각각 설정 메뉴에서 간편하게 프락시를 설정할 수 있는 기능을 제공한다. 
- 사용자는 프락시의 호스트와 포트를 지정하며, 일부 ISP는 맞춤형 운영 체제를 제공해 웹 트래픽을 자동으로 프락시 서버로 리다이렉트한다.

## 클라이언트 프락시 설정 : PAC 파일
<img width="610" alt="image" src="https://github.com/user-attachments/assets/d2dd8dd3-e87d-4691-8c55-ffea68bb3de7" />

- 수동 프락시 설정은 간단하지만 유연하지 않으며 장애 시 대체 옵션이 없고, 많은 브라우저를 설정하는 데 어려움이 있다. 
- 반면, PAC 파일은 자바스크립트로 동적으로 프락시 서버를 계산해 주며, 브라우저는 이를 사용해 각 요청에 적합한 프락시를 선택한다.
- PAC 파일은 .pac 확장자를 가지며, FindProxyForUrl(url, host) 함수로 프락시 서버를 지정한다.

## 클라이언트 프락시 설정 : WPAD
- 웹 프락시 자동발견 프로토콜(WPAD)은 브라우저가 자동으로 적합한 PAC 파일을 찾아 설정할 수 있게 해주는 프로토콜이다.
- WPAD는 다양한 발견 메커니즘을 사용하여 PAC URI를 찾고, 해당 파일을 통해 프락시 서버를 알아낸 뒤 요청을 처리한다.
- WPAD는 여러 방법을 순차적으로 시도하여 PAC 파일을 찾는데, 그 방법에는 DHCP, SLP, DNS 잘 알려진 호스트 명, DNS SRV 레코드, DNS TXT 레코드 등이 포함된다.

# 프락시 요청의 미묘한 특징들
<img width="570" alt="image" src="https://github.com/user-attachments/assets/bc8b9726-55ef-4ece-8071-6bf29419ed71" />

## 프락시 URI는 서버 URI와 다르다
- HTTP 초기 설계에서는 단일 서버와 직접 통신했기 때문에 부분 URI만 사용했다.
- 프락시가 등장하면서 목적지 정보를 포함한 완전한 URI가 필요하게 되었다.
- 기존 서버들이 부분 URI를 처리하도록 설계되었기 때문에 완전한 URI로의 전환은 제한적이었다.
- 결과적으로, 서버 요청은 부분 URI, 프락시 요청은 완전한 URI를 사용하게 되었습니다.

### 웹 서버 요청
- 클라이언트가 서버로 요청을 보낼 때 부분 URI만 포함한다.
- 예: GET /index.html HTTP/1.0
- 서버는 자신의 호스트명과 포트번호를 알고 있어 추가 정보가 불필요하다.

### 웹 프락시 요청
- 클라이언트가 프락시로 요청을 보낼 때는 완전한 URI를 포함한다.
- 예: GET http://www.example.com/index.html HTTP/1.0
- 프락시는 목적지 서버와 연결하기 위해 서버의 호스트명, 스킴, 포트번호를 알아야 한다.

## 가상 호스팅에서 일어나는 같은 문제

- 가상 호스팅 웹 서버는 여러 웹사이트가 하나의 물리적 서버를 공유하는 방식으로, 요청이 부분 URI로 들어오면 요청이 어떤 웹사이트를 대상으로 하는지 파악하기 위해 호스트 정보를 알아야 한다.
- **명시적인 프락시** : 요청 메시지에 완전한 URI를 포함하도록 요구한다.
- **가상 호스팅 서버** : Host 헤더에 호스트와 포트 정보를 포함해 요청하도록 요구한다.

## 인터셉트 프락시는 부분 URI를 받는다
- 일부 프락시는 클라이언트에게 보이지 않으며, 클라이언트는 자신이 웹 서버와 직접 대화하고 있다고 착각할 수 있다.
- **대리 프락시** : 원 서버의 호스트명과 IP 주소를 사용해 원 서버를 대신하는 프락시
- **인터셉트 프락시** : 네트워크 트래픽을 가로채고 캐시된 응답을 돌려주는 프락시
    - 인터셉트 프락시는 클라이언트와 서버 간 트래픽을 가로채기 때문에 클라이언트가 보낸 부분 URI만을 받게 된다.

## 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다
### 1. 완전한 URI가 주어진 경우
- 프락시는 해당 URI를 사용해야 한다.

### 2. 부분 URI가 주어지고 Host 헤더가 있는 경우
- Host 헤더에서 포트 번호를 확인하여 처리해야 한다.

### 3. 부분 URI가 주어지지만 Host 헤더가 없는 경우
- **대리 프락시** : 원 서버를 대신하므로 내부 설정된 포트 번호를 사용할 수 있다.
- **인터셉트 프락시** : 이전에 가로챈 트래픽을 통해 원 서버의 주소와 포트 번호를 알고 있다면 이를 사용할 수 있다.

### 4. 모든 방법이 실패한 경우
- 프락시는 원 서버를 알아낼 정보가 부족하므로 에러 메시지를 반환해야 한다.

## 전송 중 URI 변경
- 프락시는 URI 변경 시 상호운용성 문제를 일으킬 수 있으므로, 변경을 최소화해야 한다.
- 엄격한 프로토콜 준수는 기존 시스템에 심각한 문제를 일으킬 수 있다.
- 특히, HTTP 명세에 따르면 인터셉트 프락시는 URI의 절대 경로를 수정해서는 안 된다. 
    - 유일한 예외는 빈 경로를 `/`로 교체하는 경우뿐이다.

## URI 클라이언트 자동확장과 호스트 명 분석(Hostname Resolution)
- 사용자가 타이핑한 URI를 기반으로 IP 주소를 찾는다.
- 호스트명이 발견되면 그에 대응하는 IP 주소를 연결할 때까지 시도한다.
- 호스트명이 발견되지 않으면, 브라우저는 사용자 입력을 약어로 인식하고, 이를 자동으로 확장하려고 시도한다.
    - 예를 들어, 'yahoo'를 입력하면 'www.yahoo.com'으로 변환된다.
    - 서드파티 사이트로 URI를 넘기기도 하며, 해당 사이트는 오타를 교정하고 사용자가 의도한 URI를 제시할 수 있다.
    - 대부분의 시스템에서 DNS는 사용자가 호스트 명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정되어 있다.

## 프락시 없는 URI 분석(URI Resolution)
<img width="577" alt="image" src="https://github.com/user-attachments/assets/7df2c02c-8a73-4255-a3f9-27d81ad27b4b" />

- 사용자가 브라우저 주소창에 oreilly와 같은 불완전한 호스트 명을 입력한다.
- 브라우저는 이를 http://oreilly로 간주하고, 기본 포트인 `80`과 기본 경로인 `/`를 사용하려고 시도한다.
- 브라우저는 먼저 oreilly라는 호스트 명을 DNS에 요청하여 해당 IP 주소를 찾으려 합니다. 이 과정에서 실패한다.
- 실패 후, 브라우저는 자동으로 www.oreilly.com으로 확장하여 DNS에 다시 요청을 보낸다.
- DNS는 www.oreilly.com의 IP 주소를 찾아 브라우저에 반환합니다. 이제 브라우저는 www.oreilly.com으로 연결할 수 있다.

## 명시적인 프락시를 사용할 때의 URI 분석
<img width="579" alt="image" src="https://github.com/user-attachments/assets/c40f7986-0fd1-4115-924f-1b1885016818" />

- 명시적인 프락시 사용 시, 사용자가 브라우저 주소창에 oreilly와 같은 불완전한 호스트 명을 입력하면, 브라우저는 더 이상 자동으로 주소를 확장하지 않는다.
- 브라우저는 http://oreilly/와 같이 입력된 대로의 호스트 명을 그대로 사용하고, 기본 스킴(http://)과 기본 경로(/)만 추가하여 프락시 서버로 요청을 보낸다.
- 일부 프락시 서버는 자동 확장과 같은 브라우저의 서비스를 흉내 내려고 시도할 수 있다.

## 인터셉트 프락시를 이용한  URI 분석
<img width="573" alt="image" src="https://github.com/user-attachments/assets/c158dac6-da1c-4bdb-9fa4-6d451dc5da6a" />

- 브라우저는 불완전한 호스트 명을 입력할 경우 자동 확장을 통해 전체 URL을 만들어 DNS 요청을 한다.
- 인터셉트 프락시가 개입하면, 브라우저는 원 서버가 아닌 프락시 서버에 먼저 연결하고, 이후 프락시 서버가 원 서버와 연결을 시도한다.
- 만약 원 서버가 다운되었으면, 프락시 서버는 장애 허용을 위해 다른 IP 주소를 시도해야 한다.
- 장애 허용은 프락시 서버가 처리해야 하며, 이는 명시적인 프락시와 인터셉트 프락시 모두에서 중요하다.

# 메시지 추적
<img width="574" alt="image" src="https://github.com/user-attachments/assets/bd59d97a-0c37-446b-9d3b-736ee3f07eaf" />

- 웹 요청은 클라이언트에서 서버로 가는 도중에 여러 프락시를 거치는 일이 흔해지고 있다.
- 프락시가 보편화됨에 따라 프락시를 넘나드는 메시지의 흐름을 추적하고 문제를 찾아내는 일도 중요해졌다.

## Via 헤더
<img width="582" alt="image" src="https://github.com/user-attachments/assets/5167512f-db72-43f6-805a-19d80d9c0482" />

- Via 헤더 필드는 HTTP 메시지가 거친 각 중간 노드(프락시나 게이트웨이)의 정보를 기록하는 데 사용된다. 
- 메시지가 새로운 노드를 지날 때마다 해당 노드는 Via 목록에 추가된다.
- 예 : Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com

### 주요 역할
- 메시지의 전달을 추적하고, 메시지 루프를 진단하고, 요청을 보내고 그에 대한 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용된다.
- 프락시는 요청을 보내기 전에 자신을 고유한 문자열로 Via 헤더에 삽입하고, 나중에 해당 문자열이 포함된 요청을 통해 네트워크 라우팅 루프를 감지한다.

### Via 문법
<img width="488" alt="image" src="https://github.com/user-attachments/assets/eec107ed-d688-471a-b292-130d12310f24" />

- Via 헤더 필드는 쉼표로 구분된 경유지(waypoint)의 목록이다.
- 각 경유지는 개별 프락시 서버나 게이트웨이 흡을 나타내며 그들 중간 노드의 프로토콜과 주소에 대한 정보를 담고 있다.
- 각 Via waypoint는 프로토콜 이름(선택. 기본은 HTTP), 프로토콜 버전(필수), 노드 이름(필수), 코멘트(선택) 최대 4가지 구성요소를 담을 수 있다. 

#### 프로토콜 이름
- HTTP는 이름 생략 가능, 비 HTTP는 이름 필수
- 프로토콜 이름은 버전 앞에 `/`로 구분되어 붙는다.

#### 프로토콜 버전
- 버전 포맷은 프로토콜에 따라 달라진다.
- HTTP의 경우, 표준 버전 번호 (1.0, 1.1 등)가 사용된다.
- Via 필드에 버전 정보가 포함되며, 이를 통해 애플리케이션은 중개자들이 다룬 프로토콜 버전을 알 수 있다.

#### 노드 이름
- 중개자의 호스트와 포트 번호
- 포트 번호가 없다면, 사용 중인 프로토콜의 기본 포트로 간주된다.
- 정보 보호를 위해 일부 조직은 실제 호스트 명을 공개하지 않고 가명을 사용할 수 있다.

#### 노드 코멘트
- 중개자 노드를 서술하는 선택적인 코멘트 필드가 있다.
- 이 필드는 벤더나 버전 정보, 또는 장치 이벤트에 대한 진단 정보를 포함하는 데 사용될 수 있다.

### Via 요청과 응답 경로
<img width="571" alt="image" src="https://github.com/user-attachments/assets/e341fad2-0157-4b1a-87e8-2bd1fa3f1728" />

- 요청 메시지와 응답 메시지 모두 프락시를 지나므로 둘 다 Via 헤더를 포함한다.
- 응답의 Via 헤더는 요청의 Via 헤더와 반대입니다.

### Via와 게이트웨이
- 일부 프락시는 HTTP 외의 프로토콜을 사용하여 게이트웨이 역할을 하며, 이를 Via 헤더에 기록하여 HTTP 애플리케이션이 프로토콜 변환을 인식할 수 있도록 돕는다.
- 예를 들어, HTTP 클라이언트가 FTP URI를 요청하면, HTTP 요청은 FTP로 변환되어 FTP 서버와 통신 후 응답이 HTTP로 돌아온다.
- Via 헤더는 이 과정과 관련된 프로토콜 정보를 담고 있으며, 선택적으로 벤더나 버전 정보를 포함할 수 있다.

### Server 헤더와 Via 헤더
- Server 응답 헤더는 원 서버에서 사용하는 소프트웨어 정보를 제공gks다. 
- 예를 들어, Apache, Netscape-Enterprise, Microsoft-IIS 등이 포함될 수 있다. 
- 프락시가 응답 메시지를 통과시킬 때, Server 헤더를 수정해서는 안 되며, 대신 Via 헤더 항목을 추가해야 한다.

### Via가 개인정보 보호와 보안에 미치는 영향
- 프락시 서버가 네트워크 방화벽 뒤에 있을 때, 프락시는 원래 호스트 이름과 포트를 공개해서는 안 된다. 이 정보가 악용될 수 있기 때문이다.
- 만약 호스트 이름을 전달할 수 없다면, 프락시는 그 호스트의 이름을 가명으로 교체해야 한다. 하지만 이를 위해서는 각 프락시 서버에 대한 Via 항목을 그대로 유지하려고 노력해야 한다.
- 프락시는 보안상의 이유로 네트워크 아키텍처를 숨기기 위해 Via 항목을 합칠 수 있지만, 동일한 조직의 통제하에 있지 않거나 프로토콜 값이 다른 항목들은 합쳐서 전달해서는 안 된다. 

## TRACE 메서드
<img width="571" alt="image" src="https://github.com/user-attachments/assets/d86a2c45-1e46-4f68-8da1-3144da24a2ec" />

- 프락시 서버는 메시지가 전달되는 동안 메시지를 수정할 수 있다. 예를 들어, 헤더를 추가하거나 수정하거나 삭제하고, 본문 형식을 변경할 수 있다. 
- HTTP/1.1의 TRACE 메서드는 요청 메시지가 프락시를 거치면서 어떻게 수정되는지 추적하는 데 유용하다. 
- TRACE 요청이 서버에 도달하면, 서버는 요청 메시지를 그대로 응답 본문에 포함해 클라이언트에게 돌려보낸다.
- 이를 통해 클라이언트는 메시지와 그 메시지가 지나간 프락시 목록을 확인할 수 있다.

### Max-Forwards
- TRACE 메시지는 일반적으로 중간 프락시의 개수를 신경 쓰지 않고 목적지 서버까지 전달된다. 
- 그러나 Max-Forwards 헤더를 사용하여 프락시의 경유 횟수를 제한할 수 있다. 
- 이 헤더는 메시지가 무한 루프에 빠지지 않도록 하고, 프락시 연쇄 중간의 특정 프락시들의 영향을 확인하는 데 유용하다. 
- Max-Forwards 값이 0이면 메시지를 더 이상 전달하지 않고 클라이언트에게 응답을 돌려줘야 한다. 
- 값이 0보다 크면, 각 프락시에서 해당 값을 1씩 감소시켜 전달해야 한다. 
- 모든 프락시와 게이트웨이는 Max-Forwards를 지원해야 한다.

# 프락시 인증
<img width="530" alt="image" src="https://github.com/user-attachments/assets/db735e67-1cbb-4a17-910a-5444601c18e7" />

- 프락시 인증은 HTTP에서 접근 제어 메커니즘으로 사용된다.
- 요청이 제한된 콘텐츠에 도달하면, 프락시 서버는 407 Proxy Authorization Required 상태 코드와 함께 Proxy-Authenticate 헤더를 반환하여 자격 증명을 요구한다.
- 클라이언트는 자격을 수집하고, 이를 Proxy-Authorization 헤더에 담아 요청을 다시 보낸다.
- 자격이 유효하면 프락시는 요청을 연쇄에 따라 전달하고, 유효하지 않으면 407 응답을 반복한다. 
- 여러 프락시가 있을 경우 인증 문제는 잘 해결되지 않으며, 이에 대한 해결책은 널리 채택되지 않았다.

# 프락시 상호운용성
- 프락시 서버는 여러 HTTP 명세 버전과 다양한 벤더에 의해 구현되며, 각 프락시는 서로 다른 기능을 지원하고 다양한 버그를 가질 수 있다. 
- 이로 인해 클라이언트와 서버 간의 중개 역할을 하면서 예기치 않은 동작이나 프로토콜 구현 차이로 문제가 발생할 수 있다.

## 지원하지 않는 헤더와 메서드 다루기
- 프락시 서버는 모든 헤더 필드를 이해하지 못할 수 있다.
- 이해할 수 없는 헤더는 그대로 전달해야 하며, 동일한 이름의 헤더 필드는 순서를 유지해야 한다. 
- 또한, 프락시가 특정 메서드에 익숙하지 않다면, 그 메시지를 다음 홉으로 전달하려고 시도해야 한다.
- 프락시가 지원하지 않는 메서드를 처리할 수 없다면, 해당 프락시는 네트워크에서 정상적으로 동작하지 않을 가능성이 있다.
- HTTP/1.1은 메서드 확장을 허용한다. 예 : WebDAV

## OPTIONS： 어떤 기능을 지원하는지 알아보기
<img width="529" alt="image" src="https://github.com/user-attachments/assets/c3838862-0ee0-4f0f-a35d-bbd8f9c67499" />

- HTTP OPTIONS 메서드는 클라이언트나 프락시가 서버나 특정 리소스가 지원하는 기능을 알아볼 수 있게 해준다. 
- URI가 *일 경우, 서버 전체의 기능을 묻고, 특정 리소스 URI를 사용하면 해당 리소스의 기능을 묻게 된다. 
- HTTP/1.1에서 성공적인 OPTIONS 요청에 대해, 서버는 Allow 헤더를 포함한 200 OK 응답을 반환하며, 이 헤더는 서버에서 지원하는 메서드를 나열한다. 
- 추가 정보는 선택적인 응답 본문에 포함될 수 있으나, 이에 대한 정의는 없다.

## Allow 헤더
- Allow 엔터티 헤더 필드는 요청 URI가 식별하는 자원에 대해 지원되는 메서드들을 나열한다. 
- 요청 URI가 *인 경우, 서버가 지원하는 모든 메서드를 열거한다. 예를 들어, Allow: GET, HEAD, PUT과 같은 형태로 나타날 수 있다. 
- 또한, Allow 헤더는 새 리소스가 지원할 수 있는 메서드를 추천하기 위한 요청 헤더로 사용할 수 있다. 
- 하지만 서버는 반드시 이 메서드들을 지원해야 할 의무는 없으며, 응답에는 실제로 지원하는 메서드들이 열거되어야 한다. 
- 프락시는 메서드를 이해할 수 없어도, Allow 헤더를 수정할 수 없다.