# HTTP 아키텍처 개요

2장 시작. 웹 시스템 아키텍처의 핵심 구성 요소들에 대한 설명으로 구성된 6개의 챕터.

## 주요 구성 요소

1. **웹 서버** : 기본적인 웹 서버 아키텍처와 구현
2. **프락시** : HTTP 서비스와 제어를 위한 중개 서버의 역할과 기능
3. **캐시** : 자주 요청되는 문서의 지역 사본을 통한 트래픽 감소와 성능 향상 메커니즘
4. **게이트웨이** : 서로 다른 프로토콜 간 HTTP 기반 상호작용 지원 시스템
5. **웹 로봇** : HTTP 아키텍처를 활용하는 웹 클라이언트의 구현
6. **HTTP/2.0** : HTTP/1.1의 성능 개선을 위해 도입된 새로운 프로토콜의 특징

각 구성 요소는 웹의 효율적인 동작을 위한 고유한 역할을 수행하며 상호 연계된 구조를 형성.

---

# 웹 서버

HTTP를 통해 웹페이지를 제공하는 웹의 핵심 구성요소. 매일 수십억 개의 웹페이지를 처리해 날씨 정보 제공, 온라인 쇼핑, 소셜 네트워킹 등 다양한 서비스의 기반이 되는 월드 와이드 웹의 일꾼.

## 웹 서버의 정의 & 형태

> [!NOTE]
> HTTP 요청을 처리하고 응답을 제공하는 시스템, 소프트웨어적 측면과 하드웨어적 측면을 모두 포함하는 개념
> 클라이언트의 HTTP 요청을 받아 적절한 리소스를 응답으로 전달하는 과정에서 일련의 핵심 작업들을 순차적으로 수행하는 시스템.

기능과 형태, 크기가 다양하나 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 전달하는 공통된 목적을 가짐.

## 웹 서버의 구현 방식

웹 서버는 HTTP 프로토콜과 TCP 처리를 구현하고 리소스를 관리하며 서버 관리 기능을 제공.
TCP 커넥션 관리는 운영체제와 책임을 공유하는 구조. 운영체제는 하드웨어 관리, TCP/IP 네트워크 지원, 파일 시스템 유지, 프로세스 관리 등을 담당.

구현 형태는 크게 두 가지임.

- **다목적 소프트웨어 웹 서버** : 표준 컴퓨터 시스템에 설치돼 실행
- **임베디드 웹 서버** : 전자기기에 내장돼 관리 콘솔로 제공

### 다목적 소프트웨어 웹 서버의 현황

> [!NOTE]
> 네트워크에 연결된 표준 컴퓨터 시스템에서 동작하는 서버 소프트웨어
> 오픈 소스(아파치, W3C 직소)와 상용 소프트웨어(마이크로소프트, 아이플래닛) 모두 존재

#### 2014년 넷크래프트 조사 기준 시장 점유율

<img width="673" alt="image" src="https://github.com/user-attachments/assets/fc3b6396-5c47-41cd-90df-3a714d23a81d" />

- 마이크로소프트 웹 서버 : 37%
- 아파치 웹 서버 : 35%
- nginx 서버 : 14%

\+ 현재 책에서 나온 [링크](http://news.netcraft.com/archives/2014/08/27/august-2014-web-server-survey.html)는 404가 떠서 못보고, 웹 서버를 검색할 수 있는 [**사이트**](https://searchdns.netcraft.com/)는 있음.

### 임베디드 웹 서버의 특징

일반 소비자용 제품에 내장되는 소형 웹 서버. 프린터나 가전제품 등에 탑재돼 웹 브라우저를 통한 관리 인터페이스를 제공. 대부분 1제곱인치 미만의 크기로 구현되며 최소한의 기능만을 제공하는 것이 특징.

#### 대표적인 예시

- 아이픽 성냥 머리 크기 웹 서버
- 넷미디어 사이트플레이어 SP1 이더넷 웹 서버

  5.2장의 내용을 다음과 같이 정리하겠습니다.

## 간단한 펄 웹 서버 구현과 HTTP 테스트 도구

### 웹 서버의 복잡성 & 단순 구현의 가치

HTTP/1.1 지원 등 완전한 기능을 갖춘 **HTTP 서버**는 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 모니터링 등 수만 줄의 코드가 필요한 복잡한 시스템.

하지만 **기본적인 HTTP 통신 테스트용 서버**는 30줄 미만의 간단한 코드로도 구현이 가능한 시스템. 즉, 학습용으로 웹서버가 HTTP를 어떻게 서빙하는지 잘 볼 수 있다.

### Type-O-Serve 유틸리티 특징 & 구조

> [!NOTE]
> 펄로 작성된 Type-O-Serve는 HTTP 커넥션을 수신하고 요청-응답을 직접 제어할 수 있는 진단 도구

#### 주요 구성 요소

```perl
#!/usr/bin/perl
use Socket;
use Carp;
use FileHandle;

# (1) 포트 설정: 기본 8080 포트 사용, 명령줄 인자로 변경 가능
$port = (@ARGV ? $ARGV[0] : 8080);

# (2) TCP 소켓 생성 및 커넥션 대기 설정
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지 출력
printf("    <<Type-O-Serve Accepting on Port %d>>>\n\n", $port);

while (1) {
    # (4) 커넥션 수락
    $cport_caddr = accept(C, S);
    ($cport, $caddr) = sockaddr_in($cport_caddr);
    C->autoflush(1);

    # 클라이언트 정보 출력
    $cname = gethostbyaddr($caddr, AF_INET);
    printf("<<Request From '%s'>>>\n", $cname);

    # (5) 요청 메시지 읽기 및 출력 : `^lr`가 나오면 종료
    while ($line = <C>) {
        print $line;
        if ($line =~ /^lr/) { last; }
    }

    # (6) 응답 생성 및 전송 : `.`로 응답 생성 종료
    printf("    <<Type Response Followed by '.'>>>\n");
    while ($line = <STDIN>) {
        $line =~ s/\r//;
        $line =~ s/\n//;
        if ($line =~ /^\./) { last; }
        print C $line . "\r\n";
    }
    close(C);
}
```

1. **포트 설정 및 및 소켓 초기화** : 기본 8080 포트 사용 or 명령줄 인자로 포트 변경 가능
2. **TCP 소켓 생성** : 해당 포트에서 로컬 TCP 소켓을 생성하고 커넥션 대기
3. **커넥션 처리** : 클라이언트로부터의 연결을 수락 후 호스트 정보 확인 및 요청 메시지를 화면에 출력 (`^lr`)
4. **응답 생성** : 관리자가 직접 입력한 응답을 클라이언트에게 전송 (`.`)

### Type-O-Serve 실행 과정

실제 웹 서버 관리자의 HTTP 통신 테스트 시나리오는 다음과 같은 단계로 구성.

<img width="676" alt="image" src="https://github.com/user-attachments/assets/617273bc-8985-4b3e-aa67-f9cc0c07de08" />

1. **서버 시작** : 사용하지 않는 포트(예: 8080)로 Type-O-Serve 실행 수행
2. **요청 수신** : 브라우저의 HTTP 요청 메시지를 수신하고 화면에 표시
3. **응답 생성** : 관리자가 직접 입력해 HTTP 응답 메시지를 생성 (`.`로 끝냄)
4. **응답 전송** : 생성된 응답을 브라우저에게 전송하고 클라이언트는 결과 확인

이러한 도구는 HTTP 프로토콜의 이해와 디버깅, 특히 프락시 서버와의 상호작용 테스트에 유용한 진단 도구로서의 가치를 지님.

## 웹 서버의 핵심 작업 흐름

아래의 작업들이 하나의 완전한 HTTP 트랜잭션을 구성, 현대의 웹 서버는 이 기본적인 작업 흐름을 기반으로 더욱 복잡하고 다양한 기능을 제공하는 것이 특징.

<img width="675" alt="image" src="https://github.com/user-attachments/assets/70b60b0e-5a66-40c9-8546-ce62a96e72e7" />

#### 1. 커넥션 관리

클라이언트로부터의 연결 요청을 수락하거나 거부하는 초기 단계. 허용된 클라이언트와의 연결 수립이 핵심.

#### 2. 요청 수신 처리

네트워크를 통해 들어오는 HTTP 요청 메시지를 읽고 파싱하는 과정. 메시지의 구조와 내용 파악이 중요.

#### 3. 요청 내용 분석

파싱된 HTTP 요청을 해석하고 서버가 수행해야 할 작업을 결정하는 단계. 요청의 유효성과 수행 가능성 검증이 필수.

#### 4. 리소스 접근

요청된 리소스의 위치를 파악하고 해당 리소스에 대한 접근 권한을 확인하는 과정. 파일 시스템이나 다른 백엔드 시스템과의 상호작용이 포함됨.

#### 5. 응답 생성

리소스 접근 결과를 바탕으로 적절한 HTTP 헤더와 함께 응답 메시지를 구성하는 작업. 상태 코드와 메타데이터 포함이 중요.

#### 6. 응답 전송

생성된 HTTP 응답을 네트워크를 통해 클라이언트에게 전달하는 단계. 효율적인 데이터 전송이 핵심.

#### 7. 트랜잭션 기록

모든 요청-응답 과정에 대한 상세 정보를 로그 파일에 기록하는 작업. 서버 모니터링과 문제 해결을 위한 중요한 단계임.

## 1단계 : 클라이언트 커넥션 수락

### 새 커넥션 처리 방식

웹 서버는 클라이언트의 TCP 커넥션 요청을 받아들이고, IP 주소를 추출해 클라이언트를 확인하는, 초기 연결 단계를 수행한다.

커넥션 수락 후의 서버 동작이 핵심. 서버는 새 커넥션을 커넥션 목록에 추가하고 데이터 모니터링을 위한 준비를 수행함. 필요한 경우 보안상의 이유로 커넥션을 거부하거나 즉시 종료할 수 있는 권한을 가짐.

### 클라이언트 호스트명 식별 확인 메커니즘

#### DNS를 통한 호스트명 식별 : hostname lookup

> [!NOTE]
> 역방향 DNS를 사용해 클라이언트 IP 주소를 호스트명으로 변환하는 것이 핵심

이는 **접근 제어와 로깅**에 활용되나, 성능 저하를 유발할 수 있어 선택적 사용이 권장됨.

아파치의 경우 HostnameLookups 설정으로 특정 리소스에 대해서만 호스트명 분석을 활성화할 수 있음.

```
HostnameLookups off
<Files ~ "\.(html|htm|cgi)$">
  HostnameLookups on
</Files>
```

#### ident 프로토콜을 통한 사용자 식별

<img width="675" alt="image" src="https://github.com/user-attachments/assets/4a4ffeaa-2320-418f-b29c-5ee62d4d44cd" />

> [!NOTE]
> TCP 113번 포트를 통해 클라이언트 사용자 정보를 확인하는 방식이 핵심
> 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 등

**로깅 목적**으로 주로 사용되나, 아래와 같은 제약사항이 존재함.

- 대부분의 클라이언트 PC에서 ident 신원확인 프로토콜 데몬 소프트웨어 미실행
- HTTP 트랜잭션 지연 발생
- 보안상 취약점과 조작 가능성 존재
- 가상 IP 주소 지원의 한계
- 방화벽에 의한 차단 가능성
- 프라이버시 침해 우려

아파치의 경우 IdentityCheck 지시어로 ident 룩업 설정이 가능하며, 정보 부재 시 일반 로그 포맷 로그파일의 두 번째 필드는 하이픈(-)으로 표시됨.

## 2단계 : 서버 요청 메시지 수신

### 요청 메시지 파싱 과정

> [!NOTE]
> 웹 서버가 네트워크 커넥션에 데이터가 도착하면, 데이터를 읽고 파싱해 HTTP 요청 메시지를 구성하는 단계적 처리 과정

서버의 요청 메시지 파싱 절차가 있음. 구체적으로 아래와 같은 순차적 단계를 거침.

<img width="678" alt="image" src="https://github.com/user-attachments/assets/bec12d2a-bbeb-494a-b321-e2c33de3d5ba" />

1. 요청줄 분석 : 메서드, URI, 버전 번호를 스페이스로 구분해 추출. 요청줄은 **CRLF**로 종료됨
   (버전 번호는 HTTP/0.9에선 미지원)
2. 메시지 헤더 처리 : 각각의 헤더를 읽고 **CRLF**로 종료되는 지점까지 파싱 (LF도 가능임)
3. 빈 줄 확인 : 헤더의 끝을 나타내는 **CRLF**로 끝나는 빈 줄을 탐색
4. 요청 본문 처리 : `Content-Length` 헤더에 명시된 길이만큼의 본문 데이터를 읽음

### 메시지의 내부 표현 방식

웹 서버의 효율적인 요청 처리를 위한 자료구조를 구성 해야함.

<img width="677" alt="image" src="https://github.com/user-attachments/assets/88d2818c-c86e-4ef5-9f1a-d0c77710fea1" />

요청 메시지의 각 구성 요소를 포인터와 길이 정보로 저장하고, 헤더는 빠른 검색이 가능한 룩업 테이블 형태로 구성함.

### 커넥션 입출력 처리 아키텍처

고성능 웹 서버의 동시 커넥션 처리 방식이 핵심. 주요 아키텍처는 아래와 같이 구분됨.

#### 1. 단일 스레드 웹 서버

<img width="297" alt="image" src="https://github.com/user-attachments/assets/87b2cc01-70ea-4334-8573-fe84d8e372ee" />

- 한 번에 하나의 요청만 순차적으로 처리
- 구현은 간단하나 성능상 한계가 명확함
- 오직 로드가 적은 서버나 type-o-serve 등 가벼운 진단 도구 용도로만 적합함

#### 2. 멀티프로세스/스레드 웹 서버

<img width="402" alt="image" src="https://github.com/user-attachments/assets/3e603a84-539b-4c71-b568-39a84b807ab9" />

- 동시 요청 처리를 위해 다중 프로세스/스레드 활용
- 필요에 따라 동적 생성 또는 미리 생성하는 방식 선택
- 커넥션 수에 따라 매우 많은 프로세스/스레드가 생성됨, 리소스 소모를 고려한 프로세스/스레드 수 제한 필요

\+ 참고 : 프로세스와 스레드는 다른 개념과 성능을 지니고 있지만 역할상 같기 때문에 혼용함.

#### 3. 다중 I/O 서버

<img width="400" alt="image" src="https://github.com/user-attachments/assets/455bc102-81a7-440a-a6f0-7b529b5f03c7" />

- 대량의 동시 커넥션을 효율적으로 관리
- 커넥션 상태 변화를 지속적으로 모니터링
- 필요한 시점에만 처리를 수행해 리소스 효율성 확보

멀티플렉싱!

#### 4. 다중 멀티스레드 웹 서버

<img width="404" alt="image" src="https://github.com/user-attachments/assets/0e9aa9ae-6ae5-4cc7-abd4-386792e80dcd" />

- 다중화와 멀티스레딩의 장점을 결합
- 다중 CPU 환경에서 최적의 성능 구현
- 커넥션 집합을 여러 스레드가 나누어 관리

이러한 아키텍처는 서버의 용도와 규모에 따라 적절히 선택돼야 하며, 각각의 장단점을 고려한 설계가 필요함.

## 3단계 : 수신받은 메세지 요청 처리

> [!NOTE]
> 웹 서버가 수신한 HTTP 요청으로부터 메서드, URI, 헤더, 본문(있는 경우)을 추출해 적절한 처리를 수행하는 핵심 단계

메서드의 성격에 따른 요청 본문 처리가 핵심. HTTP 메서드는 요청 본문의 포함 여부에 따라 세 가지 유형으로 분류됨.

1. **필수 본문 포함 메서드** : POST 등 본문 필수 메서드, 본문을 통해 서버에 처리할 데이터를 전달하는 것이 필수적임.
2. **선택적 본문 허용 메서드** : OPTIONS 등 본문 선택 메서드, 클라이언트의 필요에 따라 본문 포함 여부를 결정할 수 있음.
3. **본문 금지 메서드** : GET 등 본문 필요 없음 메서드, 이러한 제약은 HTTP 프로토콜의 설계 의도를 반영한 것임.

얘기 안해줌.. 네트워크 얘기가 아니니까!

4장의 내용을 아래와 같이 정리해보겠음.

## 4단계 : 리소스 매핑과 접근

웹 서버가 클라이언트의 요청 URI를 실제 리소스(정적/동적 콘텐츠)로 변환하고 접근을 제어함. 그래서 알맞은 콘텐츠나 콘텐츠 생성기를 웹 서버에서 찾아 그 콘텐츠의 원천을 식별해야함.

그 과정들을 여기서 서술한다.

\+ 아파치 서버에서는 다 따로 지시어나 블록을 설정해 설정해주어야 한다.

### 문서 루트(Docroot) 시스템

> [!NOTE]
> 문서 루트는 **웹 콘텐츠를 담는 특별한 폴더**로, 요청 URI를 문서 루트 뒤에 붙여 실제 리소스의 위치를 찾아냄
> 웹 서버의 리소스 매핑은 **주로 문서 루트를 활용한 매핑**이 기본

<img width="678" alt="image" src="https://github.com/user-attachments/assets/a4da3282-c454-420d-b6b5-9bce58d83688" />

위 이미지처럼 `/usr/local/httpd/files`에 문서 루트 설정 파일이 있어, 여기서 `specials/saw-blade.gif`를 가져온다.
파일 시스템의 **docroot 이외 부분이 노출되는 일이 생기지 않도록 주의**하기 위해서 생겨난 것. 성숙한 사이트는 그런 식으로 동작함.

\+ 아파치 적용법 : `DocumentRoot /usr/local/httpd/files`

\++ 여기서부터는 Docroot의 활용 사례를 보여준다.

#### 가상 호스팅된 Docroot의 활용

> [!NOTE]
> 하나의 웹 서버에서 **여러 웹사이트를 호스팅**하기 위해 **각 사이트별로 분리된 문서 루트를 제공**하는 방식

<img width="675" alt="image" src="https://github.com/user-attachments/assets/593abea7-4b71-4f27-aabc-9991ed065029" />

`Host` 헤더나 IP 주소를 통해 적절한 문서 루트를 식별하고 매핑.

\+ 아파치 적용법 : `VirtualHost`

```
<VirtualHost www.joes-hardware.com>
  ServerName www.joes-hardware.com
  DocumentRoot /docs/joe
  TransferLog /logs/joe.access_log
  ErrorLog /logs/joe.error_log
</VirtualHost>
<VirtualHost www.marys-antiques.com>
  ServerName www.marys-antiques.com
  DocumentRoot /docs/mary
  TransferLog /logs/mary.access_log
  ErrorLog /logs/mary.error_log
</VirtualHost>
...
```

#### 사용자 홈 디렉터리 Docroot의 특징

> [!NOTE]
> 웹사이트 중 **개인화된 웹사이트 운영**을 위해 **각 사용자별로 할당**된 문서 루트 시스템

<img width="671" alt="image" src="https://github.com/user-attachments/assets/dd045bb4-16b6-4344-97f5-d40db40c5a42" />

URI에서 `~/사용자명` 형태로 요청이 들어오면 해당 사용자의 `public_html` 디렉터리로 매핑함.

### 디렉터리 접근 처리 방식

파일이 아닌 디렉터리 URL 요청 시 웹 서버의 대응 방식은 다음과 같음.

1. **에러 반환**을 통한 접근 차단
2. `index.html`과 같은 **기본 파일 반환**
3. **디렉터리 내용을 HTML로 자동 생성**해 반환

대부분의 웹 서버는 **요청한 URL에 대응되는 디렉터리 안에서 `index.html` 혹은 `index.htm`으로 이름 붙은 파일**을 찾는다.

\+ 아파치 적용법 : `Directorylndex index.html index.htm home.html home.htm index.cgi` or `Options -Indexes`(끄기)

### 동적 리소스 처리

> [!NOTE]
> 웹 서버가 **URI를 실행 가능한 프로그램과 매핑**해 **요청에 따라 콘텐츠를 동적으로 생성**하는 메커니즘

<img width="671" alt="image" src="https://github.com/user-attachments/assets/d71335a7-f827-40a8-bd93-7d063ad819b0" />

웹 서버 중 애플리케이션 서버라는 것도 있는데, 복잡한 백엔드 애플리케이션과 이어주는 역할을 한다. 그 리소스가 동적이거나 실행하기 어려운 리소스라면 애플리케이션 서버가 알려줘야한다.

\+ 아파치 적용법1 : `ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/`(`/cgi-bin`로 시작하면 저 주소에서 가져오라는 뜻)
\+ 아파치 적용법2 : `AddHandler cgi-script .cgi`(특정 확장자의 파일만 실행하도록 설정, `.cgi`로 끝나는 모든 웹 리소스는 실행되어야 함을 명시)

#### 주요 동적 처리 방식

- **CGI**를 통한 기본적인 실행 프로그램 매핑
- **서버사이드 인클루드(SSI)**를 통한 동적 콘텐츠 생성
  - 특별한 패턴 검사 => 변수 값이나 실행 가능한 스크립트의 출력 값으로 치환 => 동적 컨텐츠 생성

액티브 서버 페이지, 자바 서블릿 등 현대적 애플리케이션 서버 활용, 강력하고 효과적인 서버사이드 동적 콘텐츠 지원이 가능해짐

\+ 웹 서버는 IP 주소나 비밀번호 기반의 인증을 통해 리소스별 접근 제어를 구현. 추후 12장에서 보는 걸로.

## 5단계 : 응답 생성과 반환

**리소스를 식별**한 웹 서버가 **요청 메서드에 따라 동작을 수행** 후, 상태 코드/헤더/본문을 포함한 **응답 메시지를 생성해 반환**하는 과정.

### 응답 엔터티의 구성

응답 본문이 있는 트랜잭션의 경우, 다음 요소들을 포함한 메시지를 반환함.

- `Content-Type` 헤더 : MIME 타입 명시
- `Content-Length` 헤더 : 본문 크기 표시
- 실제 응답 본문 데이터를 포함

### MIME 타입 결정 메커니즘

서버에게는 응답 본문의 MIME 타입을 결정할 의무가 있음. 웹 서버의 MIME 타입 결정 방식은 다음과 같음.

#### `mime.types` : 파일 확장자 기반 결정

<img width="666" alt="image" src="https://github.com/user-attachments/assets/e6c51d06-a127-4bdf-9896-bb47faf1d4a8" />

가장 일반적인 방식으로, 확장자별 MIME 타입 매핑 파일을 통해 적절한 타입을 결정하는 것이 핵심.

#### 매직 타이핑(Magic typing)

파일 내용의 패턴을 검사하여 MIME 타입을 결정. 표준 확장자가 없는 파일에 유용하나 처리 속도가 느린 것이 특징.

#### 명시적 타입(Explicit typing) 지정

특정 파일이나 디렉터리의 MIME 타입을 설정으로 직접 지정하는 방식이 핵심.

\+ 책에선 '유형 명시'라 칭함

#### 타입 협상(Type negotiation) 시스템

하나의 리소스에 여러 문서 형식을 지정하고, 클라이언트와의 협상을 통해 최적의 MIME 타입을 선택하는 것이 핵심.

\+ 책에선 '유형 협상'이라 칭함

### 리다이렉션 시스템

> [!NOTE]
> 웹 서버가 클라이언트의 요청을 다른 위치로 보내는 3XX 상태 코드 기반의 응답 메커니즘

#### 리다이렉션 주요 사용 예시

- **영구 이동** : 리소스의 새로운 위치로 영구 이동, 요청 URL에 대해 수정이 필요함
  - `301 Moved Permanently` 사용
- **임시 이동** : 임시이기 때문에 원래 URL 유지 필요하면서 현재 요청에 대해서는 임시 위치 변경함
  - `303 See Other`/`307 Temporary Redirect` 활용
- **URL 증강** : 서버 문맥 정보를 포함시키기 위해 상태 정보를 포함한 새 URL(`뚱뚱한-fat URL`) 생성 후 다시 요청
  - `303 See Other`/`307 Temporary Redirect` 활용
- **부하 분산** : 서버 부하에 따른 분산 처리
  - `303 See Other`/`307 Temporary Redirect` 활용
- **친밀도 기반 다른 서버 존재** : 요청에 대한 사용자 정보 보유 서버로의 이동
  - `303 See Other`/`307 Temporary Redirect` 활용
- **디렉터리 정규화** : 디렉터리 경로 교정(`/` 오타 등)을 위한 슬래시 추가 처리가 핵심

## 6단계 : 응답 전송 + 시스템

요청 시 애로사항이 응답에도 똑같이 적용된다. 웹 서버가 다수의 클라이언트 커넥션을 동시에 관리하며 데이터를 전송하는 복잡한 처리 과정을 다뤄야함.

### 커넥션 관리의 핵심 요소

웹 서버의 커넥션 처리 방식은 상태에 따라 세분화되어 있음.

- 비활성 커넥션 관리
- 데이터 수신 중인 커넥션 처리
- 응답 전송 중인 커넥션 핸들링
- 지속적/비지속적 커넥션의 구분된 처리

서버는 이러한 커넥션들을 요청과 마찬가지로 커넥션을 관리하고 추적해야함.

### 커넥션 종료 정책

커넥션 타입에 따른 종료 방식이 상이함.

- 비지속적 커넥션: 메시지 전송 완료 후 즉시 종료하는 것이 핵심
- 지속적 커넥션: `Content-Length` 헤더의 정확한 계산과 종료 시점 파악이 중요

## 7단계 : 트랜잭션 로깅 시스템

> [!NOTE]
> 웹 서버가 완료된 트랜잭션의 수행 결과와 과정을 로그 파일에 기록하는 마지막 단계의 처리 메커니즘.

- 트랜잭션 완료 시점에 기록이 이루어짐
- 다양한 로깅 설정 양식 제공이 가능
- 트랜잭션의 세부 수행 정보를 담는 것이 핵심

21장에 더 자세히 다룸.
