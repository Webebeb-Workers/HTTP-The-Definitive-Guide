# HTTP 아키텍처 개요

2장 시작. 웹 시스템 아키텍처의 핵심 구성 요소들에 대한 설명으로 구성된 6개의 챕터.

## 주요 구성 요소

1. **웹 서버** : 기본적인 웹 서버 아키텍처와 구현
2. **프락시** : HTTP 서비스와 제어를 위한 중개 서버의 역할과 기능
3. **캐시** : 자주 요청되는 문서의 지역 사본을 통한 트래픽 감소와 성능 향상 메커니즘
4. **게이트웨이** : 서로 다른 프로토콜 간 HTTP 기반 상호작용 지원 시스템
5. **웹 로봇** : HTTP 아키텍처를 활용하는 웹 클라이언트의 구현
6. **HTTP/2.0** : HTTP/1.1의 성능 개선을 위해 도입된 새로운 프로토콜의 특징

각 구성 요소는 웹의 효율적인 동작을 위한 고유한 역할을 수행하며 상호 연계된 구조를 형성.

---

# 웹 서버

HTTP를 통해 웹페이지를 제공하는 웹의 핵심 구성요소. 매일 수십억 개의 웹페이지를 처리해 날씨 정보 제공, 온라인 쇼핑, 소셜 네트워킹 등 다양한 서비스의 기반이 되는 월드 와이드 웹의 일꾼.

## 웹 서버의 정의 & 형태

> [!NOTE]
> HTTP 요청을 처리하고 응답을 제공하는 시스템, 소프트웨어적 측면과 하드웨어적 측면을 모두 포함하는 개념
> 클라이언트의 HTTP 요청을 받아 적절한 리소스를 응답으로 전달하는 과정에서 일련의 핵심 작업들을 순차적으로 수행하는 시스템.

기능과 형태, 크기가 다양하나 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 전달하는 공통된 목적을 가짐.

## 웹 서버의 구현 방식

웹 서버는 HTTP 프로토콜과 TCP 처리를 구현하고 리소스를 관리하며 서버 관리 기능을 제공.
TCP 커넥션 관리는 운영체제와 책임을 공유하는 구조. 운영체제는 하드웨어 관리, TCP/IP 네트워크 지원, 파일 시스템 유지, 프로세스 관리 등을 담당.

구현 형태는 크게 두 가지임.

- **다목적 소프트웨어 웹 서버** : 표준 컴퓨터 시스템에 설치돼 실행
- **임베디드 웹 서버** : 전자기기에 내장돼 관리 콘솔로 제공

### 다목적 소프트웨어 웹 서버의 현황

> [!NOTE]
> 네트워크에 연결된 표준 컴퓨터 시스템에서 동작하는 서버 소프트웨어
> 오픈 소스(아파치, W3C 직소)와 상용 소프트웨어(마이크로소프트, 아이플래닛) 모두 존재

#### 2014년 넷크래프트 조사 기준 시장 점유율

<img width="673" alt="image" src="https://github.com/user-attachments/assets/fc3b6396-5c47-41cd-90df-3a714d23a81d" />

- 마이크로소프트 웹 서버 : 37%
- 아파치 웹 서버 : 35%
- nginx 서버 : 14%

\+ 현재 책에서 나온 [링크](http://news.netcraft.com/archives/2014/08/27/august-2014-web-server-survey.html)는 404가 떠서 못보고, 웹 서버를 검색할 수 있는 [**사이트**](https://searchdns.netcraft.com/)는 있음.

### 임베디드 웹 서버의 특징

일반 소비자용 제품에 내장되는 소형 웹 서버. 프린터나 가전제품 등에 탑재돼 웹 브라우저를 통한 관리 인터페이스를 제공. 대부분 1제곱인치 미만의 크기로 구현되며 최소한의 기능만을 제공하는 것이 특징.

#### 대표적인 예시

- 아이픽 성냥 머리 크기 웹 서버
- 넷미디어 사이트플레이어 SP1 이더넷 웹 서버

  5.2장의 내용을 다음과 같이 정리하겠습니다.

## 간단한 펄 웹 서버 구현과 HTTP 테스트 도구

### 웹 서버의 복잡성 & 단순 구현의 가치

HTTP/1.1 지원 등 완전한 기능을 갖춘 **HTTP 서버**는 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 모니터링 등 수만 줄의 코드가 필요한 복잡한 시스템.

하지만 **기본적인 HTTP 통신 테스트용 서버**는 30줄 미만의 간단한 코드로도 구현이 가능한 시스템. 즉, 학습용으로 웹서버가 HTTP를 어떻게 서빙하는지 잘 볼 수 있다.

### Type-O-Serve 유틸리티 특징 & 구조

> [!NOTE]
> 펄로 작성된 Type-O-Serve는 HTTP 커넥션을 수신하고 요청-응답을 직접 제어할 수 있는 진단 도구

#### 주요 구성 요소

```perl
#!/usr/bin/perl
use Socket;
use Carp;
use FileHandle;

# (1) 포트 설정: 기본 8080 포트 사용, 명령줄 인자로 변경 가능
$port = (@ARGV ? $ARGV[0] : 8080);

# (2) TCP 소켓 생성 및 커넥션 대기 설정
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지 출력
printf("    <<Type-O-Serve Accepting on Port %d>>>\n\n", $port);

while (1) {
    # (4) 커넥션 수락
    $cport_caddr = accept(C, S);
    ($cport, $caddr) = sockaddr_in($cport_caddr);
    C->autoflush(1);

    # 클라이언트 정보 출력
    $cname = gethostbyaddr($caddr, AF_INET);
    printf("<<Request From '%s'>>>\n", $cname);

    # (5) 요청 메시지 읽기 및 출력 : `^lr`가 나오면 종료
    while ($line = <C>) {
        print $line;
        if ($line =~ /^lr/) { last; }
    }

    # (6) 응답 생성 및 전송 : `.`로 응답 생성 종료
    printf("    <<Type Response Followed by '.'>>>\n");
    while ($line = <STDIN>) {
        $line =~ s/\r//;
        $line =~ s/\n//;
        if ($line =~ /^\./) { last; }
        print C $line . "\r\n";
    }
    close(C);
}
```

1. **포트 설정 및 및 소켓 초기화** : 기본 8080 포트 사용 or 명령줄 인자로 포트 변경 가능
2. **TCP 소켓 생성** : 해당 포트에서 로컬 TCP 소켓을 생성하고 커넥션 대기
3. **커넥션 처리** : 클라이언트로부터의 연결을 수락 후 호스트 정보 확인 및 요청 메시지를 화면에 출력 (`^lr`)
4. **응답 생성** : 관리자가 직접 입력한 응답을 클라이언트에게 전송 (`.`)

### Type-O-Serve 실행 과정

실제 웹 서버 관리자의 HTTP 통신 테스트 시나리오는 다음과 같은 단계로 구성.

<img width="676" alt="image" src="https://github.com/user-attachments/assets/617273bc-8985-4b3e-aa67-f9cc0c07de08" />

1. **서버 시작** : 사용하지 않는 포트(예: 8080)로 Type-O-Serve 실행 수행
2. **요청 수신** : 브라우저의 HTTP 요청 메시지를 수신하고 화면에 표시
3. **응답 생성** : 관리자가 직접 입력해 HTTP 응답 메시지를 생성 (`.`로 끝냄)
4. **응답 전송** : 생성된 응답을 브라우저에게 전송하고 클라이언트는 결과 확인

이러한 도구는 HTTP 프로토콜의 이해와 디버깅, 특히 프락시 서버와의 상호작용 테스트에 유용한 진단 도구로서의 가치를 지님.

## 웹 서버의 핵심 작업 흐름

아래의 작업들이 하나의 완전한 HTTP 트랜잭션을 구성, 현대의 웹 서버는 이 기본적인 작업 흐름을 기반으로 더욱 복잡하고 다양한 기능을 제공하는 것이 특징.

<img width="675" alt="image" src="https://github.com/user-attachments/assets/70b60b0e-5a66-40c9-8546-ce62a96e72e7" />

#### 1. 커넥션 관리

클라이언트로부터의 연결 요청을 수락하거나 거부하는 초기 단계. 허용된 클라이언트와의 연결 수립이 핵심.

#### 2. 요청 수신 처리

네트워크를 통해 들어오는 HTTP 요청 메시지를 읽고 파싱하는 과정. 메시지의 구조와 내용 파악이 중요.

#### 3. 요청 내용 분석

파싱된 HTTP 요청을 해석하고 서버가 수행해야 할 작업을 결정하는 단계. 요청의 유효성과 수행 가능성 검증이 필수.

#### 4. 리소스 접근

요청된 리소스의 위치를 파악하고 해당 리소스에 대한 접근 권한을 확인하는 과정. 파일 시스템이나 다른 백엔드 시스템과의 상호작용이 포함됨.

#### 5. 응답 생성

리소스 접근 결과를 바탕으로 적절한 HTTP 헤더와 함께 응답 메시지를 구성하는 작업. 상태 코드와 메타데이터 포함이 중요.

#### 6. 응답 전송

생성된 HTTP 응답을 네트워크를 통해 클라이언트에게 전달하는 단계. 효율적인 데이터 전송이 핵심.

#### 7. 트랜잭션 기록

모든 요청-응답 과정에 대한 상세 정보를 로그 파일에 기록하는 작업. 서버 모니터링과 문제 해결을 위한 중요한 단계임.

## 1단계 : 클라이언트 커넥션 수락

### 새 커넥션 처리 방식

웹 서버는 클라이언트의 TCP 커넥션 요청을 받아들이고, IP 주소를 추출해 클라이언트를 확인하는, 초기 연결 단계를 수행한다.

커넥션 수락 후의 서버 동작이 핵심. 서버는 새 커넥션을 커넥션 목록에 추가하고 데이터 모니터링을 위한 준비를 수행함. 필요한 경우 보안상의 이유로 커넥션을 거부하거나 즉시 종료할 수 있는 권한을 가짐.

### 클라이언트 호스트명 식별 확인 메커니즘

#### DNS를 통한 호스트명 식별 : hostname lookup

> [!NOTE] > **역방향 DNS를 사용해 클라이언트 IP 주소를 호스트명으로 변환**하는 것이 핵심

이는 **접근 제어와 로깅**에 활용되나, 성능 저하를 유발할 수 있어 선택적 사용이 권장됨.

아파치의 경우 HostnameLookups 설정으로 특정 리소스에 대해서만 호스트명 분석을 활성화할 수 있음.

```
HostnameLookups off
<Files ~ "\.(html|htm|cgi)$">
  HostnameLookups on
</Files>
```

#### ident 프로토콜을 통한 사용자 식별

<img width="675" alt="image" src="https://github.com/user-attachments/assets/4a4ffeaa-2320-418f-b29c-5ee62d4d44cd" />

> [!NOTE] > **TCP 113번 포트를 통해 클라이언트 사용자 정보를 확인**하는 방식이 핵심
> 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 등

**로깅 목적**으로 주로 사용되나, 아래와 같은 제약사항이 존재함.

- 대부분의 클라이언트 PC에서 ident 신원확인 프로토콜 데몬 소프트웨어 미실행
- HTTP 트랜잭션 지연 발생
- 보안상 취약점과 조작 가능성 존재
- 가상 IP 주소 지원의 한계
- 방화벽에 의한 차단 가능성
- 프라이버시 침해 우려

아파치의 경우 IdentityCheck 지시어로 ident 룩업 설정이 가능하며, 정보 부재 시 일반 로그 포맷 로그파일의 두 번째 필드는 하이픈(-)으로 표시됨.

## 2단계 : 서버 요청 메시지 수신

### 요청 메시지 파싱 과정

> [!NOTE]
> 웹 서버가 네트워크 커넥션에 데이터가 도착하면, 데이터를 읽고 파싱해 HTTP 요청 메시지를 구성하는 단계적 처리 과정

서버의 요청 메시지 파싱 절차가 있음. 구체적으로 아래와 같은 순차적 단계를 거침.

<img width="678" alt="image" src="https://github.com/user-attachments/assets/bec12d2a-bbeb-494a-b321-e2c33de3d5ba" />

1. 요청줄 분석 : 메서드, URI, 버전 번호를 스페이스로 구분해 추출. 요청줄은 **CRLF**로 종료됨
   (버전 번호는 HTTP/0.9에선 미지원)
2. 메시지 헤더 처리 : 각각의 헤더를 읽고 **CRLF**로 종료되는 지점까지 파싱 (LF도 가능임)
3. 빈 줄 확인 : 헤더의 끝을 나타내는 **CRLF**로 끝나는 빈 줄을 탐색
4. 요청 본문 처리 : `Content-Length` 헤더에 명시된 길이만큼의 본문 데이터를 읽음

### 메시지의 내부 표현 방식

웹 서버의 효율적인 요청 처리를 위한 자료구조를 구성 해야함.

<img width="677" alt="image" src="https://github.com/user-attachments/assets/88d2818c-c86e-4ef5-9f1a-d0c77710fea1" />

요청 메시지의 각 구성 요소를 포인터와 길이 정보로 저장하고, 헤더는 빠른 검색이 가능한 룩업 테이블 형태로 구성함.

### 커넥션 입출력 처리 아키텍처

고성능 웹 서버의 동시 커넥션 처리 방식이 핵심. 주요 아키텍처는 아래와 같이 구분됨.

#### 1. 단일 스레드 웹 서버

<img width="297" alt="image" src="https://github.com/user-attachments/assets/87b2cc01-70ea-4334-8573-fe84d8e372ee" />

- 한 번에 하나의 요청만 순차적으로 처리
- 구현은 간단하나 성능상 한계가 명확함
- 오직 로드가 적은 서버나 type-o-serve 등 가벼운 진단 도구 용도로만 적합함

#### 2. 멀티프로세스/스레드 웹 서버

<img width="402" alt="image" src="https://github.com/user-attachments/assets/3e603a84-539b-4c71-b568-39a84b807ab9" />

- 동시 요청 처리를 위해 다중 프로세스/스레드 활용
- 필요에 따라 동적 생성 또는 미리 생성하는 방식 선택
- 커넥션 수에 따라 매우 많은 프로세스/스레드가 생성됨, 리소스 소모를 고려한 프로세스/스레드 수 제한 필요

\+ 참고 : 프로세스와 스레드는 다른 개념과 성능을 지니고 있지만 역할상 같기 때문에 혼용함.

#### 3. 다중 I/O 서버

<img width="400" alt="image" src="https://github.com/user-attachments/assets/455bc102-81a7-440a-a6f0-7b529b5f03c7" />

- 대량의 동시 커넥션을 효율적으로 관리
- 커넥션 상태 변화를 지속적으로 모니터링
- 필요한 시점에만 처리를 수행해 리소스 효율성 확보

멀티플렉싱!

#### 4. 다중 멀티스레드 웹 서버

<img width="404" alt="image" src="https://github.com/user-attachments/assets/0e9aa9ae-6ae5-4cc7-abd4-386792e80dcd" />

- 다중화와 멀티스레딩의 장점을 결합
- 다중 CPU 환경에서 최적의 성능 구현
- 커넥션 집합을 여러 스레드가 나누어 관리

이러한 아키텍처는 서버의 용도와 규모에 따라 적절히 선택돼야 하며, 각각의 장단점을 고려한 설계가 필요함.

## 3단계 : 수신받은 메세지 요청 처리

> [!NOTE]
> 웹 서버가 수신한 HTTP 요청으로부터 메서드, URI, 헤더, 본문(있는 경우)을 추출해 적절한 처리를 수행하는 핵심 단계

메서드의 성격에 따른 요청 본문 처리가 핵심. HTTP 메서드는 요청 본문의 포함 여부에 따라 세 가지 유형으로 분류됨.

1. **필수 본문 포함 메서드** : POST 등 본문 필수 메서드, 본문을 통해 서버에 처리할 데이터를 전달하는 것이 필수적임.
2. **선택적 본문 허용 메서드** : OPTIONS 등 본문 선택 메서드, 클라이언트의 필요에 따라 본문 포함 여부를 결정할 수 있음.
3. **본문 금지 메서드** : GET 등 본문 필요 없음 메서드, 이러한 제약은 HTTP 프로토콜의 설계 의도를 반영한 것임.

얘기 안해줌.. 네트워크 얘기가 아니니까!
