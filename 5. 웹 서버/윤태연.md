# HTTP 아키텍처 개요

2장 시작. 웹 시스템 아키텍처의 핵심 구성 요소들에 대한 설명으로 구성된 6개의 챕터.

## 주요 구성 요소

1. **웹 서버** : 기본적인 웹 서버 아키텍처와 구현
2. **프락시** : HTTP 서비스와 제어를 위한 중개 서버의 역할과 기능
3. **캐시** : 자주 요청되는 문서의 지역 사본을 통한 트래픽 감소와 성능 향상 메커니즘
4. **게이트웨이** : 서로 다른 프로토콜 간 HTTP 기반 상호작용 지원 시스템
5. **웹 로봇** : HTTP 아키텍처를 활용하는 웹 클라이언트의 구현
6. **HTTP/2.0** : HTTP/1.1의 성능 개선을 위해 도입된 새로운 프로토콜의 특징

각 구성 요소는 웹의 효율적인 동작을 위한 고유한 역할을 수행하며 상호 연계된 구조를 형성.

---

# 웹 서버

HTTP를 통해 웹페이지를 제공하는 웹의 핵심 구성요소. 매일 수십억 개의 웹페이지를 처리해 날씨 정보 제공, 온라인 쇼핑, 소셜 네트워킹 등 다양한 서비스의 기반이 되는 월드 와이드 웹의 일꾼.

## 웹 서버의 정의 & 형태

> [!NOTE]
> HTTP 요청을 처리하고 응답을 제공하는 시스템, 소프트웨어적 측면과 하드웨어적 측면을 모두 포함하는 개념
> 클라이언트의 HTTP 요청을 받아 적절한 리소스를 응답으로 전달하는 과정에서 일련의 핵심 작업들을 순차적으로 수행하는 시스템.

기능과 형태, 크기가 다양하나 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아 콘텐츠를 클라이언트에게 전달하는 공통된 목적을 가짐.

## 웹 서버의 구현 방식

웹 서버는 HTTP 프로토콜과 TCP 처리를 구현하고 리소스를 관리하며 서버 관리 기능을 제공.
TCP 커넥션 관리는 운영체제와 책임을 공유하는 구조. 운영체제는 하드웨어 관리, TCP/IP 네트워크 지원, 파일 시스템 유지, 프로세스 관리 등을 담당.

구현 형태는 크게 두 가지임.

- **다목적 소프트웨어 웹 서버** : 표준 컴퓨터 시스템에 설치되어 실행
- **임베디드 웹 서버** : 전자기기에 내장되어 관리 콘솔로 제공

### 다목적 소프트웨어 웹 서버의 현황

> [!NOTE]
> 네트워크에 연결된 표준 컴퓨터 시스템에서 동작하는 서버 소프트웨어
> 오픈 소스(아파치, W3C 직소)와 상용 소프트웨어(마이크로소프트, 아이플래닛) 모두 존재

#### 2014년 넷크래프트 조사 기준 시장 점유율

<img width="673" alt="image" src="https://github.com/user-attachments/assets/fc3b6396-5c47-41cd-90df-3a714d23a81d" />

- 마이크로소프트 웹 서버 : 37%
- 아파치 웹 서버 : 35%
- nginx 서버 : 14%

\+ 현재 책에서 나온 [링크](http://news.netcraft.com/archives/2014/08/27/august-2014-web-server-survey.html)는 404가 떠서 못보고, 웹 서버를 검색할 수 있는 [**사이트**](https://searchdns.netcraft.com/)는 있음.

### 임베디드 웹 서버의 특징

일반 소비자용 제품에 내장되는 소형 웹 서버. 프린터나 가전제품 등에 탑재되어 웹 브라우저를 통한 관리 인터페이스를 제공. 대부분 1제곱인치 미만의 크기로 구현되며 최소한의 기능만을 제공하는 것이 특징.

#### 대표적인 예시

- 아이픽 성냥 머리 크기 웹 서버
- 넷미디어 사이트플레이어 SP1 이더넷 웹 서버

  5.2장의 내용을 다음과 같이 정리하겠습니다.

## 간단한 펄 웹 서버 구현과 HTTP 테스트 도구

### 웹 서버의 복잡성 & 단순 구현의 가치

HTTP/1.1 지원 등 완전한 기능을 갖춘 **HTTP 서버**는 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 모니터링 등 수만 줄의 코드가 필요한 복잡한 시스템.

하지만 **기본적인 HTTP 통신 테스트용 서버**는 30줄 미만의 간단한 코드로도 구현이 가능한 시스템. 즉, 학습용으로 웹서버가 HTTP를 어떻게 서빙하는지 잘 볼 수 있다.

### Type-O-Serve 유틸리티 특징 & 구조

> [!NOTE]
> 펄로 작성된 Type-O-Serve는 HTTP 커넥션을 수신하고 요청-응답을 직접 제어할 수 있는 진단 도구

#### 주요 구성 요소

```perl
#!/usr/bin/perl
use Socket;
use Carp;
use FileHandle;

# (1) 포트 설정: 기본 8080 포트 사용, 명령줄 인자로 변경 가능
$port = (@ARGV ? $ARGV[0] : 8080);

# (2) TCP 소켓 생성 및 커넥션 대기 설정
$proto = getprotobyname('tcp');
socket(S, PF_INET, SOCK_STREAM, $proto) || die;
setsockopt(S, SOL_SOCKET, SO_REUSEADDR, pack("l", 1)) || die;
bind(S, sockaddr_in($port, INADDR_ANY)) || die;
listen(S, SOMAXCONN) || die;

# (3) 시작 메시지 출력
printf("    <<Type-O-Serve Accepting on Port %d>>>\n\n", $port);

while (1) {
    # (4) 커넥션 수락
    $cport_caddr = accept(C, S);
    ($cport, $caddr) = sockaddr_in($cport_caddr);
    C->autoflush(1);

    # 클라이언트 정보 출력
    $cname = gethostbyaddr($caddr, AF_INET);
    printf("<<Request From '%s'>>>\n", $cname);

    # (5) 요청 메시지 읽기 및 출력 : `^lr`가 나오면 종료
    while ($line = <C>) {
        print $line;
        if ($line =~ /^lr/) { last; }
    }

    # (6) 응답 생성 및 전송 : `.`로 응답 생성 종료
    printf("    <<Type Response Followed by '.'>>>\n");
    while ($line = <STDIN>) {
        $line =~ s/\r//;
        $line =~ s/\n//;
        if ($line =~ /^\./) { last; }
        print C $line . "\r\n";
    }
    close(C);
}
```

1. **포트 설정 및 및 소켓 초기화** : 기본 8080 포트 사용 or 명령줄 인자로 포트 변경 가능
2. **TCP 소켓 생성** : 해당 포트에서 로컬 TCP 소켓을 생성하고 커넥션 대기
3. **커넥션 처리** : 클라이언트로부터의 연결을 수락 후 호스트 정보 확인 및 요청 메시지를 화면에 출력 (`^lr`)
4. **응답 생성** : 관리자가 직접 입력한 응답을 클라이언트에게 전송 (`.`)

### Type-O-Serve 실행 과정

실제 웹 서버 관리자의 HTTP 통신 테스트 시나리오는 다음과 같은 단계로 구성.

<img width="676" alt="image" src="https://github.com/user-attachments/assets/617273bc-8985-4b3e-aa67-f9cc0c07de08" />

1. **서버 시작** : 사용하지 않는 포트(예: 8080)로 Type-O-Serve 실행 수행
2. **요청 수신** : 브라우저의 HTTP 요청 메시지를 수신하고 화면에 표시
3. **응답 생성** : 관리자가 직접 입력해 HTTP 응답 메시지를 생성 (`.`로 끝냄)
4. **응답 전송** : 생성된 응답을 브라우저에게 전송하고 클라이언트는 결과 확인

이러한 도구는 HTTP 프로토콜의 이해와 디버깅, 특히 프락시 서버와의 상호작용 테스트에 유용한 진단 도구로서의 가치를 지님.

## 웹 서버의 핵심 작업 흐름

아래의 작업들이 하나의 완전한 HTTP 트랜잭션을 구성, 현대의 웹 서버는 이 기본적인 작업 흐름을 기반으로 더욱 복잡하고 다양한 기능을 제공하는 것이 특징.

<img width="675" alt="image" src="https://github.com/user-attachments/assets/70b60b0e-5a66-40c9-8546-ce62a96e72e7" />

#### 1. 커넥션 관리

클라이언트로부터의 연결 요청을 수락하거나 거부하는 초기 단계. 허용된 클라이언트와의 연결 수립이 핵심.

#### 2. 요청 수신 처리

네트워크를 통해 들어오는 HTTP 요청 메시지를 읽고 파싱하는 과정. 메시지의 구조와 내용 파악이 중요.

#### 3. 요청 내용 분석

파싱된 HTTP 요청을 해석하고 서버가 수행해야 할 작업을 결정하는 단계. 요청의 유효성과 수행 가능성 검증이 필수.

#### 4. 리소스 접근

요청된 리소스의 위치를 파악하고 해당 리소스에 대한 접근 권한을 확인하는 과정. 파일 시스템이나 다른 백엔드 시스템과의 상호작용이 포함됨.

#### 5. 응답 생성

리소스 접근 결과를 바탕으로 적절한 HTTP 헤더와 함께 응답 메시지를 구성하는 작업. 상태 코드와 메타데이터 포함이 중요.

#### 6. 응답 전송

생성된 HTTP 응답을 네트워크를 통해 클라이언트에게 전달하는 단계. 효율적인 데이터 전송이 핵심.

#### 7. 트랜잭션 기록

모든 요청-응답 과정에 대한 상세 정보를 로그 파일에 기록하는 작업. 서버 모니터링과 문제 해결을 위한 중요한 단계임.
