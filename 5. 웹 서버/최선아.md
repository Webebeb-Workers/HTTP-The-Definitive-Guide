# 5. 웹 서버

- 웹 서버는 날씨 정보 제공, 온라인 쇼핑, 친구 찾기 등 다양한 기능을 수행하며 월드 와이드 웹의 핵심 역할을 함
- 월드 와이드 웹(www) : 인터넷 상에서 하이퍼텍스트 문서를 검색하고 접근할 수 있는 시스템으로, 우리가 흔히 사용하는 웹사이트와 웹페이지를 포함하는 공간

## 5.1 다채로운 웹 서버

- 웹 서버 소프트웨어와 웹페이지 제공에 특화된 하드웨어를 카리킴
- 간단한 Perl 스크립트, 대형 상용 서버, 소형 기판 서버 등 기능/크기/형태가가 다양함
- 모든 웹 서버는 HTTP 요청을 받아 리소스나 콘텐츠를 클라이언트에게 반환함

### 5.1.1 웹 서버 구현

**웹 서버의 역할**

- HTTP 프로토콜을 구현함
- 웹 리소스를 관리함
- 웹 서버 관리 기능을 제공함
- TCP 커넥션 관리 책임을 운영체제와 나눠가짐

**운영체제의 지원**

- TCP/IP 네트워크, 파일 시스템, 프로세스 관리 등을 통해 웹 서버의 기능 보조

**웹 서버의 구현 형태**

- 표준 컴퓨터 시스템에서 실행되는 다목적 소프트웨어 웹 서버
- 전자기기 내부의 마이크로프로세서 기반 내장형 웹 서버

### 5.1.2 다목적 소프트웨어 웹 서버

<img width="414" alt="Image" src="https://github.com/user-attachments/assets/48aff166-44df-495a-867d-13fe3a66b09f" />

**기본 특성**

- 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작함
- 대부분의 컴퓨터와 운영체제에서 동작함
- 웹 서버 프로그램으로 오픈소스(아파치, W3C 직소)나 상용 소프트웨어(마이크로소프트, 아이플래닛)를 사용할 수 있음

**시장 현황**

- 전체 웹 서버 중 주요 몇 개의 소프트웨어만 널리 사용됨
- 마이크로소프트(37%), 아파치(35%), nginx(14%)가 시장의 대부분 점유
- nginx는 최근 지속적 성장세 기록

> Q. 표는 꽤 오래전 이야기인데 지금은 어떨까?

### 5.1.3 임베디드 웹 서버

**정의:**

- 일반 소비자용 제품에 내장되는 소형 웹 서버
- ex) 프린터나 가전제품 등에 탑재

**주요 특징:**

- 매우 작은 크기 (1제곱인치 미만도 가능)
- 보통 최소한의 기능만 제공함
- 웹 브라우저를 통한 기기 관리 인터페이스를 제공함

## 5.2 간단한 펄 웹 서버

**HTTP 서버의 규모:**

- 완전한 기능의 HTTP 서버(예: 아파치)는 5만 줄 이상의 코드로 돼있고, 부가적인 처리 모듈들을 더하면 훨씬 커짐
- HTTP/1.1 의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터 링, 그 외 성능을 위한 각종 기능들이 필요
- 최소 기능의 HTTP 서버는 30줄 미만의 펄(Perl) 코드로도 구현 가능

**type-o-serve 프로그램:**

- 간단한 펄(Perl) 기반 웹 서버 프로그램
- HTTP 요청 메시지를 화면에 출력하고, 클라이언트가 응답 메시지를 입력하도록 설계됨.
- 클라이언트-프락시 간 상호작용 테스트에 유용한 진단 도구임

**type-o-serve 프로그램의 작동 방식:**

1. HTTP 연결 대기
2. 요청 메시지 수신 및 화면 출력
3. 사용자가 입력한 응답 메시지를 클라이언트에게 전송

**type-o-serve 프로그램으로 HTTP 통신을 테스트하는 예시**

- 아래 사진은 죠의 하드웨어 상점의 관리자가 type-o-serve를 이용해 어떻게 HTTP 통신을 테스트하는지 보여줌

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/5a76e3af-c53f-4711-8a9d-feca9bd58428" />

1. 관리자는 특정 포트로 수신하는 type-o-serve 진단 서버를 시작

- 죠의 하드웨어 상점 웹 서버는 80포트로 수신하고 있기 때문에 관리자는 `% type-o-serve.pl 8080` 명령을 입력해 type-o-serve 서버를 8080번 포트로 시작함

2. type-o-serve가 동작하기 시작한 후, 죠의 하드웨어 상점 웹 서버에 브라우저로 접근할 수 있음

- `http：//www.joes-hardware.com：8080/foo/bar/blah.txt`에 접근

3. type-o-serve 프로그램은 브라우저로부터 HTTP 요청 메시지를 받아 그 내용을 화면에 출력한 뒤, 관리자가 마침표 하나뿐인 줄로 끝나는 간단한 응답 메시지를 입력할 때까지 기다림

4. type-o-serve는 HTTP 응답 메시지를 브라우저에게 돌려주고, 브라우저는 응답 메시지의 본문을 화면에 출력함

## 5.3 진짜 웹 서버가 하는 일

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/8ea53117-3a48-42bd-bfda-76550d984e72" />

- 최신형 상용 웹 서버가 일반적으로 수행하는 주요 작업은 다음과 같음

1. `커넥션`: 클라이언트의 접속을 받아들이거나 원치 않는 클라이언트라면 연결을 닫음
2. `요청 수신`: HTTP 요청 메시지를 네트워크로부터 읽어 들임
3. `요청 처리`: 요청 메시지를 해석하고 적절한 행동을 취함
4. `리소스 접근`: 요청 메시지에서 지정한 리소스에 접근함
5. `응답 생성`: 올바른 헤더를 포함한 HTTP 응답 메시지를 생성함
6. `응답 송신`: 응답 메시지를 클라이언트에게 전달함
7. `로그 남기기`: 트랜잭션 완료에 대한 정보를 로그 파일에 기록함

## 5.4 단계 1: 클라이언트 커넥션 수락

- 지속적 커넥션이 있는 경우: 기존 커넥션을 사용해 요청 전송 가능
- 지속적 커넥션이 없는 경우: 새로운 커넥션을 열어야 함

### 5.4.1 새 커넥션 다루기

- 클라이언트가 웹 서버에 TCP 커넥션을 요청하면 서버는 커넥션을 맺고 IP 주소를 추출하여 클라이언트를 확인함
- 서버는 새 커넥션을 목록에 추가하고, 오고 가는 데이터를 처리하기 위한 준비를 함
- 서버는 필요에 따라 커넥션을 거절하거나 즉시 닫을 수 있음
- 서버는 인가되지 않거나 악의적인 클라이언트의 경우 커넥션을 닫을 수 있음

### 5.4.2 클라이언트 호스트 명 식별

- 대부분의 웹 서버는 **역방향 DNS(reverse DNS)**를 사용해 클라이언트 IP 주소를 호스트 명으로 변환한다.
- 클라이언트 호스트 명은 접근 제어와 로깅에 활용될 수 있다.
- **호스트 명 룩업(hostname lookup)**은 시간이 많이 걸릴 수 있어 웹 트랜잭션 속도를 저하시킬 수 있다.
- 대용량 웹 서버에서는 호스트 명 분석을 꺼두거나 특정 콘텐츠에 대해서만 활성화한다.
- 아파치 서버에서는 HostnameLookups 설정 지시자를 통해 호스트 명 룩업을 제어할 수 있다.
  - 예: HTML과 CGI 리소스에만 호스트 명 분석을 켜도록 설정 가능.
    ```
    HostnameLookups off
    <Files ~ "\.(html|htm|cgi)$">
        HostnameLookups on
    </Files>
    ```

> 접근 제어와 로깅이 뭐지, 호스트 명 룩업이 뭐지

### 5.4.3 ident를 통해 클라이언트 사용자 알아내기

**IETF ident 프로토콜 개요:**

- 몇몇 웹 서버는 IETF ident 프로토콜을 지원함
- 서버가 HTTP 커넥션을 초기화한 사용자 이름을 찾을 수 있게 해줌
- 웹 서버 로깅에서 유용하며, 일반 로그 포맷(Common Log Format)의 두 번째 필드가 ident 사용자 이름을 담음

**작동 방식:**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/b0ebb6e3-8e26-4f00-b911-c5238390bbea" />

- 클라이언트가 HTTP 커넥션을 열음
- 서버가 클라이언트의 identd 서버 포트(113)로 커넥션을 열음
- 서버가 새 커넥션에 대응하는 사용자 이름을 묻는 요청을 보냄

**ident 프로토콜의 한계점:**

- 많은 클라이언트 PC가 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않음
- HTTP 트랜잭션을 유의미하게 지연시킴
- 방화벽이 ident 트래픽 유입을 막는 경우가 많음
- 안전하지 않고 조작하기 쉬움
- 가상 IP 주소를 잘 지원하지 않음
- 클라이언트 사용자 이름 노출로 프라이버시 침해 우려가 있음

**실제 활용:**

- 조직 내부에서는 잘 사용 할 수 있지만 공공 인터넷에서는 위의 한계들로 인해 잘 동작하지 않음
- 아파치 웹 서버는 IdentityCheck 지시어로 ident 룩업 사용 가능
- ident 정보가 없으면 아파치는 ident 로그 필드를 하이픈(-)으로 채움
- 보통 ident 정보가 없어서 일반 로그 포맷 로그파일의 두 번째 필드는 하이픈으로 채워짐

## 5.5 단계 2: 요청 메시지 수신

- 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메시지를 구성함

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/858ec09a-033d-4267-a41b-06556145339a" />

**웹 서버의 요청 메시지 파싱 단계:**

1. 요청줄 파싱

   - 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호를 찾음
   - 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF)문자열로 끝남

2. 메시지 헤더 읽기

   - 각 헤더는 CRLF로 끝남

3. 빈 줄 확인

   - 헤더의 끝을 나타내는 CRLF로 끝나는 빈 줄 찾기

4. 요청 본문 처리

   - 본문이 존재하는 경우 Content-Length 헤더에 정의된 길이만큼 읽기

**주의사항:**

- 네트워크로부터 데이터가 불규칙적으로 수신됨(속도가 일정하지 않음)
- 네트워크 커넥션이 언제든 무효화될 수 있음(갑작스러운 연결 종료)
- 파싱 가능한 수준의 분량을 확보할 때까지 데이터를 메모리에 임시 저장해 둘 필요가 있음

### 5.5.1 메시지의 내부 표현

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/5d33e526-7e06-4e19-bf67-5edb2a9bbdbd" />

**웹 서버가 요청 메시지를 내부적으로 처리하는 방법:**

- 요청 메시지를 처리하기 쉽게 내부 자료 구조로 변환하여 저장
- 자료 구조에는 메시지 조각들의 포인터, 각 조각의 길이를 담을 수 있음
- 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근 가능

### 5.5.1 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 동시 커넥션 지원
- 커넥션마다 요청 패턴이 다양함 (느린 요청, 대기 중, 빠른 요청)
- 웹 서버는 항상 새 요청을 주시하며, 아키텍처에 따라 처리 방식이 다름

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/773874e3-d982-429f-8b33-8b9a90dfb7da" />

**단일 스레드 웹 서버(그림 5-7a)**

- 단일 스레드 웹 서버는 한 번에 하나씩 요청을 처리함
- 트랜잭션이 완료되면, 다음 커넥션이 처리됨
- 이 아키텍처는 구현하기 간단하지만 처리 도중에 모든 다른 커넥션은 무시되기 때문에 심각한 성능 문제를 만들어내므로 오직 로드가 적은 서버나 type-o-serve와 같은 진단도구에서만 적당하다.

**멀티프로세스와 멀티스레드 웹 서버(그림 5-7b)**

- 멀티프로세스와 멀티스레드 웹 서버는 여러 요청의 동시 처리를 위해 다수의 프로세스나 스레드를 할당함
- 스레드/프로세스는 필요할 때마다 생성되거나 미리 생성될 수 있음
- 일부 서버는 각 커넥션마다 스레드/프로세스를 하나씩 할당하는데, 이는 많은 동시 커넥션을 처리할 때 과도한 메모리와 시스템 리소스를 소비하게 되기 때문에 많은 멀티스레드 웹 서비스는 스레드/프로세스의 최대 개수를 제한함

**다중 I/O 서버(그림 5-7c)**

- 대량의 커넥션을 지원하기 위해 많은 웹 서버가 다중 아키텍처를 채택함
- 다중 아키텍처에서는 모든 커넥션의 활동을 동시에 감시함
- 커넥션의 상태가 변경되면(데이터 사용 가능, 에러 발생 등) 해당 커넥션에 대해 작은 양의 처리를 수행함
- 처리가 완료되면 해당 커넥션은 다음 상태 변경을 기다리며 열린 커넥션 목록으로 돌아감
- 실제 처리가 필요한 커넥션에 대해서만 작업을 수행하므로, 유휴 상태의 커넥션에 스레드와 프로세스가 불필요하게 할당되지 않음

**다중 멀티스레드 웹 서버(그림 5-7d)**

- CPU 여러 개의 이점을 활용하기 위해 멀티스레딩과 다중화(multiplexing)를 결합하는 방식을 사용함
- 여러 스레드(보통 하나의 물리적 프로세스에 속함)가 각각 열려있는 커넥션들을 나눠서 감시함
- 각 스레드는 자신이 담당하는 커넥션들에 대해 작은 단위로 작업을 수행함

## 5.6 단계 3: 요청 처리

- 웹 서버는 요청을 받으면 메서드, 리소스, 헤더, 본문을 추출하여 처리함
- 요청 메시지의 본문(엔터티 본문) 포함 여부는 메서드에 따라 다름:

  - POST: 본문 필수
  - OPTIONS: 본문 허용 (선택적)
  - GET: 본문 금지

- 이 책의 나머지 부분에서 요청 처리 방법을 다룰 예정이므로 여기서는 자세히 설명하지 않음

## 5.7 단계 4: 리소스의 매핑과 접근

- 웹 서버는 HTML 페이지나 이미지 같은 정적 콘텐츠뿐만 아니라 동적 콘텐츠도 제공함
- 웹 서버가 클라이언트에게 콘텐츠를 전달하려면 클라이언트가 요청한 URI에 맞는 콘텐츠나 콘텐츠 생성기를 찾아서, 해당 콘텐츠를 클라이언트에게 전달해야함

### 5.7.1 Docroot

<img width="419" alt="Image" src="https://github.com/user-attachments/assets/60abd165-afbf-4779-9a59-ce5b4d464f1d" />

- 웹 서버는 요청 URI를 파일 시스템의 파일 이름으로 매핑하여 콘텐츠를 제공함.
- 이를 위해 '문서 루트(docroot)'라는 특별한 폴더를 사용함.
- 예를 들어, 요청된 URI가 /specials/saw-blade.gif라면, 웹 서버는 docroot로 설정된 /usr/local/httpd/files 뒤에 URI를 이어붙여 `/usr/local/httpd/files/specials/saw-blade.gif`로 해당 파일을 반환함.
- httpd.conf 설정 파일에 DocumentRoot 줄을 추가하여 아파치 웹 서버의 문서 루트를 설정할 수 있음
  ```
  DocumentRoot /usr/local/httpd/files
  ```
- 또한, 서버는 문서 루트 외부의 파일을 노출하지 않도록 주의해야 함.

**가상 호스팅된 docroot**

> 가상 호스팅이 뭐지?

<img width="415" alt="Image" src="https://github.com/user-attachments/assets/77c8f1ea-8334-43bb-8686-5400f535237c" />

- 기능: 하나의 웹 서버에서 여러 웹 사이트를 호스팅하며, 각 사이트에 독립적인 문서 루트를 제공
- 작동 원리: 서버는 URI나 Host 헤더에서 얻은 IP 주소나 호스트 명을 사용해 올바른 문서 루트를 식별
- 예시:

  - `www.joes-hardware.com`에 대한 요청이 오면 `/docs/joe/index.html` 파일을 반환
  - `www.marys-antiques.com`에 대한 요청이 오면 `/docs/mary/index.html` 파일을 반환

- 설정 방법: 아파치 웹 서버에서는 `VirtualHost` 블록을 사용하여 각 사이트의 `DocumentRoot`를 설정

  ```
  <VirtualHost www.joes-hardware.com>
   ServerName www.joes-hardware.com
   DocumentRoot /docs/joe
   TransferLog /logs/joe.access_log
   ErrorLog /logs/joe.error_log
  </VirtualHost>

  <VirtualHost www.marys-antiques.com>
   ServerName www.marys-antiques.com
   DocumentRoot /docs/mary
   TransferLog /logs/mary.access_log
   ErrorLog /logs/mary.error_log
  </VirtualHost>
  ```

**사용자 홈 디렉터리 docroots**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/74eaad0e-63b7-42da-977a-ad1dff5a8e3d" />

- 기능: 사용자들이 한 대의 웹 서버에서 각자의 개인 웹 사이트를 만들 수 있도록 지원
- URI 형식: 보통 빗금(/)과 물결표(~) 뒤에 사용자 이름이 오는 형식으로 개인 문서 루트를 가리킴
- 개인 docroot: 일반적으로 사용자 홈 디렉터리 내의 `public_html` 디렉터리를 사용하며, 설정에 따라 다를 수 있음

> public_html이 뭐지..? 사용자 홈 디렉터리 docroots가 그냥 파일 시스템하고는 다른 내용인건가?

### 5.7.1 디렉터리 목록

- 웹 서버는 경로가 파일이 아닌 디렉터리를 가리키는 URL에 대해서도 다양한 방식으로 응답할 수 있음.

  - 에러 반환: 디렉터리 URL에 해당하는 파일이 없을 때 에러를 반환
  - 색인 파일 반환: `index.html`, `index.htm` 등 디렉터리 내의 기본 파일을 반환
  - 디렉터리 내용 반환: 디렉터리를 탐색하고 HTML 페이지로 그 내용을 표시

- 대부분의 웹 서버는 디렉터리 URL에 대해 기본 색인 파일(`index.html`, `index.htm`)을 찾고 반환함

- 아파치 웹 서버 설정:

  - `DirectoryIndex` 지시자를 사용하여 디렉터리 색인 파일로 사용될 모든 파일의 우선순위를 설정함으로써 디렉터리 URL 요청에 대한 응답으로 나열된 파일 중 하나를 찾게 만듬

  ```apache
  DirectoryIndex index.html index.htm home.html home.htm index.cgi
  ```

  - 사용자가 디렉터리 URI를 요청했을 때 기본 색인 파일이 없고 디렉터리 색인 기능이 꺼져 있지 않다면, 많은 웹 서버는 자동으로 그 디렉터리의 파일들을 크기, 변경일 및 그 파일에 대한 링크와 함께 열거한 HTML 파일을 반환함
  - 그러나 파일 열거는 숨겨진 파일까지도 드러나게 된다는 단점이 있음
  - 아래와 같이 아파치 지시자로 디렉터리 색인 파일 자동 생성을 끌 수 있음

  ```
  Options -Indexes
  ```

### 5.7.3 동적 콘텐츠 리소스 매핑

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/4cc183cb-d869-4768-b17e-936b69fcda80" />

웹 서버는 **동적 리소스**를 처리하기 위해 **애플리케이션 서버**와 연결하여, 요청에 맞는 콘텐츠를 생성하는 프로그램을 실행할 수 있음.

**동적 리소스 처리**:

- 웹 서버는 URI를 동적 리소스에 매핑하여, 요청에 따라 콘텐츠를 생성하는 프로그램을 실행할 수 있음.

**아파치 설정 예시**:

- 아파치 웹 서버는 URI의 경로명이 실행 가능한 프로그램이 위치한 디렉터리로 매핑될 수 있도록 설정할 수 있음.
- 예: `ScriptAlias /cgi-bin/ /usr/local/etc/httpd/cgi-programs/`는 `/cgi-bin/` 경로에 대한 요청을 `/usr/local/etc/httpd/cgi-programs/` 디렉터리로 매핑하여 프로그램을 실행함.
- 특정 확장자(예: `.cgi`)를 가진 파일만 실행하도록 설정할 수 있음. 예: `AddHandler cgi-script .cgi`.

**CGI와 현대적인 서버사이드 기술**:

- **CGI**(Common Gateway Interface)는 초기 웹 서버에서 사용된 서버사이드 애플리케이션 실행 인터페이스임.
- 현대적인 애플리케이션 서버는 **액티브 서버 페이지(ASP)**, **자바 서블릿**과 같은 더 강력하고 효율적인 서버사이드 동적 콘텐츠 지원 기능을 제공함.

> cgi 가 뭐지???

### 5.7.4 서버사이드 인클루드(Server-Side Includes, SSI)

- 많은 웹 서버가 서버사이드 인클루드도 지원함
- **서버사이드 인클루드(SSI)**는 웹 서버가 동적 콘텐츠를 생성하는 방법 중 하나임.
- 웹 서버는 리소스에 서버사이드 인클루드(SSI)가 설정되어 있다면, 콘텐츠에 포함된 **특별한 패턴**(예: 변수 값 또는 실행 가능한 스크립트)을 처리하여, 클라이언트에게 보내기 전에 동적으로 변환함.
- SSI는 보통 **HTML 주석 안**에 포함되어 있으며, 서버는 이 패턴을 검사하고 변수를 치환하거나 실행 가능한 스크립트의 출력을 삽입함.
- 이는 **동적 콘텐츠 생성**을 위한 간단하고 효율적인 방법임.

  ```html
  <!-- index.html -->
  <html>
    <head>
      <title>서버사이드 인클루드 예시</title>
    </head>
    <body>
      <h1>오늘 날짜:<!--#echo var="DATE_LOCAL" --></h1>
      <p>사용자 이름:<!--#echo var="USER" --></p>
    </body>
  </html>
  ```

### 5.7.5 접근 제어

- 웹 서버는 리소스에 대한 접근 제어를 설정할 수 있습니다.
- 이를 통해 클라이언트의 IP 주소를 기반으로 접근을 제한하거나, 특정 리소스에 대한 비밀번호를 요구할 수 있음

## 5.8 단계 5: 응답 만들기

- 서버는 리소스를 식별한 후, 요청 메서드에 따라 동작을 수행하고, 응답 메시지를 반환함
- 응답 메시지에는 상태 코드, 응답 헤더, 그리고 응답 본문이 포함됩니다.

### 5.8.1 응답 엔터티

- 트랜잭션이 응답 본문을 생성하면, 그 내용은 응답 메시지와 함께 반환됨
- 응답 메시지에는 주로 다음이 포함됨

  - Content-Type: 응답 본문의 MIME 타입
  - Content-Length: 응답 본문의 길이
  - 응답 본문: 실제 내용

### 5.8.2 MIME 타입 결정하기

웹 서버는 **응답 본문의 MIME 타입**을 결정하는 책임이 있고 이를 위해 MIME 타입과 리소스를 연결하는 아래와 같은 방법을 사용할 수 있음:

**mime.types**

- 파일 확장자에 기반하여 MIME 타입을 결정함. 파일 이름의 확장자와 연계된 MIME 타입 정보를 mime.types파일에서 찾아 사용함.
- 가장 흔한 방법

```
text/html  html htm
image/jpeg jpg jpeg
text/css   css
```

**매직 타이핑 (Magic typing)**

- 파일 내용을 검사하여 알려진 패턴을 찾아 MIME 타입을 결정함.
- 표준 확장자 없이 이름 지어진 경우는에 특히 유용함

**유형 명시 (Explicit typing)**

- 특정 파일이나 디렉터리 안의 파일들이 파일 확장자나 내용에 상관없이 어떠한 MIME 타입을 갖도록 웹 서버를 설정

**유형 협상 (Type negotiation)**

- 어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있음
- 여러 형식의 리소스 중에서 가장 적합한 MIME 타입을 사용자가 선택할 수 있음

### 5.8.3 리다이렉션

- 웹 서버에서 리다이렉션 응답은 3XX 상태 코드로 반환되며, 이를 통해 브라우저가 다른 위치로 이동하도록 유도함
- 리다이렉션 응답은 Location 헤더에 새로운 URI를 포함하는데 이를 통해 페이지가 이동되거나 콘텐츠의 새로운 위치로 안내됨
- 리다이렉트는 아래의 경우에 유용함

**영구히 리소스가 옮겨진 경우**

- 301 Moved Permanently 상태 코드는 리소스가 영구적으로 새 URL로 이동했음을 나타냄
- 이 응답은 클라이언트에게 북마크를 갱신하라는 안내를 제공할 수 있음

**임시로 리소스가 옮겨진 경우**

- 리소스가 임시로 옮겨졌거나 이름이 변경된 경우, 서버는 클라이언트를 새 위치로 리다이렉트하지만, 나중에는 원래 URL로 돌아오길 원함
- 이때 사용되는 상태 코드는 303 See Other와 307 Temporary Redirect임
- 이 리다이렉션은 임시적인 것이므로, 클라이언트는 북마크를 갱신할 필요가 없음

**URL 증강**

- 서버는 문맥 정보를 포함한 새 URL로 리다이렉트하여, 클라이언트가 리다이렉트를 따라가면 상태 정보가 추가된 완전한 URL을 포함한 요청을 다시 보냄
- 이는 트랜잭션 간 상태를 유지하는 데 유용함
- 이 리다이렉션에 사용되는 상태 코드는 303 See Other와 307 Temporary Redirect임
- ex) 장바구니 담고 구매버튼 누르면 선택한 상품의 정보들을 포함한 URL로 리다이렉트

**부하 균형**

- 서버가 과부하되었을 때, 클라이언트를 다른 서버로 리다이렉트하여 부하를 분산시킬 수 있음
- 이를 위해 303 See Other와 307 Temporary Redirect 상태 코드를 사용함

**친밀한 다른 서버가 있을 때**

- 서버는 특정 사용자에 대한 정보를 가질 수 있으며, 해당 사용자의 정보를 보유한 다른 서버로 클라이언트를 리다이렉트할 수 있음
- 이를 위해 303 See Other와 307 Temporary Redirect 상태 코드를 사용함
- ex) 소셜로그인

**디렉터리 이름 정규화**

- 클라이언트가 디렉터리 이름에 끝 슬래시(/)를 빠뜨리고 요청하면, 대부분의 웹 서버는 이를 자동으로 수정하여 슬래시를 추가한 URI로 리다이렉트함
- 이렇게 하면 상대 경로가 정상적으로 동작할 수 있음

## 5.9 단계 6: 응답 보내기

- 서버는 다수의 클라이언트와 동시에 여러 커넥션을 관리함
- 비지속적 커넥션은 응답 전송 후 자동 종료되어 관리가 단순하지만, 지속적 커넥션은 Content-Length 헤더 계산에 주의가 필요함

## 5.10 단계 7: 로깅

- 트랜잭션이 완료되면 웹 서버는 트랜잭션의 수행 결과를 로그 파일에 기록함
- 대부분의 웹 서버는 다양한 로깅 설정 양식을 제공하여, 로그의 형식과 내용을 유연하게 조정할 수 있음
- 자세한 내용: 21장
