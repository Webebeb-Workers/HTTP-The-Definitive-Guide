# 5. 웹 서버

- 웹 서버는 날씨 정보 제공, 온라인 쇼핑, 친구 찾기 등 다양한 기능을 수행하며 월드 와이드 웹의 핵심 역할을 함
- 월드 와이드 웹(www) : 인터넷 상에서 하이퍼텍스트 문서를 검색하고 접근할 수 있는 시스템으로, 우리가 흔히 사용하는 웹사이트와 웹페이지를 포함하는 공간

## 5.1 다채로운 웹 서버

- 웹 서버 소프트웨어와 웹페이지 제공에 특화된 하드웨어를 카리킴
- 간단한 Perl 스크립트, 대형 상용 서버, 소형 기판 서버 등 기능/크기/형태가가 다양함
- 모든 웹 서버는 HTTP 요청을 받아 리소스나 콘텐츠를 클라이언트에게 반환함

### 5.1.1 웹 서버 구현

**웹 서버의 역할**

- HTTP 프로토콜을 구현함
- 웹 리소스를 관리함
- 웹 서버 관리 기능을 제공함
- TCP 커넥션 관리 책임을 운영체제와 나눠가짐

**운영체제의 지원**

- TCP/IP 네트워크, 파일 시스템, 프로세스 관리 등을 통해 웹 서버의 기능 보조

**웹 서버의 구현 형태**

- 표준 컴퓨터 시스템에서 실행되는 다목적 소프트웨어 웹 서버
- 전자기기 내부의 마이크로프로세서 기반 내장형 웹 서버

### 5.1.2 다목적 소프트웨어 웹 서버

<img width="414" alt="Image" src="https://github.com/user-attachments/assets/48aff166-44df-495a-867d-13fe3a66b09f" />

**기본 특성**

- 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작함
- 대부분의 컴퓨터와 운영체제에서 동작함
- 웹 서버 프로그램으로 오픈소스(아파치, W3C 직소)나 상용 소프트웨어(마이크로소프트, 아이플래닛)를 사용할 수 있음

**시장 현황**

- 전체 웹 서버 중 주요 몇 개의 소프트웨어만 널리 사용됨
- 마이크로소프트(37%), 아파치(35%), nginx(14%)가 시장의 대부분 점유
- nginx는 최근 지속적 성장세 기록

> Q. 표는 꽤 오래전 이야기인데 지금은 어떨까?

### 5.1.3 임베디드 웹 서버

**정의:**

- 일반 소비자용 제품에 내장되는 소형 웹 서버
- ex) 프린터나 가전제품 등에 탑재

**주요 특징:**

- 매우 작은 크기 (1제곱인치 미만도 가능)
- 보통 최소한의 기능만 제공함
- 웹 브라우저를 통한 기기 관리 인터페이스를 제공함

## 5.2 간단한 펄 웹 서버

**HTTP 서버의 규모:**

- 완전한 기능의 HTTP 서버(예: 아파치)는 5만 줄 이상의 코드로 돼있고, 부가적인 처리 모듈들을 더하면 훨씬 커짐
- HTTP/1.1 의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터 링, 그 외 성능을 위한 각종 기능들이 필요
- 최소 기능의 HTTP 서버는 30줄 미만의 펄(Perl) 코드로도 구현 가능

**type-o-serve 프로그램:**

- 간단한 펄(Perl) 기반 웹 서버 프로그램
- HTTP 요청 메시지를 화면에 출력하고, 클라이언트가 응답 메시지를 입력하도록 설계됨.
- 클라이언트-프락시 간 상호작용 테스트에 유용한 진단 도구임

**type-o-serve 프로그램의 작동 방식:**

1. HTTP 연결 대기
2. 요청 메시지 수신 및 화면 출력
3. 사용자가 입력한 응답 메시지를 클라이언트에게 전송

**type-o-serve 프로그램으로 HTTP 통신을 테스트하는 예시**

- 아래 사진은 죠의 하드웨어 상점의 관리자가 type-o-serve를 이용해 어떻게 HTTP 통신을 테스트하는지 보여줌

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/5a76e3af-c53f-4711-8a9d-feca9bd58428" />

1. 관리자는 특정 포트로 수신하는 type-o-serve 진단 서버를 시작

- 죠의 하드웨어 상점 웹 서버는 80포트로 수신하고 있기 때문에 관리자는 `% type-o-serve.pl 8080` 명령을 입력해 type-o-serve 서버를 8080번 포트로 시작함

2. type-o-serve가 동작하기 시작한 후, 죠의 하드웨어 상점 웹 서버에 브라우저로 접근할 수 있음

- `http：//www.joes-hardware.com：8080/foo/bar/blah.txt`에 접근

3. type-o-serve 프로그램은 브라우저로부터 HTTP 요청 메시지를 받아 그 내용을 화면에 출력한 뒤, 관리자가 마침표 하나뿐인 줄로 끝나는 간단한 응답 메시지를 입력할 때까지 기다림

4. type-o-serve는 HTTP 응답 메시지를 브라우저에게 돌려주고, 브라우저는 응답 메시지의 본문을 화면에 출력함

## 5.3 진짜 웹 서버가 하는 일

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/8ea53117-3a48-42bd-bfda-76550d984e72" />

- 최신형 상용 웹 서버가 일반적으로 수행하는 주요 작업은 다음과 같음

1. `커넥션`: 클라이언트의 접속을 받아들이거나 원치 않는 클라이언트라면 연결을 닫음
2. `요청 수신`: HTTP 요청 메시지를 네트워크로부터 읽어 들임
3. `요청 처리`: 요청 메시지를 해석하고 적절한 행동을 취함
4. `리소스 접근`: 요청 메시지에서 지정한 리소스에 접근함
5. `응답 생성`: 올바른 헤더를 포함한 HTTP 응답 메시지를 생성함
6. `응답 송신`: 응답 메시지를 클라이언트에게 전달함
7. `로그 남기기`: 트랜잭션 완료에 대한 정보를 로그 파일에 기록함

## 5.4 단계 1: 클라이언트 커넥션 수락

- 지속적 커넥션이 있는 경우: 기존 커넥션을 사용해 요청 전송 가능
- 지속적 커넥션이 없는 경우: 새로운 커넥션을 열어야 함

### 5.4.1 새 커넥션 다루기

- 클라이언트가 웹 서버에 TCP 커넥션을 요청하면 서버는 커넥션을 맺고 IP 주소를 추출하여 클라이언트를 확인함
- 서버는 새 커넥션을 목록에 추가하고, 오고 가는 데이터를 처리하기 위한 준비를 함
- 서버는 필요에 따라 커넥션을 거절하거나 즉시 닫을 수 있음
- 서버는 인가되지 않거나 악의적인 클라이언트의 경우 커넥션을 닫을 수 있음

### 5.4.2 클라이언트 호스트 명 식별

- 대부분의 웹 서버는 **역방향 DNS(reverse DNS)**를 사용해 클라이언트 IP 주소를 호스트 명으로 변환한다.
- 클라이언트 호스트 명은 접근 제어와 로깅에 활용될 수 있다.
- **호스트 명 룩업(hostname lookup)**은 시간이 많이 걸릴 수 있어 웹 트랜잭션 속도를 저하시킬 수 있다.
- 대용량 웹 서버에서는 호스트 명 분석을 꺼두거나 특정 콘텐츠에 대해서만 활성화한다.
- 아파치 서버에서는 HostnameLookups 설정 지시자를 통해 호스트 명 룩업을 제어할 수 있다.
  - 예: HTML과 CGI 리소스에만 호스트 명 분석을 켜도록 설정 가능.
    ```
    HostnameLookups off
    <Files ~ "\.(html|htm|cgi)$">
        HostnameLookups on
    </Files>
    ```

> 접근 제어와 로깅이 뭐지, 호스트 명 룩업이 뭐지

### 5.4.3 ident를 통해 클라이언트 사용자 알아내기

**IETF ident 프로토콜 개요:**

- 몇몇 웹 서버는 IETF ident 프로토콜을 지원함
- 서버가 HTTP 커넥션을 초기화한 사용자 이름을 찾을 수 있게 해줌
- 웹 서버 로깅에서 유용하며, 일반 로그 포맷(Common Log Format)의 두 번째 필드가 ident 사용자 이름을 담음

**작동 방식:**

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/b0ebb6e3-8e26-4f00-b911-c5238390bbea" />

- 클라이언트가 HTTP 커넥션을 열음
- 서버가 클라이언트의 identd 서버 포트(113)로 커넥션을 열음
- 서버가 새 커넥션에 대응하는 사용자 이름을 묻는 요청을 보냄

**ident 프로토콜의 한계점:**

- 많은 클라이언트 PC가 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않음
- HTTP 트랜잭션을 유의미하게 지연시킴
- 방화벽이 ident 트래픽 유입을 막는 경우가 많음
- 안전하지 않고 조작하기 쉬움
- 가상 IP 주소를 잘 지원하지 않음
- 클라이언트 사용자 이름 노출로 프라이버시 침해 우려가 있음

**실제 활용:**

- 조직 내부에서는 잘 사용 할 수 있지만 공공 인터넷에서는 위의 한계들로 인해 잘 동작하지 않음
- 아파치 웹 서버는 IdentityCheck 지시어로 ident 룩업 사용 가능
- ident 정보가 없으면 아파치는 ident 로그 필드를 하이픈(-)으로 채움
- 보통 ident 정보가 없어서 일반 로그 포맷 로그파일의 두 번째 필드는 하이픈으로 채워짐

## 5.5 단계 2: 요청 메시지 수신

- 커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메시지를 구성함

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/858ec09a-033d-4267-a41b-06556145339a" />

**웹 서버의 요청 메시지 파싱 단계:**

1. 요청줄 파싱

   - 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자(URI), 버전 번호를 찾음
   - 각 값은 스페이스 한 개로 분리되어 있으며, 요청줄은 캐리지 리턴 줄바꿈(CRLF)문자열로 끝남

2. 메시지 헤더 읽기

   - 각 헤더는 CRLF로 끝남

3. 빈 줄 확인

   - 헤더의 끝을 나타내는 CRLF로 끝나는 빈 줄 찾기

4. 요청 본문 처리

   - 본문이 존재하는 경우 Content-Length 헤더에 정의된 길이만큼 읽기

**주의사항:**

- 네트워크로부터 데이터가 불규칙적으로 수신됨(속도가 일정하지 않음)
- 네트워크 커넥션이 언제든 무효화될 수 있음(갑작스러운 연결 종료)
- 파싱 가능한 수준의 분량을 확보할 때까지 데이터를 메모리에 임시 저장해 둘 필요가 있음

### 5.5.1 메시지의 내부 표현

<img width="418" alt="Image" src="https://github.com/user-attachments/assets/5d33e526-7e06-4e19-bf67-5edb2a9bbdbd" />

**웹 서버가 요청 메시지를 내부적으로 처리하는 방법:**

- 요청 메시지를 처리하기 쉽게 내부 자료 구조로 변환하여 저장
- 자료 구조에는 메시지 조각들의 포인터, 각 조각의 길이를 담을 수 있음
- 헤더는 속도가 빠른 룩업 테이블에 저장되어 각 필드에 신속하게 접근 가능

### 5.5.1 커넥션 입력/출력 처리 아키텍처

- 고성능 웹 서버는 수천 개의 동시 커넥션 지원
- 커넥션마다 요청 패턴이 다양함 (느린 요청, 대기 중, 빠른 요청)
- 웹 서버는 항상 새 요청을 주시하며, 아키텍처에 따라 처리 방식이 다름

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/773874e3-d982-429f-8b33-8b9a90dfb7da" />

**단일 스레드 웹 서버(그림 5-7a)**

- 단일 스레드 웹 서버는 한 번에 하나씩 요청을 처리함
- 트랜잭션이 완료되면, 다음 커넥션이 처리됨
- 이 아키텍처는 구현하기 간단하지만 처리 도중에 모든 다른 커넥션은 무시되기 때문에 심각한 성능 문제를 만들어내므로 오직 로드가 적은 서버나 type-o-serve와 같은 진단도구에서만 적당하다.

**멀티프로세스와 멀티스레드 웹 서버(그림 5-7b)**

- 멀티프로세스와 멀티스레드 웹 서버는 여러 요청의 동시 처리를 위해 다수의 프로세스나 스레드를 할당함
- 스레드/프로세스는 필요할 때마다 생성되거나 미리 생성될 수 있음
- 일부 서버는 각 커넥션마다 스레드/프로세스를 하나씩 할당하는데, 이는 많은 동시 커넥션을 처리할 때 과도한 메모리와 시스템 리소스를 소비하게 되기 때문에 많은 멀티스레드 웹 서비스는 스레드/프로세스의 최대 개수를 제한함

**다중 I/O 서버(그림 5-7c)**

- 대량의 커넥션을 지원하기 위해 많은 웹 서버가 다중 아키텍처를 채택함
- 다중 아키텍처에서는 모든 커넥션의 활동을 동시에 감시함
- 커넥션의 상태가 변경되면(데이터 사용 가능, 에러 발생 등) 해당 커넥션에 대해 작은 양의 처리를 수행함
- 처리가 완료되면 해당 커넥션은 다음 상태 변경을 기다리며 열린 커넥션 목록으로 돌아감
- 실제 처리가 필요한 커넥션에 대해서만 작업을 수행하므로, 유휴 상태의 커넥션에 스레드와 프로세스가 불필요하게 할당되지 않음

**다중 멀티스레드 웹 서버(그림 5-7d)**

- CPU 여러 개의 이점을 활용하기 위해 멀티스레딩과 다중화(multiplexing)를 결합하는 방식을 사용함
- 여러 스레드(보통 하나의 물리적 프로세스에 속함)가 각각 열려있는 커넥션들을 나눠서 감시함
- 각 스레드는 자신이 담당하는 커넥션들에 대해 작은 단위로 작업을 수행함

## 5.6 단계 3: 요청 처리

- 웹 서버는 요청을 받으면 메서드, 리소스, 헤더, 본문을 추출하여 처리함
- 요청 메시지의 본문(엔터티 본문) 포함 여부는 메서드에 따라 다름:

  - POST: 본문 필수
  - OPTIONS: 본문 허용 (선택적)
  - GET: 본문 금지

- 이 책의 나머지 부분에서 요청 처리 방법을 다룰 예정이므로 여기서는 자세히 설명하지 않음
