# 다채로운 웹 서버
### 웹서버
- HTTP 요청을 받아서 필요한 콘텐츠를 클라이언트(브라우저 등)에 보내주는 역할을 한다.
- 소프트웨어나 장비 둘 다 "웹 서버"라 부를 수 있다.

## 웹 서버 구현
- HTTP 및 TCP 처리를 구현한 시스템이다.
- HTTP 프로토콜을 구현하고, 웹 리소스와 웹 서버 관리 기능을 제공한다.
- TCP 커넥션 관리는 운영체제와 역할을 분담한다. 운영체제는 컴퓨터 시스템의 하드웨어 관리, TCP/IP 네트워크 지원, 파일 시스템 관리, 프로세스 관리 등을 담당한다.

### 웹 서버 형태
- **다목적 소프트웨어 웹 서버**: 표준 컴퓨터 시스템에 설치 및 실행
- **내장형 웹 서버**: 전자기기에 내장된 칩으로 구현, 관리 콘솔 역할 수행

### 다목적 소프트웨어 웹 서버
- 다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.
- 오픈 소스 소프트웨어나 상용 소프트웨어를 사용 가능하다.
- 웹 서버 소프트웨어는 대부분의 컴퓨터와 운영체제에서 작동하며, 전 세계에 수많은 종류가 존재하지만, 일부만 널리 사용된다.
- **웹 서버 점유율 (2014년 기준)**: Microsoft 웹 서버: 37%, Apache 웹 서버: 35%, Nginx: 14% (점유율이 꾸준히 증가 중)

### 임베디드 웹 서버
- 임베디드 웹 서버는 일반 소비자용 제품에 내장되어, 사용자가 웹 브라우저 인터페이스를 통해 기기를 간편하게 관리할 수 있도록 설계된 작은 웹 서버이다.
- 크기가 매우 작고, 최소한의 기능만 제공한다.
- 예시 : 아이픽 성냥 머리 크기 웹 서버, 넷미디어 사이트플레이어 SP1 이더넷 웹 서버

# 간단한 펄 웹 서버
## 복잡한 HTTP 서버
- 아파치 웹 서버와 같은 대형 HTTP 서버는 수만 줄의 코드로 이루어져 있으며, 다양한 기능을 지원한다.
- HTTP/1.1을 지원하려면 리소스 관리, 가상 호스팅, 접근 제어, 설정, 모니터링 등의 다양한 기능이 필요하다.

## 간단한 HTTP 서버 구현
- 최소한의 기능을 가진 HTTP 서버는 30줄 이하의 Perl 코드로도 구현할 수 있다.
- type-o-serve는 HTTP 서버의 기본적인 기능을 시뮬레이션하는 도구로, 클라이언트의 요청 메시지를 정확하게 기록하고 어떤 응답 메시지라도 보낼 수 있도록 돕는다.

<img width="577" alt="스크린샷 2025-01-20 오후 10 19 17" src="https://github.com/user-attachments/assets/70f36b41-f792-4ce4-ad0f-6ef622e85ccd" />

### type-o-serve 실행
- 관리자는 type-o-serve 서버를 특정 포트(여기서는 8080번 포트)에서 실행한다.
- type-o-serve.pl 8080 명령어로 서버를 시작하면, 8080 포트에서 HTTP 요청을 받을 준비가 된다.

### 브라우저에서 접속
- 웹 브라우저를 통해 http://www.joes-hardware.com:8080/foo/bar/blah.txt와 같은 URL로 접근한다.
- 이때 type-o-serve 프로그램이 HTTP 요청 메시지를 수신하고 이를 화면에 출력한다.

### 응답 메시지 생성
- 관리자는 HTTP 요청 메시지를 확인한 후, 응답 메시지를 수동으로 입력한다.
- 응답 메시지는 마침표 하나로 끝나는 줄로 간단히 입력된다.

### 응답 메시지 반환
- type-o-serve는 입력된 HTTP 응답 메시지를 클라이언트(브라우저)에게 반환한다.
- 브라우저는 서버로부터 받은 응답 메시지를 출력하고, 사용자는 그 내용을 확인할 수 있다.

# 진짜 웹서버가 하는 일
<img width="576" alt="image" src="https://github.com/user-attachments/assets/88a21e80-2983-43aa-ad28-1255c50ace13" />

### 1. 커넥션 처리
- 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트는 차단

### 2. 요청 수신
- 네트워크를 통해 HTTP 요청 메시지를 읽음

### 3. 요청 처리
- 요청 메시지를 해석하고, 필요한 작업을 수행

### 4. 리소스 접근
- 요청된 리소스에 접근

### 5. 응답 생성
- 올바른 HTTP 헤더와 함께 응답 메시지를 생성

### 6. 응답 전송
- 클라이언트에게 HTTP 응답을 보냄

### 7. 로그 작성
- 트랜잭션 완료 정보를 로그 파일에 기록

# 단계 1: 클라이언트 커넥션 수락
## 새 커넥션 다루기
- 클라이언트가 TCP 커넥션 요청을 보내면, 웹 서버는 커넥션을 수락하고 IP 주소를 추출해 클라이언트의 정보를 확인한다.
- 커넥션이 수락되면 목록에 추가하고 데이터를 주고받을 준비를 한다.
- 웹 서버는 IP 주소, 호스트명, 또는 기타 신원 정보를 기준으로 인가되지 않거나 악의적이라 판단된 커넥션을 거절하거나 닫을 수 있다.

## 클라이언트 호스트 명 식별
- 대부분의 웹 서버는 역방향 DNS를 사용하여 클라이언트의 IP 주소를 호스트 명으로 변환한다.
- 이 호스트 명은 접근 제어와 로깅에 사용될 수 있다.
- 하지만 호스트 명 룩업은 시간이 오래 걸릴 수 있어, 웹 트랜잭션을 느리게 할 수 있다. 
- 그래서 대용량 웹 서버는 호스트 명 분석을 비활성화하거나 특정 콘텐츠에 대해서만 사용한다. 

> Q. 특정 콘텐츠에서 호스트 명 룩업이 필요한 이유?

## ident를 통해 클라이언트 사용자 알아내기
- IETF ident 프로토콜은 웹 서버가 HTTP 커넥션을 초기화한 클라이언트의 사용자 이름을 찾아낼 수 있도록 도와주는 프로토콜이다.
- 이 정보는 웹 서버 로그에서 유용하며, 특히 일반 로그 포맷의 두 번째 필드에 ident 사용자 이름이 포함되어 있다.

### 동작 방식
<img width="575" alt="image" src="https://github.com/user-attachments/assets/dbb89870-2bff-4604-aec0-42a88194eae0" />

- TCP 포트 113을 통해 identd 프로세스가 클라이언트에서 실행되고 있어야 하며, 이를 통해 클라이언트의 사용자 이름을 얻을 수 있다.
- 클라이언트가 HTTP 커넥션을 열면, 웹 서버는 클라이언트의 identd 서버(포트 113)에 요청을 보내어 사용자 이름을 묻는다.
- 클라이언트가 identd 서버에 응답하면, 웹 서버는 해당 사용자 이름을 로그에 기록하거나 요청을 처리한다.

### 문제점
- 많은 클라이언트 PC는 identd 신원확인 프로토콜 데몬 소프트웨어를 실행하지 않는다.
- ident 프로토콜은 HTTP 트랜잭션을 유의미하게 지연시킨다.
- 방화벽이 ident 트래픽이 들어오는 것을 막는 경우가 많다.
- ident 프로토콜은 안전하지 않고 조작하기 쉽다.
- ident 프로토콜은 가상 IP 주소를 잘 지원하지 않는다.
- 클라이언트 사용자 이름의 노출로 인한 프라이버시 침해의 우려가 있다.

### 아파치 웹 서버에서의 설정
- IdentityCheck 지시어를 사용하여 ident 프로토콜을 활성화할 수 있다.

> Q. 클라이언트 호스트 명과 ident의 차이점?

# 단계 2： 요청 메시지 수신
- 네트워크 커넥션에서 데이터를 읽어 들인다.
- 데이터를 파싱하여 HTTP 요청 메시지를 구성한다.

### 요청 메시지 파싱
#### 요청줄 파싱
- 요청 메서드, 리소스 식별자(URI), HTTP 버전을 추출. 요청줄은 공백으로 분리된 값들로 구성되며, 마지막에 CRLF 문자열로 종료
#### 메시지 헤더 읽기
- 각 헤더는 CRLF로 끝남. 헤더 끝을 나타내는 빈 줄(CRLF로 끝나는 줄)을 확인
#### 본문(Content) 읽기
- 본문이 존재하는 경우, 본문의 길이는 Content-Length 헤더를 참고해 읽음

## 메세지 내부 표현
<img width="575" alt="image" src="https://github.com/user-attachments/assets/c72571a0-9675-4f1f-bd87-0469c45e87c7" />

- 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.
- 요청 메시지의 각 부분에 대한 포인터와 길이를 저장한다.
- 헤더는 룩업 테이블에 저장되어, 특정 헤더 필드에 신속하게 접근할 수 있도록 최적화된다.

## 커넥션 입력/출력 처리 아키텍처
- 고성능 웹 서버는 수천 개의 커넥션을 동시에 열어, 전 세계 클라이언트들과 통신할 수 있도록 설계된다.
- 일부 커넥션은 요청을 느리게 보내거나 조용히 대기 중이고, 다른 커넥션은 빠르고 빈번하게 요청을 보낸다.
- 웹 서버는 언제라도 도착할 수 있는 요청을 처리하기 위해 지속적으로 대기하고 있으며, 웹 서버의 아키텍처 설계에 따라 요청 처리 방식이 다르다 

<img width="573" alt="image" src="https://github.com/user-attachments/assets/7e8205a7-d16a-4345-9338-171f6160bdf1" />

### 단일 스레드 웹 서버
- 단일 스레드 웹 서버는 한 번에 하나의 요청만 처리한다.
- 구현이 간단하지만, 처리 도중에 모든 다른 커넥션은 무시된다.
- 이 방식은 부하가 적은 서버나 진단 도구(예: type-o-serve)에 적합하다.

### 멀티프로세스와 멀티스레드 웹 서버
- 멀티프로세스와 멀티스레드 웹 서버는 여러 요청을 동시에 처리하기 위해 각각의 요청에 프로세스나 스레드를 할당한다.
- 스레드/프로세스는 요청 시 생성하거나 미리 생성할 수 있다.
- 매 커넥션마다 스레드/프로세스를 할당하면, 동시 커넥션 증가로 인해 메모리와 리소스 소모가 급증해 성능 문제가 발생할 수 있다.
- 이를 방지하기 위해, 최대 스레드/프로세스 개수를 제한하는 방식이 일반적이다.

### 다중 I/O 서버
- 대량의 커넥션을 지원하기 위해 많은 웹 서버는 다중 아키텍처를 채택한다.
- 모든 커넥션을 동시에 감시하며, 상태 변화(예: 데이터 도착, 에러 발생)가 있을 때만 작은 처리를 수행한다.
- 처리가 완료되면, 커넥션은 다시 열린 커넥션 목록으로 돌아간다.
- 작업은 필요한 경우에만 수행되며, 유휴 커넥션에 스레드나 프로세스를 할당하지 않아 리소스를 효율적으로 사용한다.

### 다중 멀티스레드 웹 서버
- 몇몇 시스템은 멀티스레딩과 다중화(multiplexing)를 결합하여 여러 CPU 코어의 장점을 활용한다.
- 여러 스레드는 하나의 프로세스 내에서 여러 커넥션을 감시하며, 각 커넥션에 대해 필요한 작업을 조금씩 분배하여 처리한다.

# 단계 3 : 요청 처리
- 웹 서버는 요청을 받으면, 요청에서 메서드, 리소스, 헤더, 그리고 본문(있을 경우)을 추출하여 처리한다.
    - POST와 같은 메서드는 요청 메시지에 엔터티 본문(body)을 포함할 것을 요구한다.
    - OPTIONS와 같은 메서드는 본문을 허용하나, 반드시 요구하지는 않는다.
    - GET과 같은 일부 메서드는 요청 메시지에 본문이 포함되는 것을 금지한다.