**정보 보호의 필요성**

- 웹은 개인 업무 및 데이터 접근을 용이하게 하지만, 보안이 필요함.
- 허가된 사용자만 특정 정보 및 업무에 접근해야 함.
- 개인 프로필, 문서, 기업의 민감한 전략 문서 등은 권한이 없는 사용자가 볼 수 없어야 함.
- 서버는 사용자를 식별하고, 권한을 검증해야 함.

**사용자 식별과 인증**

- 서버는 사용자를 식별해야 하며, 이를 통해 접근 권한을 결정할 수 있음.
- 인증(Authentication)은 사용자의 신원을 증명하는 과정.
- 일반적으로 **사용자 이름 + 비밀번호** 방식으로 인증 수행.

**HTTP 기본 인증 (Basic Authentication)**

- HTTP는 자체적인 인증 관련 기능을 제공함.

# 12.1 인증

**인증이란?**

- **인증(Authentication)**: 사용자가 누구인지 증명하는 것
- 예시:
  - 여권이나 운전면허증을 제시.
  - 자동 전화기에 **PIN 번호** 입력.
  - 컴퓨터 대화상자에 **비밀번호** 입력.

**완벽한 인증은 불가능**

- 비밀번호:
  - **추측**되거나 **엿들을** 가능성이 있음.
- 신분증:
  - **도난** 또는 **위조**될 수 있음.

## 12.1.1 HTTP의 인증요구/응답 프레임워크

<img width="416" alt="Image" src="https://github.com/user-attachments/assets/6f9178d7-5029-48a5-8ce9-b85959f1304b" />

**HTTP 인증 프레임워크**

- HTTP는 자체적인 **인증요구/응답 프레임워크**를 제공.
- **그림 12-1**: HTTP 인증 모델.

**인증 과정**

1. **클라이언트가 요청**을 보냄.
2. 서버는 요청을 처리하는 대신, **인증 요구** 응답을 반환.
3. 사용자는 **인증 정보(사용자 이름과 비밀번호)**를 포함하여 다시 요청.
4. 서버가 인증 정보를 검증:
   - 인증 정보가 맞으면 요청을 정상 처리.
   - 인증 정보가 틀리면 다시 **인증 요구** 또는 **에러 반환**.

## 12.1.2 인증 프로토콜과 헤더

**HTTP 인증 프레임워크 확장성**

- HTTP는 **제어 헤더**를 통해 다양한 **인증 프로토콜**을 확장할 수 있음.
- 인증 프로토콜에 따라 **헤더 형식과 내용**이 달라짐.

**HTTP 공식 인증 프로토콜**

- **기본 인증(Basic Authentication)**
- **다이제스트 인증(Digest Authentication)**
- 미래에는 새로운 인증 프로토콜이 추가될 가능성이 있음.

> 지금은??

**HTTP 인증 절차**

| 단계          | 헤더                           | 설명                                                       | 메서드/상태        |
| ------------- | ------------------------------ | ---------------------------------------------------------- | ------------------ |
| **요청**      | -                              | 첫 번째 요청에는 인증 정보 없음                            | `GET`              |
| **인증 요구** | `WWW-Authenticate`             | 서버가 **401 Unauthorized** 상태와 함께 사용자 인증 요청   | `401 Unauthorized` |
| **인증**      | `Authorization`                | 클라이언트가 **사용자 이름과 비밀번호**를 포함한 요청 전송 | `GET`              |
| **성공**      | `Authentication-Info` (선택적) | 인증 성공 시, 서버가 **200 OK** 응답                       | `200 OK`           |

**인증 요청 및 응답 흐름**

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/4e850c8b-f4c5-498e-a12d-27cdba8fd04c" />

1. 클라이언트가 **인증 없이 요청**을 보냄.
2. 서버가 **401 Unauthorized** 상태와 함께 `WWW-Authenticate` 헤더를 포함한 응답을 반환.
3. 클라이언트가 `Authorization` 헤더에 **인코딩된 비밀번호와 인증 정보**를 포함하여 재요청.
4. 서버가 인증이 성공하면 **200 OK** 상태 코드와 함께 응답.
5. 일부 인증 프로토콜은 `Authentication-Info` 헤더에 **추가 인증 정보**를 포함할 수도 있음.

## 12.1.3 보안 영역

<img width="409" alt="Image" src="https://github.com/user-attachments/assets/fcd6c89b-d934-42a4-b3ff-22a2e575e774" />

**보안 영역의 개념**

- HTTP는 **보안 영역(Realm)** 을 사용하여 리소스마다 **다른 접근 조건**을 적용.
- 각 보안 영역은 **다른 사용자 권한**을 요구함.
- `WWW-Authenticate` 헤더의 `realm` 지시자를 통해 영역을 구분.

**보안 영역의 예시**

- 예를 들어, 웹 서버가 두 개의 보안 영역을 가질 수 있음:
  - **회사 재정 정보 (Corporate Financials)**
  - **개인 가족 문서 (Family Documents)**
- 회사의 CEO는 **재정 정보**에 접근할 수 있지만, **가족 문서**에는 접근할 수 없음.

**기본 인증과 보안 영역**

서버가 특정 보안 영역에 접근하기 위해 인증을 요구하는 예시:

```http
HTTP/1.0 401 Unauthorized
WWW-Authenticate: Basic realm="Corporate Financials"
```

- realm 값은 사용자가 권한의 범위를 이해하는 데 도움을 줌.
- 예를 들어 "executive-committee@bigcompany.com" 같은 서버의 호스트명을 realm으로 설정할 수도 있음.

# 12.2 기본 인증

**기본 인증 개요**

- **가장 널리 사용되는 HTTP 인증 규약**으로, 대부분의 클라이언트와 서버에서 지원됨.
- HTTP/1.0에 기술되어 있었지만, 이후 **RFC 2617**로 상세 내용이 옮겨짐

**기본 인증의 동작 방식**

1. **클라이언트 요청 → 서버 거부**

   - 웹 서버는 클라이언트의 요청을 **401 Unauthorized** 상태 코드로 거부.
   - `WWW-Authenticate` 헤더에 **보안 영역(Realm)** 을 기술하여 응답.

2. **브라우저의 인증 요청**

   - 브라우저는 인증이 필요함을 인식하고 **사용자 이름과 비밀번호 입력 창**을 띄움.

3. **사용자 입력 후 요청 재전송**
   - 사용자가 입력한 계정 정보를 `Authorization` 요청 헤더에 **암호화**하여 서버로 전송.

## 12.2.1 기본 인증의 예

**기본 인증 요청과 응답 흐름**

그림 12-2의 예를 통해 기본 인증의 동작 과정을 살펴보자.

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/4e850c8b-f4c5-498e-a12d-27cdba8fd04c" />

1. **클라이언트 요청 (`그림 12-2a`)**

   - 사용자가 가족사진인 `/family/jeff.jpg` 요청

2. **서버의 인증 요구 (`그림 12-2b`)**

   - 서버가 `401 Authorization Required` 응답.
   - `WWW-Authenticate` 헤더를 포함하여 인증 요청.

3. **클라이언트의 인증 정보 입력 (`그림 12-2c`)**

   - 브라우저가 사용자에게 Family 영역에 관한 사용자 이름과 비밀번호 입력 요청.
   - 사용자가 입력한 정보를 `username:password` 형태로 이어 붙인 후 Base64 인코딩.
   - 인코딩된 값을 Authorization 헤더에 담아 서버로 재요청.

4. **서버의 인증 검증 및 응답 (`그림 12-2d`)**

   - 서버가 Authorization 헤더 값(사용자 이름과 비밀번호)을 Base64 디코딩하여 계정 정보 확인.
   - 인증이 성공하면 요청된 문서와 함께 200 OK 응답.

| 단계                                  | 설명                                                                                                                                                                                             | 헤더 예시                                                       |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------- |
| **인증 요구 (서버에서 클라이언트로)** | 각 사이트는 보안 영역마다 다른 비밀번호가 있을 수 있다. `realm` 값은 요청받은 문서 집합의 이름을 따옴표로 감싸며, 사용자는 이 정보를 보고 어떤 비밀번호를 사용해야 하는지 알 수 있다.            | `WWW-Authenticate: Basic realm="보안 영역 이름"`                |
| **인증 응답 (클라이언트에서 서버로)** | 사용자 이름과 비밀번호를 콜론으로 잇고, 이를 **Base64로 인코딩**해서 `Authorization` 헤더에 담아 서버로 전송한다. 이 방식은 네트워크에서 사용자 이름과 비밀번호가 쉽게 노출되지 않도록 보호한다. | `Authorization: Basic base64로 인코딩한 사용자 이름과 비밀번호` |

- 기본 인증 프로토콜은 Authentication-Info 헤더를 사용하지 않음

## 12.2.2 Base-64 사용자 이름/비밀번호 인코딩

<img width="420" alt="Image" src="https://github.com/user-attachments/assets/0d0254a7-864c-4467-be12-d2088dab199b" />

- HTTP 기본 인증은 사용자 이름과 비밀번호를 **콜론(:)**으로 이어서 합친 후, **Base-64 인코딩**을 사용하여 인코딩함
- Base-64 인코딩은 8비트 바이트 시퀀스를 6비트 덩어리로 변환하고, 이 6비트 덩어리는 알파벳과 숫자 등 64개의 문자로 표현됨

**예시:**

- 사용자 이름: `brian-totty`
- 비밀번호: `Ow!`
- 결합: `brian-totty:Ow!`
- Base-64 인코딩: `YnJpYW4tdG90dHk6T3ch`

**Base-64 인코딩의 목적:**

- 바이너리, 텍스트, 국제 문자 데이터를 전송 가능한 문자로 변환
- 원본 문자열이 변질되지 않고 전송될 수 있도록 보호
- 사용자 이름과 비밀번호에 HTTP 헤더에서 사용할 수 없는 문자가 포함될 때 유용
- 서버나 네트워크에서 예기치 않게 사용자 이름과 비밀번호가 노출되는 문제를 예방

## 12.2.3 프락시 인증

- 중개 프락시 서버를 통해 인증할 수도 있음
- 어떤 회사에서는 사용자들이 회사 서버나 LAN, 무선 네트워크에 접근하기 전에 프락시 서버를 거쳐 인증하는 방식을 사용함
- 이를 통해 프락시 서버에서 중앙 집중적으로 접근 정책을 관리할 수 있습니다.
- 프락시 인증 절차는 웹 서버 인증과 비슷하지만, 사용되는 상태 코드와 헤더가 다름

## 웹 서버와 프락시 인증의 대조:

| **웹 서버**           | **프락시 서버**           |
| --------------------- | ------------------------- |
| 비인증 상태 코드: 401 | 비인증 상태 코드: 407     |
| WWW-Authenticate      | Proxy-Authenticate        |
| Authorization         | Proxy-Authorization       |
| Authentication-Info   | Proxy-Authentication-Info |

# 12.3 기본 인증의 보안 결함

- 기본 인증은 단순하고 편리하지만 보안상 여러 가지 결함이 존재함
- 아래는 기본 인증에서 발생할 수 있는 주요 보안 결함

### 1. 사용자 이름과 비밀번호의 쉽게 디코딩 가능한 전송

- 기본 인증은 사용자 이름과 비밀번호를 base-64로 인코딩하여 전송
- base-64로 인코딩된 문자열은 쉽게 디코딩할 수 있어, 이를 가로채면 비밀번호가 노출됨
- 해결 방법: SSL 암호화 채널을 사용하거나 다이제스트 인증과 같은 보안이 더 강화된 프로토콜을 사용

### 2. 재전송 공격

- 기본 인증은 재전송 공격을 예방하지 않음
- 제삼자가 사용자 이름과 비밀번호를 캡처한 뒤 이를 서버로 재전송하면 인증에 성공할 수 있음

> 이게 무슨 소리지? '캡처' 란게 뭘까

### 3. 사용자가 동일한 비밀번호를 여러 사이트에서 사용하는 문제

- 많은 사용자가 여러 사이트에서 동일한 사용자 이름과 비밀번호를 사용함
- 악의적인 공격자는 이메일 사이트에서 캡처한 비밀번호로 다른 중요한 사이트에 접근할 수 있음

### 4. 중간자 개입

- 프락시나 중개자가 트랜잭션의 본래 의도를 변경할 수 있음
- 기본 인증은 중간자가 트랜잭션을 변경하는 경우에도 정상 동작을 보장하지 않음

### 5. 가짜 서버에 대한 취약성

- 기본 인증은 가짜 서버에 취약함
- 사용자가 가짜 서버에 연결되어 있는 동안 공격자는 비밀번호를 요청하고, 이를 나중에 사용할 수 있음

**결론**

- 기본 인증은 보안이 그렇게 중요하지 않은 애플리케이션에서 유용할 수 있으며, 사용자가 우연히 접근하지 않도록 보호하는 데 사용됨
- 중요한 정보나 고급 보안이 필요한 경우에는 SSL 암호화 및 더 강력한 인증 방법을 사용하는 것이 좋음
- 기본 인증은 보안 암호화와 함께 사용될 때 유용함
