# 3. HTTP 메시지

HTTP 메시지가 어떻게 흘러가고, 어떻게 구성되어 있고, 각 영역별로 어떤 역할을 맡고 있는지 알아보는 챕터

## 3.1 메시지의 흐름

- HTTP 메시지 = 메시지 내용과 의미 설명하는 텍스트 메타 정보 + 데이터 (선택적)
- 클라이언트, 서버, 프락시 사이 통과
- 메시지 방향: 인바운드, 아웃바운드, 업스트림, 다운스트림

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신한다.

- 인바운드, 아웃바운드 ➡️ 트랜잭션 방향 표현 용어
- **인바운드**: 메시지가 원 서버로 향하는 방향
- **아웃바운드**: 모든 처리 후 메시지가 사용자 에이전트로 돌아오는 방향

<img width="571" alt="image" src="https://github.com/user-attachments/assets/699815cc-88e2-4848-bec2-ceda707a053a" />

### 3.1.2 다운스트림으로 흐르는 메시지

- **다운스트림**: 요청/응답 메시지 관계없이 모든 메시지는 다운스트림으로 흐름, 메시지 수신자는 발송자의 다운스트림
- **업스트림**: 메시지의 발송자는 수신자의 업스트림

<img width="577" alt="image" src="https://github.com/user-attachments/assets/a069777a-cd4a-4466-b6d4-c1c97bd5ea55" />

## 3.2 메시지의 각 부분

<img width="573" alt="image" src="https://github.com/user-attachments/assets/d3ce1f35-a758-4d0d-a497-299a4ab22a26" />

- **시작줄**: 아스키 문자열 + 줄바꿈 문자열 (CRLF: 캐리지 리턴 + 개행 문자)
- **헤더**: 아스키 문자열 + 줄바꿈 문자열 (CRLF: 캐리지 리턴 + 개행 문자)
  - Content-Type: 본문 타입
  - Content-Length: 본문 크기
- **본문**: 데이터 덩어리 (텍스트, 이진 데이터, 공백 등)

### 3.2.1 메시지 문법

**요청 메시지 형식**

```
<메서드><요청 URL><버전>
<헤더>

<엔터티 본문>
```

- **메서드**: 클라이언트 ➡️ 서버가 리소스에 대해 수행해주길 바라는 동작 (GET, HEAD, POST)
- **요청 URL**: 리소스 지칭하는 완전한 URL / URL의 경로 구성
- **버전**: 메시지에서 사용 중인 HTTP 버전 `HTTP/메이저.마이너`

**응답 메시지 형식**

```
<버전><상태 코드><사유 구절>
<헤더>

<엔터티 본문>
```

- **상태 코드**: 요청 중에 발생한 일에 대한 세 자리 숫자
- **사유 구절**: 상태 코드의 의미를 사람이 이해할 수 있게 하는 짧은 문구

- **헤더**: 이름: 값(CRLF), 몇몇 버전의 HTTP는 어떤 특정 헤더 포함해야 유효함
- **엔터티 본문**: 데이터 블록(CRLF)

### 3.2.2 시작줄

**요청줄**

```
<메서드><요청 URL><버전>
```

<img width="597" alt="image" src="https://github.com/user-attachments/assets/82ff885a-c197-4661-936e-04bc454c9c85" />

- 서버 구현에 따라 추가 메서드로 HTTP 명세 확장 가능 ➡️ 확장 메서드

> Q. PATCH는 왜 없지?

**응답줄**

```
<버전><상태 코드><사유 구절>
```

<img width="394" alt="image" src="https://github.com/user-attachments/assets/ebcee82e-0026-4894-afb9-fe03720f9300" />

<img width="598" alt="image" src="https://github.com/user-attachments/assets/5279f41e-6b14-42d1-a3be-5208916a0997" />

- 버전 정보는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전으로 표기
  - HTTP/2.22 버전은 HTTP/2.3 보다 큼

### 3.2.3 헤더

- 요청/응답 메시지에 추가 정보를 더하며 기본적으로 이름/값 쌍의 목록
- 헤더 종류
  - 일반 헤더: 요청/응답 양쪽에 모두 나타날 수 있음
  - 요청 헤더: 요청에 대한 부가 정보 제공
  - 응답 헤더: 응답에 대한 부가 정보 제공
  - Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체 서술
  - 확장 헤더: 명세에 정의되지 않은 새로운 헤더
- **헤더 문법**: `이름: 필드값(CRLF)` (공백은 선택값)
- 헤더 여러 줄로 작성 시 추가 줄 앞에는 공백 / 탭 문자 와야함

<img width="601" alt="image" src="https://github.com/user-attachments/assets/89aa309b-efad-41fe-9486-f59eb3220b28" />

### 3.2.4 엔터티 본문

- 데이터 예) 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등

### 3.2.5 버전 0.9 메시지

<img width="574" alt="image" src="https://github.com/user-attachments/assets/25ef38c9-0d50-4e59-86f2-ccfbb0a6128a" />

- 요청: 메서드 + 요청 URL
- 응답: 엔터티로만 구성됨

## 3.3 메서드

- HTTP/1.1: 서버는 GET, HEAD 메서드만 구현해도 조건 충족함

### 3.3.1 안전한 메서드

- **GET, HEAD 메서드**: HTTP 요청으로 인해 서버에 작용하는 일이 없기 때문에 안전하다고 할 수 있음
  - 100% 보장은 못함, 서버 개발자에게 달려있음
- 목적: 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 알려주기 위함

### 3.3.2 GET

- 서버에게 리소스를 달라고 요청하기 위해 사용

<img width="578" alt="image" src="https://github.com/user-attachments/assets/138f443f-81ce-4ca3-bb1d-07b50c234f32" />

### 3.3.3 HEAD

- GET처럼 행동하지만 서버는 응답으로 헤더만 돌려줌
- 엔티티 본문은 반환되지 않음
- **HEAD 사용 시 특징**
  - 리소스를 가져오지 않고도 리소스에 대해 알아낼 수 있음 (e.g. 리소스 타입)
  - 응답 상태 코드를 통해 개체가 존재하는지 알 수 있음
  - 헤더를 확인하여 리소스가 변경되었는지 검사 가능
- 서버 개발자는 GET 메서드 사용 시의 헤더와 일치함을 보장해야함
- HTTP/1.1 준수 ➡️ HEAD 메서드 반드시 구현되어 있어야함

<img width="575" alt="image" src="https://github.com/user-attachments/assets/a8ca8434-e4e0-42f0-9254-bac632d74fcf" />

### 3.3.4 PUT

- 서버에 문서를 쓰는 메서드
- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체함

<img width="574" alt="image" src="https://github.com/user-attachments/assets/27c69792-27d0-4294-bd2c-1a55a09a2058" />

> Q. 근데 그럼 POST 사용 안해도 되는거 아닌가? 정확한 차이점이 뭐지?

### 3.3.5 POST

- 서버에 입력 데이터를 전송하기 위해 사용하는 메서드
- 서버로 전송된 데이터를 필요로 하는 곳 (e.g. 데이터를 처리할 서버 게이트웨이)에 전송

<img width="576" alt="image" src="https://github.com/user-attachments/assets/a7c323f0-a2a6-4556-a7a7-e170262158b3" />

### 3.3.6 TRACE

- 주로 진단을 위해 사용되는 메서드,
- 다른 애플리케이션의 요청이 어떤 영향 미치는지 확인하고자 사용하는 메서드
- 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌

1. 클라이언트 ➡️ 방화벽, 프락시, 게이트웨이 등 (**원래의 HTTP 요청 수정 가능**) ➡️ 서버
2. 서버에서 루프백(loopbac) 진단 ➡️ 자신이 받은 요청 메시지 본문에 넣어 TRACE 응답 되돌려 줌
3. 그러면 클라이언트는 클라이언트 ↔️ 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가며 망가짐/수정/변경 추적 가능

<img width="575" alt="image" src="https://github.com/user-attachments/assets/b31e5300-b3f2-4fd5-b94a-0125d15c38ce" />

- TRACE는 메서드를 구별하는 매커니즘을 제공하지 않기 때문에 보통 중간 애플리케이션이 동작에 대한 결정 내림
- TRACE 요청: 엔터티 본문 보낼 수 없음
- TRACE 응답: 엔터티 본문에 서버가 받은 요청 그대로 들어가 있음

### 3.3.7 OPTIONS

- 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어보는 메서드
- 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음

<img width="577" alt="image" src="https://github.com/user-attachments/assets/be1c5aa9-9448-46b0-91aa-031fa9977e73" />

### 3.3.8 DELETE

- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청하는 메서드

  - 삭제가 수행되지 않을 수도 있음: HTTP 명세에서 서버가 클라이언트 요청을 알리지 않고 무시하는 것 허용하기 때문

  <img width="576" alt="image" src="https://github.com/user-attachments/assets/0b72790d-6340-4c4a-9ad3-b7e0c6d25447" />

### 3.3.9 확장 메서드

- HTTP/1.1 명세에 정의되지 않은 메서드
- 프락시는 잘 모르는 메서드라면 다운스트림 서버로 전달하고, 전달이 불가능한 경우에만 501 Not Implemented 상태 코드를 보내는 것을 권장함

<img width="592" alt="image" src="https://github.com/user-attachments/assets/060aa5c7-eeb9-4811-87fa-2233a2c5a39b" />
<img width="591" alt="image" src="https://github.com/user-attachments/assets/d7dc7caf-6330-4e1b-9b19-3ab5780660f9" />
