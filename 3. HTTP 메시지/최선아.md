# 3. HTTP 메시지

애플리케이션 간에 주고받는 데이터 블록

## 3.1 메시지의 흐름

메시지는 클라이언트, 서버, 프락시 사이를 흐름

### 3.1.1 인바운드와 아웃바운드

![image](https://github.com/user-attachments/assets/5033f10a-cf74-443d-b7b9-5e383c8b803b)

**인바운드**

- 클라이언트 -> 서버로 메시지 전송

**아웃바운드**

- 서버 -> 클라이언트로 메시지 전송

### 3.1.2 업스트림과 다운스트림

![image](https://github.com/user-attachments/assets/fb51505e-b030-4c3a-86d9-555315b58657)

- 요청에서는 프락시 1이 프락시 3의 업스트림이지
  만 응답에서는 프락시 1이 프락시 3의 다운스트림임

**업스트림**

- 메시지의 발송자는 수신자의 업스트림

**다운스트림**

- 모든 메시지는 다운스트림으로 흐름

## 3.2 메시지의 각 부분

![image](https://github.com/user-attachments/assets/b324e422-15a7-4010-9550-e9e32ace27f3)

### 시작줄

- 메시지의 종류를 나타내는 첫 줄
- 요청 또는 응답 정보 포함
- 아스키 문자열
- 필수 요소

### 헤더

- Content-Type, Content-Length 등 메시지 속성 정보
- 아스키 문자열
- 각 줄은 CRLF(캐리지 리턴+개행)로 구분

### 본문

- 실제 데이터가 들어가는 부분
- 텍스트나 이진 데이터 포함 가능
- 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 전자우편 등 여러 종류의 디지털 데이터 실어나를 수 있음

### 3.2.1 메시지 문법

![image](https://github.com/user-attachments/assets/071e3331-0cad-47d1-a71f-dc40c8c2fb3e)

#### 요청 메시지

##### 형식

```
＜메서드＞ ＜요청 URL＞ ＜버전＞
＜헤더＞

＜본문>
```

##### 메서드

![image](https://github.com/user-attachments/assets/a57ddb00-3794-42ee-aa0f-ecf5ae15fe25)

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 메서드에 따라 요청 메시지 본문 유무가 다름
- 확장 메서드: HTTP는 쉽게 확장 가능 하기 때문에 서버 자체적으로로 추가 메서드 구현 가능

##### 요청 URL

- 요청하는 리소스를 지칭하는 완전한 URL 또는 URL의 경로 구성요소
- 요청 URL이 완전한 URL이 아니라면 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주

##### 버전

- 사용중인 HTTP 버전을 나타냄
- 애플리케이션이 지원하는 최고 버전을 표시 (ex. 난 2.0까지 지원할 수 있어)
- 아래와 같은 형식이고 메이저와 마이너는 모두 정수임
  ```
  HTTP/<메이저>.<마이너>
  ```
- 상호간의 기능 호환성을 파악하기 위함
- 상위 버전이 하위 버전의 기능을 사용해야 함
  (HTTP/1.2는 HTTP/1.1과 통신 시 1.1 기능만 사용)

##### 헤더

![image](https://github.com/user-attachments/assets/f5c0a6bb-f0c8-422a-a93e-9a39bb8277d5)

- 아래와 같이 `이름, 콜론(:), 선택적 공백, 값, CRLF가 순서대로 나타남

  ```
  이름: 값

  ```

- 필드가 0개 이상 존재함
- 긴 헤더 줄은 여러 줄로 쪼갤 수 있는데, 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭을 둬야 함

  ```
  HTTP/1.0 200 OK
  Content-Type: image/gif
  Content-Length: 8572
  Server: Test Server
      Version 1.0

  ```

- 헤더는 빈 줄(CRLF)로 끝나 헤더의 끝과 본문의 시작을 구분함
- 특정 버전의 HTTP는 요청이나 응답에 특정 헤더가 포함돼야 유효한 것으로 간주함

###### 헤더 분류

- 일반 헤더

  - 요청과 응답 양쪽에 모두 나타날 수 있음
    ```
    Date: Tue, 15 Nov 2023 08:12:31 GMT
    Connection: keep-alive
    Cache-Control: no-cache
    ```

- 요청 헤더

  - 요청에 대한 부가 정보 제공
    ```
    Host: www.example.com
    User-Agent: Mozilla/5.0
    Accept: text/html
    Cookie: sessionId=abc123
    ```

- 응답 헤더

  - 응답에 대한 부가 정보 제공
    ```
    Server: nginx/1.18.0
    Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2023 07:28:00 GMT
    WWW-Authenticate: Basic
    ```

- Entity 헤더

  - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
    ```
    Content-Type: text/html; charset=UTF-8
    Content-Length: 1024
    Content-Encoding: gzip
    Last-Modified: Tue, 15 Nov 2023 12:45:26 GMT
    ```

- 확장 헤더
  - 애플리케이션은 자체 헤더 만들어낼 수 있음
  - 명세에 정의되지 않은 새로운 헤더
    ```
    X-Powered-By: PHP/7.4.0
    X-RateLimit-Limit: 100
    X-Custom-Header: SomeValue
    ```

##### 본문

![image](https://github.com/user-attachments/assets/0a10010b-2e57-467f-ab6d-821eb1847b82)

- 없을 수도 있음 (선택적)
- 본문이 없어도 헤더 뒤에 CRLF는 필요
- 참고) 본문이 없는 경우, 클라이언트와 서버는 규칙에 따라 마지막 CRLF가 있어야 하지만 없는 메시지도 호환성을 위해 처리할 수 있어야 함

#### 응답 메시지

##### 형식

```
＜버전＞ ＜상태 코드＞ ＜사유 구절＞
＜헤더＞

＜본문＞
```

##### 상태 코드

![image](https://github.com/user-attachments/assets/4dec4760-5f57-464e-bc8c-6c32cfae81d4)

![image](https://github.com/user-attachments/assets/aac72af9-e6c5-408a-9e0a-ed5712de83d9)

- 서버가 클라이언트에게 요청에 대한 처리 결과를 알려주는 3자리 숫자
- ex) 200(성공), 404(클라이언트 에러)

##### 사유 구절

- 숫자인 상태 코드의 의미를 글로 설명해주는 짧은 문구
- 단순 설명 목적이어서 사유가 다르더라도 상태 코드가 같다면 똑같이 처리됨
- HTTP 명세는 사유 구절에 대한 엄경한 규칙이 없음
- ex) HTTP/1.0 200 `OK`

### 3.2.5 버전 0.9 메시지

- HTTP의 초기 버전
- 요청은 메서드와 URL만 있고 응답은 본문만 있는 매우 단순한 구조
- 버전 정보, 상태 코드, 헤더가 없어 현대적 용도로는 제한적입니다.

## 3.3 메서드

### 3.3.1 안전한 메서드

- 서버에 상태 변화를 일으키지 않는 메서드
- ex) GET, HEAD

**목적**

- 서버에 변화를 주는 안전하지 않은 메서드(예: POST) 사용 시 사용자에게 알리기 위함
- ex) 결제 버튼 클릭 시 경고 메시지 표시

**주의**

- 안전한 메서드는 서버에 변경을 일으키지 않아야 하지만, 실제 구현은 개발자에 달려있어 완벽히 보장되지는 않음음

### 3.3.2 GET

![image](https://github.com/user-attachments/assets/eba425c0-1fb9-440b-a22f-9bd3cf741cdf)

- 가장 많이 사용되는 메서드
- 서버에게 리소스를 요청하는 메서드
- HTTP/1.1에서 필수 구현 메서드

### 3.3.3 HEAD

![image](https://github.com/user-attachments/assets/2e186648-9ef6-408b-8bf5-9f2dd93279f4)

- GET과 동일하게 동작하지만 본문 없이이 헤더만 반환
- 리소스의 정보(타입 등), 존재 여부, 변경 여부 확인가능
- HTTP/1.1에서 필수 구현
- GET과 동일한 헤더 반환 보장해야 함

### 3.3.4 PUT

![image](https://github.com/user-attachments/assets/a0532e9f-d3f1-4765-953a-57cc4aae5460)

- 요청 URL에 새 문서 생성 또는 기존 문서 교체
- 콘텐츠 변경이 가능하므로 보안 중요. 따라서 대부분 인증(로그인/비밀번호) 필요

### 3.3.5 POST

![image](https://github.com/user-attachments/assets/a0532e9f-d3f1-4765-953a-57cc4aae5460)

- 서버에 입력 데이터(HTML 폼) 전송하기 위해 사용함

### 3.3.6 TRACE

![image](https://github.com/user-attachments/assets/a08277d1-0134-4255-a616-6c9bdcafc19d)

- 클라이언트의 요청이 서버로 전달되는 과정에서 어떻게 변경되었는지 확인하고 진단하기 위한 메서드
- 요청에 엔티티 본문 보낼 수 없음
- 동작 방식:
  - 서버는 받은 요청을 그대로 응답 본문에 넣어서 반환함 ('루프백')
- 한계:

  - 단순히 "요청이 어떻게 변했는지"만 볼 수 있고, 실제 서버나 중간 시스템이 어떻게 동작하는지 자세히 파악하기는 어려움

  ```
  // TRACE는 단순히 요청을 그대로 반환
  TRACE /api HTTP/1.1  ->  똑같은 요청을 응답으로 받음

  // 실제 상황에서는
  GET /api -> 캐시를 확인할 수 있음
  POST /api -> 바로 서버로 전달

  // But TRACE로는 이런 차이를 알 수 없음
  TRACE /api -> 그냥 요청을 반사하기만 함
  ```

### 3.3.7 OPTIONS

![image](https://github.com/user-attachments/assets/dadbf1b8-fb9d-49f7-bcb2-451543cc563a)

- 특정 리소스에 대해 서버가 지원하는 메서드를 제공함
- 실제 리소스 접근 없이 확인 가능

### 3.3.8 DELETE

![image](https://github.com/user-attachments/assets/bfeb2dab-b831-4ea4-8990-6cdbe0ab54e9)

- 서버에게 요청 URL로 지정한 리소스 삭제를 요청함

### 3.3.9 확장 메서드

**정의**

- HTTP는 확장이 가능하도록 설계되어 확장해도 과거 구현된 소프트웨어들과의 호환성을 유지함.
- 확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드로, 서버 리소스 관리 기능을 확장하는 수단을 제공.
- 예: WebDAV 확장 메서드 (LOCK, MKCOL, COPY, MOVE 등).

**예시**

- LOCK: 리소스를 잠가 편집 충돌 방지.
- MKCOL: 문서 생성.
- COPY: 리소스를 복사.
- MOVE: 리소스를 이동.

**주의사항**

- 대부분의 HTTP 애플리케이션은 사용자 정의 확장 메서드를 이해하지 못하므로, 이를 사용할 때는 관용적인 태도가 권장됩
  - 프락시는 알 수 없는 메서드를 가능한 한 다운스트림 서버로 전달.
  - 불가능하면 501 Not Implemented 상태 코드 반환.
- "엄격하게 보내고 관대하게 받아들여라" 규칙 따르기
