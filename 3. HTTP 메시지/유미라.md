# 1. 메시지의 흐름 
## 인바운드와 아웃바운드

![image](https://github.com/user-attachments/assets/89f05023-d393-4c9c-a753-d1c923e46d1a)

### 인바운드
- 클라이언트 → 서버로 메시지가 전송되는 과정
### 아웃바운드
- 서버 → 클라이언트로 메시지가 돌아오는 과정

## 업스트림과 다운스트림

![image](https://github.com/user-attachments/assets/20d9e43f-82d4-44dc-8a1e-a1549c835553)

### 업스트림
- 메시지의 발송자는 수신자의 업스트림이다

### 다운스트림
- 모든 메시지는 다운스트림으로 흐른다

# 2. 메시지의 각 부분

## 요청 메시지
### 요청 메시지 형식
```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

### 메서드
- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 모든 서버가 아래 메서드를 모두 구현하지 않는다

![많이 쓰이는 HTTP 메서드](https://github.com/user-attachments/assets/9fcaf443-1507-4952-b503-2cdf092279af)

### 요청 URL
- 리소스를 지칭하는 완전한 URL 또는 URL의 경로 구성요소

## 버전 번호 
- 클라이언트가 지원하는 가장 높은 HTTP 버전
- `HTTP/<메이저>.<마이너> 형식`

## 응답 메시지
### 응답 메시지 형식
```
<버전> <상태코드> <사유 구절>
<헤더>

<엔터티 본문>
```

### 상태 코드
- 서버가 요청에 대해 처리한 결과

![image](https://github.com/user-attachments/assets/c86b6d7e-3fd8-4654-82b9-4a16ce50eaed)

- 상태 코드는 세 자리 숫자로 표현되며, 이를 기준으로 그룹화된다

![image](https://github.com/user-attachments/assets/1664cb01-faa5-41f1-99f0-00308b0e1590)

### 사유 구절
- 상태 코드에 대한 글로 된 설명을 제공한다
- 사유 구절에는 엄격한 규칙이 없다

## 헤더
- 요청과 응답메시지에 대한 추가 정보
- 0개 이상의 HTTP 헤더가 포함될 수 있다
- 헤더 목록은 `빈 줄(CRLF)`로 끝나며, 이는 헤더 목록의 끝과 엔터티 본문의 시작을 구분한다

![image](https://github.com/user-attachments/assets/05b58d1c-f913-4680-bded-70e968ba07df)

### 헤더 분류
- **일반 헤더** : 요청과 응답 양쪽에 모두 나타날 수 있음
- **요청 헤더** : 요청에 대한 부가 정보를 제공
- **응답 헤더** : 응답에 대한 부가 정보를 제공
- **Entity 헤더** : 본문 크기와 콘텐츠,혹은 리소스 그 자체를 서술
- **확장 헤더** : 명세에 정의되지 않은 새로운 헤더

## 엔터티 본문
- 전달하고자 하는 디지털 데이터

> ## 참고 : 버전 0.9 메시지
> ![image](https://github.com/user-attachments/assets/7c46b82e-164f-49fc-b833-bb587303c379)
> - **요청** : `<메서드> <요청 URL>`
> - **응답** : 오직 엔터티 본문만 포함

# 3. 메서드
## 안전한 메서드
- 클라이언트가 HTTP 요청을 보낼 때 서버의 상태나 리소스를 변경하지 않는 메서드
- 예 : `GET`, `HEAD` 등

> **안전성**은 HTTP 메서드의 정의에 의해 보장되지 않으며, 웹 애플리케이션 개발자가 서버의 동작을 어떻게 처리하느냐에 따라 달라진다

## GET

![image](https://github.com/user-attachments/assets/4e34c4ca-e609-4750-aa61-c8c31ef1a103)

- 리소스를 요청하는 메서드

## HEAD

![image](https://github.com/user-attachments/assets/5d01acfb-ec9b-4f4f-b156-665325e27d94)

- `GET`처럼 동작하지만, 응답으로 헤더만 반환된다
- 주로 리소스의 상태를 확인하거나 메타데이터를 조회하는데 사용된다

## PUT

![image](https://github.com/user-attachments/assets/ad194b25-272a-4c42-88f4-991cb538ba0f)

- 요청 URL에 리소스가 존재하지 않으면 새로운 리소스를 생성한다
- 요청 URL에 이미 리소스가 존재하면 해당 리소스를 완전히 교체한다

## POST

![image](https://github.com/user-attachments/assets/f6de3406-f291-45d6-b97e-50d0d89fd81e)

- 서버에 데이터를 보내기 위해 사용한다

> ### PUT과 POST의 차이
> PUT: 동일한 PUT 요청을 여러 번 보내더라도 결과가 동일하다.
> POST: 같은 POST 요청을 여러 번 보내면 결과가 달라질 수 있다.

## TRACE

![image](https://github.com/user-attachments/assets/ca5be011-bc3f-4349-8be4-5fb5f2a69459)

- 클라이언트가 서버에 보낸 요청 메시지가 중간에서 변경되었는지 확인하기 위해 서버가 받은 요청을 그대로 응답으로 되돌려준다
- 주로 진단을 위해 사용된다
- TRACE 요청은 서버나 네트워크 인프라의 설정에 따라 다르게 처리될 수 있다 

## OPTIONS

![image](https://github.com/user-attachments/assets/f9ede185-fb5b-4cf1-889c-bd78cd9a2bf1)

- 서버가 지원하는 메서드 및 리소스에 대한 기타 옵션을 확인할 때 사용된다

## DELETE

![image](https://github.com/user-attachments/assets/fa93c1cc-2d6e-4177-8685-f057324b85e6)

- 요청 URL로 지정한 리소스를 삭제하는 데 사용된다

## 확장 메서드

- HTTP/1.1 명세에 정의되지 않은 메서드
- HTTP는 필요에 따라 확장할 수 있도록 설계되었다
- 예 : `LOCK`, `MKCOL`, `COPY`, `MOVE` 등
- 확장 메서드는 형식이 정해져 있지 않아 대부분의 HTTP 애플리케이션에서 이해하지 못할 수 있다